<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>22年微软秋招笔试</title>
    <url>/archives/de00e3bc.html</url>
    <content><![CDATA[<div class="note primary">
            <p>微软笔试一共四轮，攒人品加总结一下前三轮的笔试内容，第四轮结束后会再做总结！</p><p>微软笔试共3道题，其中第一题是较为简单的，一般用贪心来做，第二题较难，第三题复杂但难度适中。</p>
          </div>
<span id="more"></span>
<h2 id="第一轮220806">第一轮：220806</h2>
<h3 id="填坑修路问题贪心">1. 填坑修路问题（贪心）</h3>
<ul>
<li><p>题目描述：给定一条路S和材料B份，已知路上有很多坑，用'x'表示，平路用'.'表示，我们的任务就是填坑，连续的n个坑所需要的材料是n+1份，共有B份材料，问最多可填多少坑？</p></li>
<li><p>样例：<code>S = &quot;...xxx..x....xxx&quot;, B = 7</code>，此时可填5个坑</p></li>
<li><p>解题思路：因为每填连续的n个坑都需要额外的1份材料，因此贪心策略就是尽可能先填长坑，再填短坑</p>
<ul>
<li>技巧：用优先队列存储坑的长度</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(string &amp;S, <span class="keyword">int</span> B)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++ (C++14 (g++ 6.2.0))</span></span><br><span class="line">    <span class="keyword">if</span>(B &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// cout &lt;&lt; S &lt;&lt; B &lt;&lt; endl;</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">// store the needs of each consecutive potholes</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;S.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(S[i]==<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sep++;</span><br><span class="line">            sum++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sep &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; sep + 1;</span></span><br><span class="line">            pq.<span class="built_in">push</span>(sep+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = pq.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(B&lt;=<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> sep = pq.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(B&gt;=sep) </span><br><span class="line">        &#123;</span><br><span class="line">            B -= sep;</span><br><span class="line">            res += sep<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += B<span class="number">-1</span>;</span><br><span class="line">            B = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>贪心</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>仗剑篇：进阶数据结构（树+图）</title>
    <url>/archives/4c55038.html</url>
    <content><![CDATA[<div class="note primary">
            <p>开启仗剑篇！加油！ 原论文为Java版本，我这里选择用C++实现，同时记录自己的一些思考</p>
          </div>
<p><span id="more"></span></p>
<p>## 1.1 二叉树</p>
<div class="note primary">
            <p>解题时只用思考每个节点需要做什么？ 递归解题思路：</p><ol type="1"><li>回溯：遍历一遍二叉树得出结果（辅助全局变量）</li><li>动归：拆解为子问题，并根据子问题的解推断问题的解</li></ol>
          </div>
<ul>
<li><p>递归遍历：二叉树的遍历和写for循环遍历数组和链表没有本质区别，只不过这里用了递归的思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == null) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>### 链表操作的递归思维一览：用递归不用迭代 <div class="note primary">
            <p>例题：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
          </div></p>
<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基本数据结构</tag>
        <tag>二叉树</tag>
        <tag>图</tag>
        <tag>算法tricks</tag>
      </tags>
  </entry>
  <entry>
    <title>学剑篇：基本数据结构</title>
    <url>/archives/a3522716.html</url>
    <content><![CDATA[<blockquote>
<p>发现labuladong算法秘籍真的不错，已经跟着刷了一段时间题了，打算总结一下，先从第一篇学剑开始吧！加油！具体可以参考<a href="https://labuladong.gitee.io/algo/">原网站</a></p>
<p>原论文为Java版本，我这里选择用C++实现，同时记录自己的一些思考</p>
</blockquote>
<span id="more"></span>
<h2 id="数组链表">1.1 数组+链表</h2>
<h3 id="田忌赛马背后的算法决策">田忌赛马背后的算法决策：</h3>
<blockquote>
<p>例题：<a href="https://leetcode.cn/problems/advantage-shuffle/">870. 优势洗牌</a></p>
</blockquote>
<ul>
<li><p><strong>解题思路</strong>：</p>
<ul>
<li>如果当前最快的马可以比过对方最快的马，则用该马来比赛
<ul>
<li>误区：如果第二快的马也可以比过对方，是否可以选择这一匹来比？<strong>可以但没必要</strong>，因为这样的话我最快的一匹还是比对方第二最快的马快</li>
</ul></li>
<li>如果当前最快的马比不过对方最快的马，则用最烂的一匹来比</li>
</ul></li>
<li><p><strong>实现trike</strong>：</p>
<ul>
<li>因为nums2不能改变顺序，但又需要他从大到小排列（方便后面比较），因此选用priority_queue来重新存储nums2，但这里需要把下标i以及数值num一起存储，并且用num来比大小，因此需要重载operator&lt;运算符</li>
<li>nums1也要排序，这里选用升序排序，left为最小值，right为最大值</li>
<li>双指针来收缩nums1的两端，如果nums2当前最大值大于nums1[right]，则用left对应的马，反之则用right对应的马</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">advantageCount</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 定义结构体：用来自定义优先队列比较规则</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">id_nums2</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">int</span> num;</span><br><span class="line">            <span class="built_in">id_nums2</span>(<span class="keyword">int</span> j, <span class="keyword">int</span> x)</span><br><span class="line">            &#123;</span><br><span class="line">                i = j;</span><br><span class="line">                num = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> id_nums2&amp; a) <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> num &lt; a.num; <span class="comment">// 大顶堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 对nums2数组建立优先队列</span></span><br><span class="line">        priority_queue&lt;id_nums2&gt; nums2pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums2.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums2pq.<span class="built_in">push</span>(<span class="built_in">id_nums2</span>(i, nums2[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums1.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums1.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>()); <span class="comment">// 从小到大排序</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = nums2pq.<span class="built_in">top</span>().i;</span><br><span class="line">            <span class="keyword">int</span> num = nums2pq.<span class="built_in">top</span>().num;</span><br><span class="line">            nums2pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// nums1能打过</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[right]&gt;num)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i] = nums1[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[i] = nums1[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：前期排序为O(nlogn)，后续仅遍历一次队列，时间复杂度为O(nlogn)，因为共n个元素，调整最大堆的复杂度为O(logn)，其他操作为O(1)，因此时间复杂度为O(nlogn)。空间复杂度为O(n)因为需要新开辟优先队列和res</p></li>
</ul>
<h3 id="链表操作的递归思维一览用递归不用迭代">链表操作的递归思维一览：用递归不用迭代</h3>
<blockquote>
<p>例题：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li><strong>reverse函数</strong>：输入一个节点head，将以head为起点的链表反转，并返回反转后的头节点</li>
</ul></li>
<li><p>解题tricks：</p>
<ul>
<li><strong>不要跳进递归，而是要根据刚才的函数定义，来弄清楚这段代码会产生什么结果</strong></li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = <span class="built_in">reverse</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：只遍历一遍链表，因此时间复杂度为O(n)，空间复杂度为O(n)，因为递归的底层实现是栈，而栈的大小是n（压入所有的节点）</p></li>
</ul>
<blockquote>
<p>例题：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>先尝试解决反转前N个node</li>
<li>定义reverseN(head, N)函数，输入节点head，以及要反转的节点个数N，返回前N个节点反转，后面节点顺序不变的链表的链表头</li>
</ul></li>
<li><p>解题tricks：</p>
<ul>
<li>定义successor，用来指向要反转的最后一个node的下一个node，好把第一个node指向successor上。</li>
<li>在left不等于1时，反复调用原函数，使得head向后移动的同时，缩小left和right，当left为1时再调用reversN函数，最后将head-&gt;next指向reverseN的返回值（链表头）</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode *successor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> m)</span> <span class="comment">// 反转前M个节点，并返回反转后链表的头节点</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            successor = head-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = <span class="built_in">reverseN</span>(head-&gt;next, m<span class="number">-1</span>);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = successor;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right); <span class="comment">// 从left节点开始反转</span></span><br><span class="line">        head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next, left<span class="number">-1</span>, right<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：只遍历一遍，时间复杂度为O(n)，空间复杂度为O(n)</p></li>
</ul>
<h2 id="队列栈">1.3 队列&amp;栈</h2>
<h3 id="用栈解决括号问题">用栈解决“括号问题”</h3>
<blockquote>
<p>例题1：<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>如果仅有一种括号，只用记录左括号的数量即可</li>
<li>但多种括号时，无法通过计数来完成，比如&quot;([)]&quot;是不合法的，此时需要借助栈（后进先出）来完成</li>
<li>当输入为左括号时，压入栈中；当输入为右括号时，比较栈顶和右括号是否匹配
<ul>
<li>匹配时，pop出栈顶元素</li>
<li>不匹配或栈为空时，return false</li>
</ul></li>
</ul></li>
<li><p>解题tricks：</p>
<ul>
<li><p>遍历字符串：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    s[i];</span><br><span class="line">&#125;</span><br><span class="line">方法二：<span class="keyword">auto</span>类型</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">&#123;</span><br><span class="line">    c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span> || s[i]==<span class="string">&#x27;[&#x27;</span> || s[i]==<span class="string">&#x27;&#123;&#x27;</span>) left.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(left.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>((s[i]==<span class="string">&#x27;)&#x27;</span> &amp;&amp; left.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">                   || (s[i]==<span class="string">&#x27;]&#x27;</span> &amp;&amp; left.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>) </span><br><span class="line">                   || (s[i]==<span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; left.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span>)) </span><br><span class="line">                    left.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：时间复杂度为O(N)，空间复杂度为O(N)</p></li>
</ul>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">921. 使括号有效的最少添加</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>思路一：用栈来解决，碰到不匹配时说明左括号不够用，当最后结束时栈没空，证明左括号太多了</li>
<li>思路二：不用栈，用两个变量记录左括号的数量以及res即可，思路同上</li>
</ul></li>
<li><p>解题tricks：最后要记得加上栈中残留的左括号</p></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; left;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>) left.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(left.<span class="built_in">empty</span>()) res++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += left.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：时间空间复杂度均为O(N)，但空间复杂度可以降到O(1)</p></li>
</ul>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/">1541. 平衡括号字符串的最少插入次数</a> 1个左括号和2个右括号匹配</p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>不用栈：left记录当前有多少个左括号，以及res目前添加了多少个括号了
<ul>
<li>如果当前为左括号，left++</li>
<li>如果为右括号
<ul>
<li>判断当前左括号是否为空，空的话则在当前位置左侧添加一个左括号</li>
<li>不为空时，判断当前位置的下一个位置是否为右括号
<ul>
<li>如果是，则不用添加任何操作，把left--，然后i++（跳过下一个位置）</li>
<li>如果不是，则需要在后侧加入一个右括号，即res++，同时减去匹配的左括号left--</li>
</ul></li>
</ul></li>
<li>最后剩下的左括号需要用2倍的右括号来匹配</li>
</ul></li>
<li>用栈：也可以完成</li>
</ul></li>
<li><p>解题tricks：</p></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(left==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;)&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    left--;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span> || i==s.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">2</span>*left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：时间复杂度为O(N)，空间为O(1)</p></li>
</ul>
<h3 id="单调栈结构解决下一个更大数问题">单调栈结构解决“下一个更大数问题”</h3>
<blockquote>
<p>单调栈解决的就是The Next Greater Number问题，适用范围还是比较窄的，但是遇到这类问题就要用这个方法</p>
</blockquote>
<ul>
<li><p>模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="comment">// 从后向前遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) <span class="comment">// 当有循环数组出现时，可以遍历两遍，用%符号</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; nums[i]&gt;=s.<span class="built_in">top</span>()) <span class="comment">// 如果当前值小于栈顶值，则压入栈，否则pop栈顶元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    res[i] = s.<span class="built_in">empty</span>()? <span class="number">-1</span>:s.<span class="built_in">top</span>(); <span class="comment">// 这里res存储nums的值，其实有些题目也可以存储下标</span></span><br><span class="line">    s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>建立单调栈，先把nums2中的数组从后向前遍历，同时将数值压入栈中，使栈呈现由大到小的排列，此时栈顶即为下一个更大的元素</li>
</ul></li>
<li><p>解题tricks：</p>
<ul>
<li>用哈希表来存储&lt;数值，下一个更大元素值&gt;，这样遍历nums1时就可以直接找到对应的答案了</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) </span><br><span class="line">    &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; hm;</span><br><span class="line">        vector&lt;int&gt; res(nums1.size(), -1);</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for(int i=nums2.size()-1; i&gt;=0; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            while(!s.empty() &amp;&amp; s.top()&lt;=nums2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            hm[nums2[i]] = s.empty() ? -1:s.top();</span><br><span class="line">            s.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0; i&lt;nums1.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = hm[nums1[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：因为每个元素只会被push和pop一次，因此时间复杂度为O(n)，空间复杂度因为是栈结构，且返回值也是数值，因此为O(n)</p></li>
</ul>
<blockquote>
<p><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>沿用单调栈的思路，找到下一个更大的数值，但这里设计循环数组，一般这个时候可以复制一份到原数组后面，然后就可以了</li>
</ul></li>
<li><p>解题tricks：<strong>没必要复制一份，可以遍历2n次，然后i用%n的值就可以达到相同的目的了</strong></p></li>
<li><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; res(n);</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for(int i= 2*n-1; i&gt;=0; --i) // 假设复制了一份</span><br><span class="line">        &#123;</span><br><span class="line">            while(!s.empty() &amp;&amp; s.top()&lt;=nums[i%n]) // 用%来求相应的坐标</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            if(!s.empty()) res[i%n] = s.top();</span><br><span class="line">            else res[i%n] = -1;</span><br><span class="line">            s.push(nums[i%n]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：时间空间也都是O(n)</p></li>
</ul>
<blockquote>
<p><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></p>
</blockquote>
<ul>
<li><p>解题思路：同上</p></li>
<li><p>解题tricks：栈中存储下一个更大元素的下标，这样方便计算距离，同时用下标也可以找到当日的温度</p></li>
<li><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; res(temperatures.size(), 0);</span><br><span class="line">        stack&lt;int&gt; s; // 存放next greater number的下标</span><br><span class="line">        for(int i=temperatures.size()-1; i&gt;=0; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            while(!s.empty() &amp;&amp; temperatures[s.top()]&lt;=temperatures[i])</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            if(!s.empty()) res[i] = s.top() - i;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：时间空间复杂度是O(n)</p></li>
</ul>
<h3 id="单调队列解决滑动窗口最大值">单调队列解决“滑动窗口最大值”</h3>
<blockquote>
<p>单调队列的实现方式使用STL中的deque类，中文是双向队列，意思是两边都可以进出，在进出的过程中保证队列是单调递减（增）的就可以</p>
</blockquote>
<blockquote>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>思路一：用优先队列，滑动窗口内的值和下标作为pair压入最大堆中，first为值，因为优先队列先对pair的首个元素排序。for循环在外侧遍历所有的窗口右端点，while内循环来判断最大值是否在滑动窗口内部，不在的话需要都pop出去。</li>
<li>思路二：用单调队列，<a href="https://leetcode.cn/problems/sliding-window-maximum/solution/dong-hua-yan-shi-dan-diao-dui-lie-239hua-hc5u/">解题参考</a>
<ul>
<li>遍历给定数组中的元素，如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。直到，队列为空或当前考察元素小于新的队尾元素</li>
<li>当队首元素的下标小于滑动窗口左侧边界left时，表示队首元素已经不再滑动窗口内，因此将其从队首移除</li>
<li>由于数组下标从0开始，因此当窗口右边界right+1大于等于窗口大小k时，意味着窗口形成。此时，队首元素就是该窗口内的最大值</li>
</ul></li>
</ul></li>
<li><p>解题tricks：</p>
<ul>
<li>优先队列priority_queue中数据类型为pair时，先对first比大小，在对second比大小</li>
<li>双端队列deque可以从两端进行push和pop，关键字分别是back和front</li>
</ul></li>
<li><p>代码：</p>
<ul>
<li><p>思路一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 解法一：最大堆</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; k<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">pair</span>(nums[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">pair</span>(nums[i], i));</span><br><span class="line">                <span class="keyword">while</span>(pq.<span class="built_in">top</span>().second &lt; i-k+<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>思路二：可以通过存pair来做，也可以通过存下标来完成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 解法二：双向队列来实现单调队列</span></span><br><span class="line">        deque&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dq; <span class="comment">// 存储值和下标</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;nums.<span class="built_in">size</span>(); ++r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">back</span>().first &lt;= nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.<span class="built_in">emplace_back</span>(<span class="built_in">pair</span>(nums[r], r));</span><br><span class="line">            <span class="keyword">int</span> l = r-k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>().second &lt; l)</span><br><span class="line">            &#123;</span><br><span class="line">                dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r+<span class="number">1</span>&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(dq.<span class="built_in">front</span>().first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 解法二：双向队列来实现单调队列</span></span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; dq; <span class="comment">// 只存储下标</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;nums.<span class="built_in">size</span>(); ++r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt;= nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">int</span> l = r-k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; l)</span><br><span class="line">            &#123;</span><br><span class="line">                dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r+<span class="number">1</span>&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>复杂度分析：</p>
<ul>
<li>思路一的时间复杂度为O(nlogn)，因为优先队列的调整是logn的，而遍历数组是n</li>
<li>思路二的时间复杂度为O(n)，因为从元素的角度出发，每个元素只被push和pop了一次</li>
</ul></li>
</ul>
<h3 id="数组去重问题">“数组去重问题”</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>可以将题目拆分成3个问题
<ol type="1">
<li>去重</li>
<li>字符前后顺序不变</li>
<li>字典序最小</li>
</ol></li>
<li>可以尝试用栈+标记数组来解决前两个问题，即将<code>babc</code>变为<code>bac</code></li>
<li>再尝试修改上面的思路，在插入元素时用while和栈顶元素比大小，并将大的元素且后面还会出现的元素pop出来（后方是否还会出现需要用一个count数组在一开始遍历一下整个字符串，记录每个字符出现的次数）</li>
</ul></li>
<li><p>解题triks</p>
<ul>
<li>方是否还会出现需要用一个count数组在一开始遍历一下整个字符串，记录每个字符出现的次数【在循环外多遍历一遍数组不会增加复杂度，因为遍历只有O(N)复杂度】</li>
</ul></li>
<li><p>代码</p>
<ul>
<li><p>解决前两个问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicateLetters</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; S;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">inStack</span><span class="params">(<span class="number">26</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inStack[s[i]-<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            S.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            inStack[s[i]-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(S.<span class="built_in">top</span>());</span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>解决第三个问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function">string <span class="title">removeDuplicateLetters</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          stack&lt;<span class="keyword">char</span>&gt; S;</span><br><span class="line">          <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ccount</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 统计当前位置的后面元素的多少</span></span><br><span class="line">          <span class="function">vector&lt;<span class="keyword">char</span>&gt; <span class="title">inStack</span><span class="params">(<span class="number">26</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">char</span> c : s)</span><br><span class="line">          &#123;</span><br><span class="line">              ccount[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// 无论后面如何操作，当前的字符都--</span></span><br><span class="line">              ccount[s[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">              <span class="comment">// 如果当前字符已经在里面了，那就没必要把一些元素挤出来，再push它进去了。例如abca，当第二个a来时，直接跳过即可，否则就变成了a</span></span><br><span class="line">              <span class="keyword">if</span>(inStack[s[i]-<span class="string">&#x27;a&#x27;</span>]) <span class="keyword">continue</span>;</span><br><span class="line">  </span><br><span class="line">              <span class="comment">// 当前值需要被插入</span></span><br><span class="line">              <span class="comment">// 栈不为空，栈顶元素大于当前值，且栈顶元素在后面还会出现</span></span><br><span class="line">              <span class="keyword">while</span>(!S.<span class="built_in">empty</span>() &amp;&amp; S.<span class="built_in">top</span>() &gt; s[i] &amp;&amp; ccount[S.<span class="built_in">top</span>()-<span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  inStack[S.<span class="built_in">top</span>()-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">                  S.<span class="built_in">pop</span>();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 把该pop的pop走后，再把当前元素push进来</span></span><br><span class="line">              S.<span class="built_in">push</span>(s[i]); </span><br><span class="line">              inStack[s[i]-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          string res;</span><br><span class="line">          <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())</span><br><span class="line">          &#123;</span><br><span class="line">              res.<span class="built_in">push_back</span>(S.<span class="built_in">top</span>());</span><br><span class="line">              S.<span class="built_in">pop</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>复杂度分析：总共遍历了一次字符串，虽然内部有个while循环，但是所有元素只会被push和pop一次到栈内，因此时间复杂度是O(N)</p></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基本数据结构</tag>
        <tag>算法tricks</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 1 课程信息+NLP简介</title>
    <url>/archives/41b4512d.html</url>
    <content><![CDATA[<blockquote>
<p>2.22 于华为三层自习区上课</p>
<p>3.1 于华为三层自习区看下半节课回放</p>
<p>3.22</p>
</blockquote>
<span id="more"></span>
<h1 id="section"></h1>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>COMP5046 Natural Language Processing</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture * 主讲内容</title>
    <url>/archives/5cd8abdf.html</url>
    <content><![CDATA[<blockquote>
<p>记得修改标题和tag</p>
</blockquote>
<span id="more"></span>
<h1 id="section"></h1>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>COMP5046 Natural Language Processing</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer实验</title>
    <url>/archives/697052e2.html</url>
    <content><![CDATA[<blockquote>
<p>在探索网络架构的过程中，需要做很多尝试和思考，同时也需要把实验数据和对于结果的思考等记录下来，从而一点点积累感觉</p>
</blockquote>
<blockquote>
<p>最近在做本科的毕业设计，题目是足球视频中的行为关键帧检测算法设计。在实验过程中，发现有很多细小的想法，但有时一晃而过，可能是一些小的尝试，但很少会做对比试验，因此将这些想法记录下来，方便之后再做改进。</p>
</blockquote>
<span id="more"></span>
<h1 id="探究bn和ln对于vit的影响">探究BN和LN对于ViT的影响</h1>
<h3 id="对比试验一">对比试验一：</h3>
<blockquote>
<p>modify3_10 vs modify3_11: 在baseline的基础上加入TMM结构（12 3, 27 3, 40 3, 80 3）</p>
</blockquote>
<ol type="1">
<li>modify3_10：两个TMB都有跳连操作</li>
<li>modify3_11：两个TMB都没有跳连操作</li>
</ol>
<hr />
<h3 id="对比试验二">对比试验二：</h3>
<blockquote>
<p>目前全部加TAM的效果最好</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>实验</th>
<th>设置</th>
<th>screen</th>
<th>nvidia</th>
<th>参数量（万）</th>
<th>s/epoch</th>
<th>ave-mAP on V</th>
<th>ave-mAP on T</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>modify4_1</td>
<td>全部卷积后面都加入TAM</td>
<td>1</td>
<td>0</td>
<td>32</td>
<td>43</td>
<td>55.97</td>
<td>54.74</td>
</tr>
<tr class="even">
<td>modify4_2</td>
<td>只在TMM中加入TAM</td>
<td>2</td>
<td>1</td>
<td>27</td>
<td>36</td>
<td>57.92</td>
<td>54.11</td>
</tr>
<tr class="odd">
<td>modify4_3</td>
<td>只在分类网络内加入TAM</td>
<td>3</td>
<td>2</td>
<td>15</td>
<td>32</td>
<td>55.96</td>
<td>53.52</td>
</tr>
<tr class="even">
<td>modify4_4</td>
<td>所有卷积后都不加TAM</td>
<td>4</td>
<td>3</td>
<td>15</td>
<td>32</td>
<td>57.05</td>
<td>54.98</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>OCR实验</title>
    <url>/archives/36aea8fe.html</url>
    <content><![CDATA[<blockquote>
<p>在探索网络架构的过程中，需要做很多尝试和思考，同时也需要把实验数据和对于结果的思考等记录下来，从而一点点积累感觉</p>
</blockquote>
<span id="more"></span>
<h1 id="探究backbone对于ocr的影响">探究Backbone对于OCR的影响</h1>
<h3 id="对比试验一">对比试验一：</h3>
<blockquote>
<p>modify3_10 vs modify3_11: 在baseline的基础上加入TMM结构（12 3, 27 3, 40 3, 80 3）</p>
</blockquote>
<ol type="1">
<li>modify3_10：两个TMB都有跳连操作</li>
<li>modify3_11：两个TMB都没有跳连操作</li>
</ol>
<hr />
<h3 id="对比试验二">对比试验二：</h3>
<blockquote>
<p>目前全部加TAM的效果最好</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>实验</th>
<th>设置</th>
<th>screen</th>
<th>nvidia</th>
<th>参数量（万）</th>
<th>s/epoch</th>
<th>ave-mAP on V</th>
<th>ave-mAP on T</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>modify4_1</td>
<td>全部卷积后面都加入TAM</td>
<td>1</td>
<td>0</td>
<td>32</td>
<td>43</td>
<td>55.97</td>
<td>54.74</td>
</tr>
<tr class="even">
<td>modify4_2</td>
<td>只在TMM中加入TAM</td>
<td>2</td>
<td>1</td>
<td>27</td>
<td>36</td>
<td>57.92</td>
<td>54.11</td>
</tr>
<tr class="odd">
<td>modify4_3</td>
<td>只在分类网络内加入TAM</td>
<td>3</td>
<td>2</td>
<td>15</td>
<td>32</td>
<td>55.96</td>
<td>53.52</td>
</tr>
<tr class="even">
<td>modify4_4</td>
<td>所有卷积后都不加TAM</td>
<td>4</td>
<td>3</td>
<td>15</td>
<td>32</td>
<td>57.05</td>
<td>54.98</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>OCR</tag>
      </tags>
  </entry>
  <entry>
    <title>ViT：视觉Transformer开创者（论文+代码详解）</title>
    <url>/archives/97820049.html</url>
    <content><![CDATA[<div class="note primary">
            <p>An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale</p><p>Alexey Dosovitskiy (Google, Brain Team)</p><p>论文地址: <a href="https://arxiv.org/abs/2010.11929v2">ViT, arxiv</a></p><p>代码地址: <a href="https://github.com/rwightman/pytorch-image-models/blob/master/timm/models/vision_transformer.py">timm-vision_transformer.py</a></p>
          </div>
<span id="more"></span>
<h3 id="动机">动机：</h3>
<ul>
<li>是否CNN对于图像特征提取来说不是必须的？</li>
<li>NLP领域中，Transformer相关的Encoder和Decoder这一套框架是否可以代替CNN来完成图像领域的任务？</li>
</ul>
<h3 id="创新点">创新点：</h3>
<ul>
<li><strong>将NLP领域的Transformer架构成功迁移到了CV领域，并且取得了和CNN相当的结果</strong></li>
<li>不降低图像分辨率，将图像分成小的patch，加入位置编码后加入到网络中</li>
<li>实验表明，在超大数据集上训练，在常规数据集上Finetune后可以和CNN的SOTA结果相比较，所用计算资源也大大减少</li>
</ul>
<h3 id="实验参数">实验参数：</h3>
<h3 id="结果汇总">结果汇总：</h3>
<h3 id="网络架构">网络架构：</h3>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/ViT-figure1" width="80%" height="80%" align="center"></p>
<h5 id="预处理embedding">预处理（Embedding）：</h5>
<ol type="1">
<li><p>Patch Embedding：将3维图像分patch，并且压缩到2维</p>
<ul>
<li><p>操作分解：</p>
<ol type="1">
<li><p>图像原始尺寸：<span class="math inline">\(B \times C \times H \times W\)</span></p></li>
<li>按照patch块大小 <span class="math inline">\(P\)</span> 切块，把patch内的像素放到channel维度 <span class="math inline">\((C*P^2) \times (H/P) \times (W/P)\)</span></li>
<li>将channel维度线性映射到embedding dimension <span class="math inline">\(D\)</span>，即变为 <span class="math inline">\(D \times (H/P) \times (W/P)\)</span></li>
<li>将后两维flatten成一个维度 <span class="math inline">\(N\)</span>，得到 <span class="math inline">\(D \times N\)</span> 的张量</li>
<li>将 <span class="math inline">\(D\)</span> 和 <span class="math inline">\(N\)</span> 所在的维度transpose，得到 <span class="math inline">\(N \times D\)</span> 的张量，因为此时 <span class="math inline">\(D\)</span> 中存的是patch的信息，这里就变成了feature map，而 <span class="math inline">\(N\)</span> 则是patch的数量，相当于原始的channel</li>
<li>对处理过后的张量做LN操作，即对每个feature map做归一化，LN共 <span class="math inline">\(2B \times N\)</span> 个参数</li>
<li><p>处理后的张量大小：<span class="math inline">\(B \times N \times D\)</span></p></li>
</ol></li>
<li><p>代码解读：<code>./timm/models/layers/patch_embed.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PatchEmbed</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 2D Image to Patch Embedding</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, img_size=<span class="number">224</span>, patch_size=<span class="number">16</span>, in_chans=<span class="number">3</span>, embed_dim=<span class="number">768</span>, norm_layer=<span class="literal">None</span>, flatten=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        img_size = to_2tuple(img_size)</span><br><span class="line">        patch_size = to_2tuple(patch_size)</span><br><span class="line">        self.img_size = img_size</span><br><span class="line">        self.patch_size = patch_size</span><br><span class="line">        self.grid_size = (img_size[<span class="number">0</span>] // patch_size[<span class="number">0</span>], img_size[<span class="number">1</span>] // patch_size[<span class="number">1</span>])</span><br><span class="line">        self.num_patches = self.grid_size[<span class="number">0</span>] * self.grid_size[<span class="number">1</span>]</span><br><span class="line">        self.flatten = flatten</span><br><span class="line"></span><br><span class="line">        self.proj = nn.Conv2d(in_chans, embed_dim, kernel_size=patch_size, stride=patch_size) <span class="comment"># 用卷积实现上述2、3步骤</span></span><br><span class="line">        self.norm = norm_layer(embed_dim) <span class="keyword">if</span> norm_layer <span class="keyword">else</span> nn.Identity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        B, C, H, W = x.shape</span><br><span class="line">        _<span class="keyword">assert</span>(H == self.img_size[<span class="number">0</span>], <span class="string">f&quot;Input image height (<span class="subst">&#123;H&#125;</span>) doesn&#x27;t match model (<span class="subst">&#123;self.img_size[<span class="number">0</span>]&#125;</span>).&quot;</span>)</span><br><span class="line">        _<span class="keyword">assert</span>(W == self.img_size[<span class="number">1</span>], <span class="string">f&quot;Input image width (<span class="subst">&#123;W&#125;</span>) doesn&#x27;t match model (<span class="subst">&#123;self.img_size[<span class="number">1</span>]&#125;</span>).&quot;</span>)</span><br><span class="line">        x = self.proj(x) </span><br><span class="line">        <span class="keyword">if</span> self.flatten:</span><br><span class="line">            x = x.flatten(<span class="number">2</span>).transpose(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 先把宽高维度flatten为N，然后将其与channel维度transpose # BCHW -&gt; BNC 这里后者的C其实为embed_dim D</span></span><br><span class="line">        x = self.norm(x) <span class="comment"># 这里还有一个标准化层</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Learnable Class Embedding</p>
<ul>
<li><p>操作分解：（如果存在蒸馏，则同理加入蒸馏token）</p>
<ol type="1">
<li>新建大小为 <span class="math inline">\(1 \times 1 \times D\)</span> 维度的可训练的变量</li>
<li><code>.expand</code>成 <span class="math inline">\(B \times 1 \times D\)</span> 维度</li>
<li>把patch embedding的结果与class embedding的结果在第一维上concat <code>torch.cat()</code></li>
</ol></li>
<li><p>代码解读：<code>./timm/models/vision_transformer.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisionTransformer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">...</span>):</span></span><br><span class="line">        <span class="comment"># 只截取了相关的部分</span></span><br><span class="line">        self.cls_token = nn.Parameter(torch.zeros(<span class="number">1</span>, <span class="number">1</span>, embed_dim)) <span class="comment"># 类别token 对应第1步</span></span><br><span class="line">        self.dist_token = nn.Parameter(torch.zeros(<span class="number">1</span>, <span class="number">1</span>, embed_dim)) <span class="keyword">if</span> distilled <span class="keyword">else</span> <span class="literal">None</span> <span class="comment"># 蒸馏token</span></span><br><span class="line">        self.pos_embed = nn.Parameter(torch.zeros(<span class="number">1</span>, num_patches + self.num_tokens, embed_dim)) <span class="comment"># PE Position Embedding</span></span><br><span class="line">        self.pos_drop = nn.Dropout(p=drop_rate)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_features</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.patch_embed(x) <span class="comment"># patch embedding</span></span><br><span class="line">        cls_token = self.cls_token.expand(x.shape[<span class="number">0</span>], -<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment"># 对应第2步</span></span><br><span class="line">        <span class="keyword">if</span> self.dist_token <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            x = torch.cat((cls_token, x), dim=<span class="number">1</span>) <span class="comment"># 对应第3步</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = torch.cat((cls_token, self.dist_token.expand(x.shape[<span class="number">0</span>], -<span class="number">1</span>, -<span class="number">1</span>), x), dim=<span class="number">1</span>) <span class="comment"># 如果蒸馏，则concat分类token、蒸馏token和patch token</span></span><br><span class="line">        x = self.pos_drop(x + self.pos_embed)  <span class="comment"># PE</span></span><br><span class="line">        x = self.blocks(x)</span><br><span class="line">        x = self.norm(x)</span><br><span class="line">        <span class="keyword">if</span> self.dist_token <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.pre_logits(x[:, <span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> x[:, <span class="number">0</span>], x[:, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Position Embedding</p>
<ul>
<li>操作分解：
<ol type="1">
<li>新建大小为 <span class="math inline">\(1 \times (N+1) \times D\)</span> 维度的可训练的变量，其中 <span class="math inline">\(x\)</span> 为额外加的token数量，通常为1或者2</li>
<li>将新建的变量<code>+</code>到embedding后的tensor（常量）上，<strong>不同batch共享同样的PE变量</strong></li>
</ol></li>
<li>代码解读：见上方Class Embedding</li>
</ul></li>
</ol>
<h5 id="transformer-encoder-l-重复l次">Transformer Encoder *L 重复L次</h5>
<ol type="1">
<li><p>总览： <span class="math display">\[
{
z_0 = [x_{class};\ x_p^1E;\ x_p^2E;\ ···\ ;\ x_p^NE]+\ E_{pos},\ \ \  E \in R^{P^2C \times D},\ E_{pos} \in R^{(N+1) \times D} \ \ \ (1)\\\\\\
z&#39;_l = MSA(LN(z_{l-1}))\ + \ z_{l-1}, \ \ \  l=1...L \ \ \ (2)\\\\
z_l = MLP(LN(z&#39;_{l}))\ + \ z&#39;_{l}, \ \ \  l=1...L \ \ \ (3)\\\\
y = LN(z^{0}_{L}) \ \ \ (4)
}
\]</span></p>
<ul>
<li>操作分解：</li>
</ul></li>
<li><span class="math inline">\(z_0\)</span> 为embedding后的结果，<span class="math inline">\(x_{class}\)</span> 为分类token，<span class="math inline">\(x_p^i \in R^{1\times P^2C}\)</span> 为图像分完patch后的向量，<span class="math inline">\(E\)</span> 为线性变换矩阵，<span class="math inline">\(E_{pos}\)</span> 为位置编码
<ol start="2" type="1">
<li>共有<span class="math inline">\(L\)</span>个transformer结构，每个结构包含两个部分</li>
<li>先做LN再做MSA，接一个shotcut
<ol start="2" type="1">
<li>先做LN再做MLP，接一个shotcut</li>
</ol></li>
<li>将最后一个transformer的输出中的第0个patch取出来做LN后得到 <span class="math inline">\(y\)</span> 用于分类</li>
</ol></li>
</ol>
<ul>
<li>代码解读：</li>
</ul>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim, num_heads, mlp_ratio=<span class="number">4.</span>, qkv_bias=<span class="literal">False</span>, drop=<span class="number">0.</span>, attn_drop=<span class="number">0.</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 drop_path=<span class="number">0.</span>, act_layer=nn.GELU, norm_layer=nn.LayerNorm</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.norm1 = norm_layer(dim)</span><br><span class="line">        self.attn = Attention(dim, num_heads=num_heads, qkv_bias=qkv_bias, attn_drop=attn_drop, proj_drop=drop) <span class="comment"># 这里对应Attention模块，其中Multi-head的数量就是 num_heads也就是注意力模块的数量</span></span><br><span class="line">        <span class="comment"># <span class="doctag">NOTE:</span> drop path for stochastic depth, we shall see if this is better than dropout here</span></span><br><span class="line">        self.drop_path = DropPath(drop_path) <span class="keyword">if</span> drop_path &gt; <span class="number">0.</span> <span class="keyword">else</span> nn.Identity()</span><br><span class="line">        self.norm2 = norm_layer(dim)</span><br><span class="line">        mlp_hidden_dim = <span class="built_in">int</span>(dim * mlp_ratio)</span><br><span class="line">        self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop) <span class="comment"># 对应MLP模块，其中hidden_features就是指中间隐藏层降到的维数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = x + self.drop_path(self.attn(self.norm1(x))) <span class="comment"># 对应上方的公式（2）</span></span><br><span class="line">        x = x + self.drop_path(self.mlp(self.norm2(x))) <span class="comment"># 对应上方的公式（3）</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisionTransformer</span>(<span class="params">nn.Module</span>):</span>       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">...</span>):</span></span><br><span class="line">        <span class="comment"># 只截取了相关代码</span></span><br><span class="line">        dpr = [x.item() <span class="keyword">for</span> x <span class="keyword">in</span> torch.linspace(<span class="number">0</span>, drop_path_rate, depth)]  <span class="comment"># stochastic depth decay rule</span></span><br><span class="line">        self.blocks = nn.Sequential(*[</span><br><span class="line">            Block(dim=embed_dim, num_heads=num_heads, mlp_ratio=mlp_ratio, qkv_bias=qkv_bias, drop=drop_rate,attn_drop=attn_drop_rate, drop_path=dpr[i], norm_layer=norm_layer, act_layer=act_layer)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(depth)]) <span class="comment"># 用nn.Sequential(*[Block() for i in range(depth)])来完成transfermor结构重复depth次，depth=L</span></span><br><span class="line">        self.norm = norm_layer(embed_dim)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_features</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 只截取部分代码</span></span><br><span class="line">        x = self.blocks(x)</span><br><span class="line">        x = self.norm(x)</span><br><span class="line">        <span class="keyword">if</span> self.dist_token <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.pre_logits(x[:, <span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> x[:, <span class="number">0</span>], x[:, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p>MSA(Multi-head Self Attention) <strong>想了解一下head数量对于模型的影响！</strong></p>
<ul>
<li><strong>Self Attention 机制</strong>：<span class="math inline">\(Attention(x) \ = \ Softmax(Q \times K^T/\sqrt{d}) \times V\)</span>
<ul>
<li>为什么除以根号d？：防止 <span class="math inline">\(Q\times K^T\)</span> 的数值过大，过 <span class="math inline">\(Softmax\)</span> 时梯度消失</li>
<li><span class="math inline">\(Softmax(Q \times K^T/\sqrt{d})\)</span> 整个相当于一个注意力矩阵，乘以原始图像 <span class="math inline">\(V\)</span></li>
</ul></li>
<li><p>操作分解：</p>
<ol type="1">
<li>将输入的 <span class="math inline">\(B\times N\times D\)</span> 做线性变换为原来的三倍 <span class="math inline">\(B\times N\times 3*D\)</span></li>
<li><code>reshape</code>成 <span class="math inline">\(B\times N\times 3 \times H \times (D/H)\)</span>，其中 <span class="math inline">\(H\)</span> 为Multi-head的数量，相当于把每个patch在分成H分，每一份都做不同的attention</li>
<li><code>permute</code>重新排列为 <span class="math inline">\(3\times B\times H \times N \times (D/H)\)</span>，然后<code>unbind(0)</code>得到 <span class="math inline">\(q,k,v\)</span> 三个张量，大小为<span class="math inline">\(B\times H \times N \times (D/H)\)</span></li>
<li>利用公式 <span class="math inline">\(Attention(x) \ = \ Softmax(q \times k^T/\sqrt{D/H}) \times v\)</span> 计算注意力，中间会添加dropout防止过拟合</li>
<li><code>transpose(1,2).reshape(B, N, C)</code>后将维度变换回了 <span class="math inline">\(B\times N\times D\)</span></li>
<li>之后加一个全连接层，再接一个dropout层</li>
</ol></li>
<li><p>代码解读：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Attention</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim, num_heads=<span class="number">8</span>, qkv_bias=<span class="literal">False</span>, attn_drop=<span class="number">0.</span>, proj_drop=<span class="number">0.</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">assert</span> dim % num_heads == <span class="number">0</span>, <span class="string">&#x27;dim should be divisible by num_heads&#x27;</span></span><br><span class="line">        self.num_heads = num_heads</span><br><span class="line">        head_dim = dim // num_heads</span><br><span class="line">        self.scale = head_dim ** -<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">        self.qkv = nn.Linear(dim, dim * <span class="number">3</span>, bias=qkv_bias)</span><br><span class="line">        self.attn_drop = nn.Dropout(attn_drop)</span><br><span class="line">        self.proj = nn.Linear(dim, dim)</span><br><span class="line">        self.proj_drop = nn.Dropout(proj_drop)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        B, N, C = x.shape</span><br><span class="line">        qkv = self.qkv(x).reshape(B, N, <span class="number">3</span>, self.num_heads, C // self.num_heads).permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        q, k, v = qkv.unbind(<span class="number">0</span>)   <span class="comment"># make torchscript happy (cannot use tensor as tuple)</span></span><br><span class="line"></span><br><span class="line">        attn = (q @ k.transpose(-<span class="number">2</span>, -<span class="number">1</span>)) * self.scale</span><br><span class="line">        attn = attn.softmax(dim=-<span class="number">1</span>)</span><br><span class="line">        attn = self.attn_drop(attn)</span><br><span class="line"></span><br><span class="line">        x = (attn @ v).transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(B, N, C)</span><br><span class="line">        x = self.proj(x)</span><br><span class="line">        x = self.proj_drop(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>MLP(Multi Layer Processor)</p>
<ul>
<li><p>操作分解：<strong>其实就是一个简单的降维再升维的操作，用全连接层实现</strong></p>
<ol type="1">
<li><code>nn.Linear(in_dim, out_dim)</code>全连接层将 <span class="math inline">\(B\times N\times D\)</span> 变成 <span class="math inline">\(B\times N\times H\)</span>，其中H为隐藏层维度</li>
<li><code>nn.Gelu</code>激活函数层，增加非线性</li>
<li><code>nn.Dropout(p)</code>随机丢弃一些点，不做正向传播和反向梯度更新</li>
<li><code>nn.Linear(in_dim, out_dim)</code>全连接层将 <span class="math inline">\(B\times N\times H\)</span> <strong>变回</strong> <span class="math inline">\(B\times N\times D\)</span>，其中H为隐藏层维度</li>
<li><code>nn.Gelu</code>激活函数层，增加非线性</li>
<li><code>nn.Dropout(p)</code>随机丢弃一些点，不做正向传播和反向梯度更新</li>
</ol></li>
<li><p>代码解读：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mlp</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; MLP as used in Vision Transformer, MLP-Mixer and related networks</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_features, hidden_features=<span class="literal">None</span>, out_features=<span class="literal">None</span>, act_layer=nn.GELU, drop=<span class="number">0.</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        out_features = out_features <span class="keyword">or</span> in_features</span><br><span class="line">        hidden_features = hidden_features <span class="keyword">or</span> in_features</span><br><span class="line">        drop_probs = to_2tuple(drop)</span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(in_features, hidden_features)</span><br><span class="line">        self.act = act_layer()</span><br><span class="line">        self.drop1 = nn.Dropout(drop_probs[<span class="number">0</span>])</span><br><span class="line">        self.fc2 = nn.Linear(hidden_features, out_features)</span><br><span class="line">        self.drop2 = nn.Dropout(drop_probs[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.act(x)</span><br><span class="line">        x = self.drop1(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = self.drop2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h5 id="后处理classification">后处理（Classification）：</h5>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/ViT分类头" width="80%" height="50%" align="center"></p>
<ol type="1">
<li><p>分类：</p>
<ul>
<li><p>操作分解：</p>
<ol type="1">
<li>对于Transformer的输出中class token对应的位置进行操作，先过一个MLP层，然后再过一个分类头后计算cross entropy loss</li>
<li>这里预训练和微调时不太一样，微调时会把MLP层删掉，只留下分类头。这个操作应该是借鉴了自监督，因为自监督在预训练是没有类别信息，所以MLP后跟的是一个<strong>contrastive loss</strong>，用于计算输出与原始图像的loss</li>
</ol></li>
<li><p>代码解读：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisionTransformer</span>(<span class="params">nn.Module</span>):</span>       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">...</span>):</span></span><br><span class="line">        <span class="comment"># 只截取了相关代码</span></span><br><span class="line">        <span class="comment"># Representation layer</span></span><br><span class="line">        <span class="keyword">if</span> representation_size <span class="keyword">and</span> <span class="keyword">not</span> distilled:</span><br><span class="line">            self.num_features = representation_size</span><br><span class="line">            self.pre_logits = nn.Sequential(OrderedDict([  <span class="comment"># 这里是预训练时的MLP层</span></span><br><span class="line">                (<span class="string">&#x27;fc&#x27;</span>, nn.Linear(embed_dim, representation_size)),</span><br><span class="line">                (<span class="string">&#x27;act&#x27;</span>, nn.Tanh())</span><br><span class="line">            ]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.pre_logits = nn.Identity()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_features</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 只截取部分代码</span></span><br><span class="line">        <span class="keyword">if</span> self.dist_token <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.pre_logits(x[:, <span class="number">0</span>]) <span class="comment"># 选取class token对应的区域进行分类</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> x[:, <span class="number">0</span>], x[:, <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.forward_features(x)</span><br><span class="line">        <span class="keyword">if</span> self.head_dist <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            x, x_dist = self.head(x[<span class="number">0</span>]), self.head_dist(x[<span class="number">1</span>])  <span class="comment"># x must be a tuple</span></span><br><span class="line">            <span class="keyword">if</span> self.training <span class="keyword">and</span> <span class="keyword">not</span> torch.jit.is_scripting():</span><br><span class="line">                <span class="comment"># during inference, return the average of both classifier predictions</span></span><br><span class="line">                <span class="keyword">return</span> x, x_dist</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> (x + x_dist) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = self.head(x) <span class="comment"># ViT不蒸馏直接分类</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
        <tag>ViT</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer综述</title>
    <url>/archives/9f9b7c0a.html</url>
    <content><![CDATA[<blockquote>
<p>最近一段时间都在研究ViT相关的工作，需要多读论文多多总结</p>
</blockquote>
<span id="more"></span>
<h2 id="vit">ViT</h2>
<p>DeiT</p>
<p>CaiT</p>
<p>Swin</p>
<h2 id="vitae-vision-transformer-advanced-by-exploring-intrinsic-inductive-bias">ViTAE: Vision Transformer Advanced by Exploring Intrinsic Inductive Bias</h2>
<blockquote>
<p>作者：Dacheng Tao 悉尼大学</p>
</blockquote>
<h3 id="动机">动机：</h3>
<ul>
<li>ViT训练需要大量数据以及很多个epoch：原因是Transformer结构不存在归纳偏好（IB）因此收敛较慢，需要慢慢学习隐性的归纳偏好</li>
<li>Transformer擅长获取跨度较长的全局信息；但是不具备归纳偏好</li>
<li>CNNs具有很好的归纳偏好，比如局部性和尺度不变性；但不擅长获取全局信息
<ul>
<li>卷积关注相邻的pixels之间的信息</li>
<li>浅层卷积关注low-level特征</li>
<li>深层卷积关注high-level特征</li>
<li>在不同的layer可以提取不同尺度的特征</li>
<li>layer内部还可以通过卷积的大小、步长、膨胀等提取不同特征</li>
<li>layer内部或外部特征的融合也可以提供更多信息</li>
</ul></li>
<li><strong>尝试将Transformer和CNN并行连接在一起</strong></li>
</ul>
<h5 id="生词">生词</h5>
<ul>
<li>intrinsic：内在的</li>
<li><strong>inductive bias (IB) 归纳偏好</strong> inductive：诱导的；感应的；归纳的</li>
<li>IB implicitly：隐式归纳偏好 explicitly：明白地；明确地</li>
<li>scale invariance：尺度不变性</li>
<li>prevalent：普遍的；流行的</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch炼丹</title>
    <url>/archives/164bcfad.html</url>
    <content><![CDATA[<ul>
<li>最近实习中遇到了很多问题，需要慢慢总结下来，彻底记住</li>
</ul>
<span id="more"></span>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0301 三合一</title>
    <url>/archives/5371f097.html</url>
    <content><![CDATA[<h3 id="题目"><a href="https://leetcode-cn.com/problems/three-in-one-lcci">题目：</a></h3>
<ul>
<li><p>描述如何<strong>只用一个数组来实现三个栈</strong>。</p>
<p>你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。</p>
<p>构造函数会传入一个stackSize参数，代表每个栈的大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 样例1</span></span><br><span class="line"> 输入：</span><br><span class="line">[<span class="string">&quot;TripleInOne&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;isEmpty&quot;</span>]</span><br><span class="line">[[<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>]]</span><br><span class="line"> 输出：</span><br><span class="line">[null, null, null, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, true]</span><br><span class="line">说明：当栈为空时`pop, peek`返回-<span class="number">1</span>，当栈满时`push`不压入元素。</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 样例2</span></span><br><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;TripleInOne&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;peek&quot;</span>]</span><br><span class="line">[[<span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>]]</span><br><span class="line"> 输出：</span><br><span class="line">[null, null, null, null, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示：</span></span><br><span class="line"><span class="number">0</span> &lt;= stackNum &lt;= <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>
<h3 id="解题方法">解题方法：</h3>
<ol type="1">
<li><p><strong>模拟：</strong>用数组模拟栈的后进先出(LIFO)的模式，用一个大小为3的数组作为指针来记录每个栈顶的位置（注意这里栈顶指的是存储元素的后一位）</p>
<div class="note primary">
            <ul><li>时间复杂度<span class="math inline">\(O(n)\)</span>，n为输入指令数量</li><li>额外的空间复杂度为<span class="math inline">\(O(stackSize)\)</span>，stackSize为一个栈的大小</li></ul>
          </div></li>
</ol>
<h3 id="解法一模拟">解法一：模拟</h3>
<div class="note warning">
            <ul><li><code>vector</code>可以一开始初始定长的，然后用下标去访问即可，当作定长数组来用</li><li>栈的边界处理技巧：将栈顶的指针指向顶部元素的再往上一个元素，方便处理边界条件</li></ul>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TripleInOne</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; Nstacks; <span class="comment">// 用vector来模拟栈</span></span><br><span class="line">    <span class="keyword">int</span> stacksize = <span class="number">0</span>; <span class="comment">// 记录栈的大小</span></span><br><span class="line">    <span class="keyword">int</span> stacktop[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// 记录栈顶元素的后一位的地址</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TripleInOne</span>(<span class="keyword">int</span> stackSize) &#123;</span><br><span class="line">        stacksize = stackSize;</span><br><span class="line">        Nstacks = vector&lt;<span class="keyword">int</span>&gt;(stacksize*<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">        stacktop[<span class="number">1</span>] = stacksize;</span><br><span class="line">        stacktop[<span class="number">2</span>] = stacksize*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stacktop[stackNum] &lt; stacksize*(stackNum+<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Nstacks[stacktop[stackNum]++] = value; <span class="comment">// 难点就在于判断边界条件以及top指针的变化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rst = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(stacktop[stackNum] &gt; stacksize*(stackNum))</span><br><span class="line">        &#123;</span><br><span class="line">            rst = Nstacks[--stacktop[stackNum]]; <span class="comment">// 弹出时应返回top所指的上一位，并且top移动到这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rst = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(stacktop[stackNum] &gt; stacksize*(stackNum))</span><br><span class="line">        &#123;</span><br><span class="line">            rst = Nstacks[stacktop[stackNum]<span class="number">-1</span>]; <span class="comment">// peek时应返回top所指的上一位，但top所指位置不变</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stacktop[stackNum] == stacksize*stackNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TripleInOne object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TripleInOne* obj = new TripleInOne(stackSize);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(stackNum,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop(stackNum);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek(stackNum);</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;isEmpty(stackNum);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>vector</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0208 环路检测</title>
    <url>/archives/dd36b91f.html</url>
    <content><![CDATA[<h3 id="题目"><a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci">题目：</a></h3>
<ul>
<li><p>给定一个链表，如果它是有环链表，实现一个算法返回环路的<code>开头节点</code>。若环不存在，请返回 <code>null</code>。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况</p></li>
<li><p>~~~python # 样例1 输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点</p>
<h1 id="样例2">样例2</h1>
<p>输入：head = [1,2], pos = 0 输出：tail connects to node index 0 解释：链表中有一个环，其尾部连接到第一个节点 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">### 解题方法：</span><br><span class="line"></span><br><span class="line">&#123;% note warning%&#125;</span><br><span class="line"></span><br><span class="line">哈希表法思路比较简洁明了，需要注意的是存储的是node地址，而非值；快慢指针是很重要的技巧，需要熟练掌握，优点是时间复杂度和哈希表法相同，但是只用$O(1)$的额外空间</span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125; </span><br><span class="line"></span><br><span class="line">1. **哈希表法：**遍历链表，每经过一个node就把他的地址放到表里，第一个重复的地址即为圈的首节点</span><br><span class="line"></span><br><span class="line">   &#123;% note primary %&#125;</span><br><span class="line"></span><br><span class="line">   时间复杂度为$O(n)$，额外的空间复杂度为$O(n)$</span><br><span class="line"></span><br><span class="line">   &#123;% endnote %&#125; </span><br><span class="line"></span><br><span class="line">3. **快慢指针：**</span><br><span class="line"></span><br><span class="line">   &#123;% note primary %&#125;</span><br><span class="line"></span><br><span class="line">   时间复杂度为$O(n)$，额外的空间复杂度为$O(1)$</span><br><span class="line"></span><br><span class="line">   &#123;% endnote %&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 解法一：哈希表法</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line"></span><br><span class="line">- map、set、unordered_map、unordered_set总结：https://blog.csdn.net/qq_30815237/article/details/91047041</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">~~~c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class="line">        while(head != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            if(visited.count(head) == 1) </span><br><span class="line">            // if(visited.find(head) != visited.end())</span><br><span class="line">            // count实测比find函数快，执行时间分别是4ms和8ms</span><br><span class="line">            &#123;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                visited.insert(head);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="解法二快慢指针">解法二：快慢指针</h3>
<div class="note warning">
            <p>解题思路：</p><ul><li>使用两个指针，<code>fast</code>与<code>slow</code>。它们起始都位于链表的头部。随后，<code>slow</code> 指针每次向后移动一个位置，而 <code>fast</code> 指针向后移动两个位置。<strong>如果链表中存在环</strong>，则 <code>fast</code> 指针最终将再次与 <code>slow</code> 指针在环中相遇<ul><li>此时<code>fast</code>走的距离为 <span class="math inline">\(a+n(b+c)+b\)</span>，此时<code>slow</code>走了 <span class="math inline">\(a+m(b+c)+b\)</span> 的距离</li><li>根据定义，<code>fast</code>走了<code>slow</code>的两倍距离，因此 <span class="math inline">\(a+n(b+c)+b=2(a+m(b+c)+b)\)</span></li><li>解得 <span class="math inline">\(a=(n-2m-1)*(b+c)+c\)</span></li></ul></li><li>相遇后：新建指针<code>p = head</code>从头走，<code>slow</code>和<code>p</code>一起走，当<code>p</code>走了<span class="math inline">\(a\)</span>步时，<code>slow</code>也走了<span class="math inline">\((n-2m-1)*(b+c)+c\)</span> 步，即<span class="math inline">\(n-1\)</span>圈再加上额外的<span class="math inline">\(c\)</span>步，<strong>即相遇时为环的起点</strong></li></ul>
          </div>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/快慢指针.png" width="50%" height="50%" align="center"></p>
<div class="note primary">
            <p><strong>证明1：快慢指针一定会相遇吗？（数学归纳法）</strong></p><ul><li>如果两指针间距为一，则两者再走一次就相遇了</li><li>如果间距为n，则两者再走一次后，间距就变为 <span class="math inline">\(n+1-2=n-1\)</span> 了，重复这个过程，直至两者相遇</li></ul><p><strong>证明2：快指针的速度是慢指针的n倍时，两者是否还会相遇？</strong></p><ul><li></li></ul>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *slow = head, *fast = head, *p = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next-&gt;next == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; fast-&gt;val;</span></span><br><span class="line">                <span class="keyword">while</span>(slow != p) </span><br><span class="line">                <span class="comment">// p和slow刚好在环的起始节点相遇，两者走的距离都是a=(n-1)*(b+c)+c</span></span><br><span class="line">                &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>快慢指针</tag>
        <tag>c++中set和map总结</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0109 字符串轮转</title>
    <url>/archives/f56eaff7.html</url>
    <content><![CDATA[<h3 id="题目"><a href="https://leetcode-cn.com/problems/string-rotation-lcci/">题目：</a></h3>
<ul>
<li><p>给定两个字符串<code>s1</code>和<code>s2</code>，请编写代码检查<code>s2</code>是否为<code>s1</code>旋转而成（比如，<code>waterbottle</code>是<code>erbottlewat</code>旋转后的字符串）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 样例1</span></span><br><span class="line">输入：s1 = <span class="string">&quot;waterbottle&quot;</span>, s2 = <span class="string">&quot;erbottlewat&quot;</span></span><br><span class="line">输出：<span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 样例2</span></span><br><span class="line">输入：s1 = <span class="string">&quot;aa&quot;</span>, s2 = <span class="string">&quot;aba&quot;</span></span><br><span class="line">输出：<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示：</span></span><br><span class="line">字符串长度在[<span class="number">0</span>, <span class="number">100000</span>]范围内。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明:</span></span><br><span class="line">你能只调用一次检查子串的方法吗？</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>
<h3 id="解题方法">解题方法：</h3>
<ol type="1">
<li><p><strong>扩充：</strong>如果s2是由s1旋转而成，那么将两个s2首尾拼接起来，那么s1一定是拼接后字符串的子串，因此这里用了<code>s.find(s1)?=-1</code>这个函数来判断是否为子串。</p>
<div class="note primary">
            <ul><li><p>时间复杂度取决于C++中<code>find()</code>的速度，这里find函数应该是简单使用了匹配算法（见文末），最坏的复杂度为<span class="math inline">\(O(n*m)\)</span>，但随机字符串均摊后还是<span class="math inline">\(O(m+n)\)</span>，额外的空间复杂度为<span class="math inline">\(O(n)\)</span>。</p></li><li><p><strong>KMP算法还是值得了解一下原理的（挖坑）</strong></p></li></ul>
          </div></li>
</ol>
<h3 id="解法一扩充">解法一：扩充</h3>
<div class="note warning">
            <ul><li>字符串拼接：<code>string s = s2 + s2</code>直接用加号即可</li><li>字符串匹配：<code>s.find(s1)</code>匹配成功则返回s1在s中的起始位置，否则返回-1</li></ul>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFlipedString</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        string s = s2 + s2;</span><br><span class="line">        <span class="keyword">int</span> a = s.<span class="built_in">find</span>(s1);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; a &lt;&lt; &quot;$$&quot; &lt;&lt; s &lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> (s1.<span class="built_in">size</span>() == s2.<span class="built_in">size</span>()) &amp;&amp; s.<span class="built_in">find</span>(s1) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="字符串匹配暴力算法">字符串匹配暴力算法</h3>
<div class="note warning">
            <p>遍历主串作为匹配起始点，依次和模式串匹配，匹配成功则返回匹配成功的起始点，不成功返回-1</p>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力破解法</span></span><br><span class="line"><span class="comment"> * @param ts 主串</span></span><br><span class="line"><span class="comment"> * @param ps 模式串</span></span><br><span class="line"><span class="comment"> * @return 如果找到，返回在主串中第一个字符出现的下标，否则为-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bf</span><span class="params">(String ts, String ps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] t = ts.<span class="built_in">toCharArray</span>();</span><br><span class="line">    <span class="keyword">char</span>[] p = ps.<span class="built_in">toCharArray</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 主串的位置</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串的位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line">       <span class="keyword">if</span> (t[i] == p[j]) &#123; <span class="comment">// 当两个字符相同，就比较下一个</span></span><br><span class="line">           i++;</span><br><span class="line">           j++;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           i = i - j + <span class="number">1</span>; <span class="comment">// 一旦不匹配，i后退</span></span><br><span class="line">           j = <span class="number">0</span>; <span class="comment">// j归0</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">       <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kmp算法未搞懂">KMP算法（未搞懂）</h3>
<div class="note warning">
            <p><strong>“利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置”</strong></p>
          </div>
<p>参考资料:<a href="https://www.cnblogs.com/yjiyjige/p/3263858.html">KMP算法</a></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>挖坑</tag>
        <tag>字符串</tag>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0108 零矩阵</title>
    <url>/archives/8c04a153.html</url>
    <content><![CDATA[<h3 id="题目"><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/">题目：</a></h3>
<ul>
<li><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 样例1</span></span><br><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 样例2</span></span><br><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>
<h3 id="解题方法">解题方法：</h3>
<div class="note warning">
            <p>读到零直接修改行列这种做法会是数据变脏，导致结果不符合预期，因此需要将有0的行和列存下来，然后再想办法置零，这里有两种置零策略，<strong>前者时间复杂度更低</strong>，后者<code>find()</code>函数的复杂度为<span class="math inline">\(O(n)\)</span></p>
          </div>
<ol type="1">
<li><p><strong>使用标记数组：</strong>遍历矩阵，找到有零存在的所有行和列；<strong>分别遍历这些行和列</strong>，并置零</p>
<div class="note primary">
            <p>时间复杂度为<span class="math inline">\(O(n^2)\)</span>，额外的空间复杂度为<span class="math inline">\(O(n)\)</span></p>
          </div></li>
<li><p><strong>使用标记数组：</strong>遍历矩阵，找到有零存在的所有行和列；<strong>重新遍历矩阵</strong>，判断当前所在的行列是否属于有零存在的行列，因为用<code>set</code>集合存储了为零的行列，因此利用<code>find()</code>函数即可</p>
<div class="note primary">
            <p>时间复杂度为<span class="math inline">\(O(n^3)\)</span>，因为<code>find()</code>函数的复杂度为<span class="math inline">\(O(n)\)</span>，额外的空间复杂度为<span class="math inline">\(O(n)\)</span></p>
          </div></li>
<li><p><strong>使用两个标记变量：</strong>用矩阵的第一行和第一列来当标记数组，然后用两个标记变量标记原本第一行和第一列是否出现过0，这样就可以降低空间复杂度了！<strong>目前未实现</strong></p>
<div class="note primary">
            <p>时间复杂度为<span class="math inline">\(O(n^3)\)</span>，额外的空间复杂度为<span class="math inline">\(O(1)\)</span></p>
          </div></li>
</ol>
<h3 id="解法一使用标记数组">解法一：使用标记数组</h3>
<div class="note warning">
            <ul><li><p>集合的定义：<code>set&lt;int&gt; set_row;</code></p></li><li><p>集合添加元素：</p><ul><li><code>set_row.insert(int i);</code></li><li>添加pair：<code>set&lt;pair&lt;T1, T2&gt;&gt; set_pair; set_pair.emplace(T1 a, T2, b);</code></li></ul></li><li><p>集合删除元素：成员函数 clear() 会删除 set 的所有元素。成员函数 erase() 会删除迭代器指定位置的元素或与对象匹配的元素。</p><ul><li><code>set_row.erase(int a);</code>删除对应的元素，如果没有会返回什么？</li><li><code>set_row.erase(iterator);</code>删除迭代器位置元素</li><li><code>set_row.clear();</code>删除全部元素</li></ul></li><li><p>集合的遍历（只能用iterator）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = set_row.<span class="built_in">begin</span>(); it != set_row.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl; <span class="comment">// *it为取it地址下的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找元素是否在集合中：<code>if(set_row.find(int a) != set_row.end()) return true;</code> find的复杂度为<span class="math inline">\(O(n)\)</span>，底层逻辑就是遍历整个set，直到end()</p></li></ul>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; set_row, set_col;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    set_row.<span class="built_in">insert</span>(i);</span><br><span class="line">                    set_col.<span class="built_in">insert</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="comment">// set all the 0 rows</span></span><br><span class="line">        <span class="keyword">for</span>(it = set_row.<span class="built_in">begin</span>(); it!=set_row.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[*it].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[*it][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set all the 0 colums</span></span><br><span class="line">        <span class="keyword">for</span>(it = set_col.<span class="built_in">begin</span>(); it!=set_col.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[i][*it] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二使用标记数组">解法二：使用标记数组</h3>
<div class="note warning">
            <ul><li>集合的find操作，见上文</li></ul>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; set_row, set_col;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    set_row.<span class="built_in">insert</span>(i);</span><br><span class="line">                    set_col.<span class="built_in">insert</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(set_row.<span class="built_in">find</span>(i) != set_row.<span class="built_in">end</span>()) <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(set_col.<span class="built_in">find</span>(j) != set_col.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法三使用两个标记变量未实现">解法三：使用两个标记变量（未实现）</h3>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二维矩阵</tag>
        <tag>vector</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0107 旋转矩阵</title>
    <url>/archives/924acc2a.html</url>
    <content><![CDATA[<h3 id="题目"><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/">题目：</a></h3>
<ul>
<li><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p><strong>不占用额外内存空间能否做到？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 样例1</span></span><br><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 样例2</span></span><br><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>
<h3 id="解题方法">解题方法：</h3>
<div class="note warning">
            <p>有旋转时记得用对称性来计算旋转前后的坐标</p>
          </div>
<ol type="1">
<li><p>原地旋转（根据顺时针旋转特性）：旋转前后是<strong>点对点</strong>的变化，因此只需要将对应的点旋转即可，这里由于不让使用额外空间，因此可以<strong>顺时针switch三遍起始点和对应点即可</strong></p>
<div class="note primary">
            <p>时间复杂度为<span class="math inline">\(O(n^2)\)</span>，额外的空间复杂度为<span class="math inline">\(O(1)\)</span></p>
          </div></li>
<li><p>辅助空间（利用多余空间）：新建另一个<code>N × N</code>的矩阵，遍历时交换元素到<strong>对应位置</strong></p>
<div class="note primary">
            <p>时间复杂度为<span class="math inline">\(O(n^2)\)</span>，额外的空间复杂度为<span class="math inline">\(O(n^2)\)</span>，</p>
          </div></li>
</ol>
<h3 id="解法一原地旋转">解法一：原地旋转</h3>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/面试金典0107(旋转矩阵示意图1)" width="50%" height="50%" align="center"></p>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/面试金典0107（旋转示意图2）" width="50%" height="50%" align="center"></p>
<div class="note warning">
            <ul><li>如何计算对应位置？<ol type="1"><li>位置3和1是轴对称，也就是关于横轴对称后再关于纵轴对称，计算相应的节点即可</li><li>位置2和1是先关于纵轴对称后，再关于对角线对称，可以通过计算得到</li><li>位置4和1是先关于横轴对称，然后再关于对角线对称</li></ol></li><li>用位运算代替除法，<strong>右移1个单位等价于除以二</strong></li></ul>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> r = (n&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>; <span class="comment">//左上角区域的最大行下标</span></span><br><span class="line">        <span class="keyword">int</span> c = (n<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>; <span class="comment">//左上角区域的最大列下标，行列下标从 0 开始。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = c; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][n-i<span class="number">-1</span>]); <span class="comment">// 1和2交换</span></span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>]); <span class="comment">// 1和3交换 </span></span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[n-j<span class="number">-1</span>][i]); <span class="comment">// 1和4交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二辅助空间">解法二：辅助空间</h3>
<div class="note warning">
            <ul><li>如何计算对应位置？<ol type="1"><li>先关于<code>y=-x</code>对角线对称：<span class="math inline">\(x_1=y_0;\ y_1=x_0\)</span></li><li>然后关于纵轴对称：<span class="math inline">\(x_2=x_1=y_0;\ y_2=n-1-y_1=n-1-x_0\)</span></li></ol></li><li>二维<code>vector</code>初始化方法<ul><li>初始化为另一个已知vector：<code>vector&lt;vector&lt;int&gt;&gt; tmp = matrix;</code></li><li>初始化为<code>row * cul</code>大小的0矩阵：<code>vector&lt;vector&lt;int&gt;&gt; tmp(row, vector&lt;int&gt;(cul, 0));</code></li></ul></li><li>一维<code>vector</code>初始化方法：<code>vector&lt;int&gt; vec(len, 0);</code>长度为len，初始化值为0</li></ul>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;int&gt;&gt; output(N, vector&lt;int&gt;(N, 0));//初始化N * N二维动态数组，初始化值为0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; tmp = matrix;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[j][N<span class="number">-1</span>-i] = tmp[i][j]; <span class="comment">// 关于y=-x对称后再关于横轴对称</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二维矩阵</tag>
        <tag>vector</tag>
        <tag>旋转</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0106 字符串压缩</title>
    <url>/archives/9c329055.html</url>
    <content><![CDATA[<h3 id="题目字符串压缩">题目：<a href="https://leetcode-cn.com/problems/compress-string-lcci/">字符串压缩</a></h3>
<ul>
<li><p>利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 样例1</span></span><br><span class="line">输入：<span class="string">&quot;aabcccccaaa&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a2b1c5a3&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 样例2</span></span><br><span class="line"> 输入：<span class="string">&quot;abbccd&quot;</span></span><br><span class="line"> 输出：<span class="string">&quot;abbccd&quot;</span></span><br><span class="line"> 解释：<span class="string">&quot;abbccd&quot;</span>压缩后为<span class="string">&quot;a1b2c2d1&quot;</span>，比原字符串长度更长。</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 提示：</span></span><br><span class="line">字符串长度在[<span class="number">0</span>, <span class="number">50000</span>]范围内。</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>
<h3 id="解题方法">解题方法：</h3>
<ol type="1">
<li>遍历模拟：两层遍历，内层用<code>while</code>，判断当前字符连续出现了多少个</li>
</ol>
<div class="note primary">
            <p>时间复杂度为O(n)，空间复杂度为O(n)，用于存储生成的字符串</p>
          </div>
<h3 id="解法一">解法一：</h3>
<div class="note warning">
            <ol type="1"><li>强制类型转化：想把<code>int</code>转为对应的字符，不可以用<code>char()</code>，因为这样会转化到对应的ASCII表中的字符，需要用<code>to_string()</code>来转化，转换完为<code>string</code>类型</li><li><code>S.push_back(char c)</code>：push_back()函数只能在字符串末尾添加字符，而不能是字符串</li><li><code>S.insert(int pos, string s)</code>：insert()函数只能在<code>pos</code>后面添加字符串，而不能是字符。如果<code>pos==S.size()</code>时，可以直接用加号<code>S = S + s</code>就可以了</li></ol>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">compressString</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string S2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;S.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = S[i];</span><br><span class="line">            <span class="keyword">int</span> c_num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(c == S[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                c_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            S2.<span class="built_in">push_back</span>(c); <span class="comment">// 只能push_back(char c) char类型变量</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; S2.size() &lt;&lt; (char(c_num)) &lt;&lt; &quot;##&quot; &lt;&lt; to_string(c_num); // 1##23##15##57##2 </span></span><br><span class="line">            S2.<span class="built_in">insert</span>(S2.<span class="built_in">size</span>(), <span class="built_in">to_string</span>(c_num)); <span class="comment">// 只能insert(int pos, string s) string类型变量</span></span><br><span class="line">            <span class="comment">// S2 = S2 + to_string(c_num);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(S.<span class="built_in">size</span>() &lt;= S2.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        <span class="keyword">return</span> S2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>强制类型转化</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0105 一次编辑</title>
    <url>/archives/bba92df8.html</url>
    <content><![CDATA[<h3 id="题目一次编辑">题目：<a href="https://leetcode-cn.com/problems/one-away-lcci/">一次编辑</a></h3>
<ul>
<li><p>字符串有三种编辑操作：插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line">输入: </span><br><span class="line">first = <span class="string">&quot;pale&quot;</span></span><br><span class="line">second = <span class="string">&quot;ple&quot;</span></span><br><span class="line">输出: <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line">输入: </span><br><span class="line">first = <span class="string">&quot;pales&quot;</span></span><br><span class="line">second = <span class="string">&quot;pal&quot;</span></span><br><span class="line">输出: <span class="literal">False</span></span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>
<h3 id="解题方法">解题方法：</h3>
<ol type="1">
<li>分情况讨论：
<ol type="1">
<li>当两字符串长度相差大于1时：不可能</li>
<li>当两字符串长度相等时：判断替换次数是否小于等于一</li>
<li>当两字符串长度相差为1时：遍历长的，看短的是否能只用一次插入就完成</li>
</ol></li>
</ol>
<div class="note primary">
            <p>目前只有一种解决方案，时间复杂度为O(n)，空间复杂度为​O(n)​</p>
          </div>
<h3 id="解法一">解法一：</h3>
<div class="note warning">
            <p>巧妙的点在于当长度相差1时，可以再次调用函数，传入参数时将<code>first</code>和<code>second</code>对调即可</p>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">oneEditAway</span><span class="params">(string first, string second)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == second) <span class="comment">// 相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(first.<span class="built_in">size</span>() == second.<span class="built_in">size</span>()) <span class="comment">// 不相等，但长度相等，判断替换策略是否可行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;first.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(first[i] != second[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    flag++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag &lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((first.<span class="built_in">size</span>() - second.<span class="built_in">size</span>()) == <span class="number">1</span>) <span class="comment">// 不相等，长度差一，判断添加策略是否可行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;first.<span class="built_in">size</span>(); ++i, ++j) <span class="comment">// 注意遍历较长的字符串</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;  &quot;&lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span>(first[i] != second[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((first.<span class="built_in">size</span>() - second.<span class="built_in">size</span>()) == <span class="number">-1</span>) <span class="comment">// 不相等，长度差一，判断添加策略是否可行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">oneEditAway</span>(second, first); <span class="comment">// 聪明的switch</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>情侣沟通</title>
    <url>/archives/22e4771a.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4784b14b8153bf5e9b18fd9ceb51716917cd04c4191d917467238a31313d5649">915b933d189991889314fe32087a54781f7e7bb8dc60675a55ce347a88dc62d08729cec3335274d2eb97d0a5dcd2867682094e5b02ef7000c907cd45350340ee492c689c359cc431ab218720e62728e146169f06ca09c58da064a69d7e32b632b0867528a88a07a7571dc12924445ee2d5759245ee51d22f94a19338a803c1cd540b7645b5444b3fc9ea508fbb30b59ed030fad283a042aca370989057a17fa2bbbd8295e20b3fc012b4a9ec68eba0fab61333e3710e2dc019cf3e44817aeee37879966e001028992b9a64400a7a2c6a5780b925bfa532cdc8062cbbbb3d32aa615596fd6b2380f119a33065385eced36d08fd903cee28bb55ffb9e95f62acc0d83d8534c6f86bb45f878ebabe8f916e03bcd73803177d72d7282f397473e32224b23f83b4a81ad2bd2ac62fc2eb65871235078adc3072eea788da5cc35609fb36561af651c4d0616ceb9d655e5fe82e8de6cb623a8ba561913838d536641bdfe20d553ea0944e1584c07c85b9bc8b32787e10286ce64de976664baace1b41a6814c670c5b4796a2281798bc452aa0f508a7f53ec776ea3fcb376d2d8287f2c35a41a807d7f44b86e42f35526c184c235437815173badd2050ee840daae5305bc1a9d371f07e47e55f0ad2fe0b9a97bb69eb754dbb42e93d5c0550d1f1ddbc95ffb965ad7472dd4f74626d0011694bfac83890f4f10b56566b26524ccadaa7389c8659635c98165434f6d81c68f4089958b67981cf6dcb57dded0bd8e8837b9b3cb778c2f7ca7033eddfc4269a7d7484c1682ec89f76e180e49fef581680870aed42365f420579044eaa23c9e75fff1f5596a21e569f78d9dc25c64e850651dc188d4338a9e2ad8bdf96004d29e7f11f6656290ad113ad426c096649a7aaaa812b9e9896c106b5856d634d8f05971ab8089f0867873a0c0e35e50556eb860d1e44b1808a9f45dacfee8f259323bf1f8ab9eee9e88b82dd90b5ecf4578201aba64f05079627259663212a463b725f9512bd20ed8b3317281a4b6a085710698034e355caa52f8e2709dc34e630cf6b995a4a5879946d9d01b68e92e2fd486879556348de237697ec275f96de81b42c075ce54edb556c9ea94bcf1c8ae01a02912ec624e50f2965567b64cafb16c497f57c405663e71aca78c515a06665e0a8aba31b226bcffea05f1d07ec47444e5c8d295cfc84b4d736c175ad6f2e824cf887ba404b7d4a139b65b1c38dec884c7483cc602bb8f1e382e42c9e5cbf76984ff8a41b9800497476d993ef56a561b2e27edfa16e1bd4fa6b70eed807b58c79da360440cee02e2e8e78db3e770a01d0e9c8fc346cdd36a1c67b630e7bfbeb54883970e4ff48e686a18bfb143a46565a73ff2364bd91e7b4f7e0d50e33567fb8a8835d9ef6ebed6cc79ce0b98e5fbc3b307a8e769a90a18155ee4720ca230a294c5564deae6d0b3164dbfdcc575bc1327357de3d63313dd9317028c3f96bad811006961f2ea8bb0a90b290cdeff462fdea4d05f5c2d05b05a2442e84bf3074808ef97e909b0c6b07003c967c6dc517155cdc1d1545ed156f09beece6e711bffb99ad18946de21699156eb183e1b8def83eb2436647ea3a479bbb5bf7c9b7e82e60fd6837efc7ef8162bbdde0d46e9da72823a37ede3405c8d519cefd3242a9c636ddf3561635a19a351cbc78c12d39478ebf04827ddb721e9d9be1fb9c92eaba9140a0126db7c86d4c78630cc7baae9af3f854032c40a4d47e752e87a1a9bd1e9f7176a3d1d6ff163e10b34ee9889c6f95005ef0235d92d17ee84107dabd9f342c101af7bd7fdcb91cd461803f0e0fee45184ff49c1ededb3e9e8e1f57424f90bd0c8299a25a2161155a819488746fc7a8bc490e07dd0dd775be16b8cf2f9e547a62f10d35eb91fb779fd75dea17bd8546eb25c854ff23c0e172601105fc1ae4509fbcb63e0dd04fb6b7a1f62bea1c220dd8227eb412fdb42a5da83e9b315571df620f2081ed5c0a8a23934cec050a8004816f6fd9479c9d0123e3ae276cdf3707d9f34ac34cf3cd45985d61ba3970331324cf08ba36169c3cb61b43a31f056f3c58ed1728f146f0c4a8acf2582404b2e9aa13d1e151d6a0eeee5922b304799b33292abb0a64b753d82175bafea38d3abeb939f6de36e8ed5cbf0c9c4197c7f3141942dfc65f9ec9521208ea4c99188724c22fbd92ab4f1decd4df23330a1b248e3982fe3ef6113759b9da39b1d06aac57450ea862a57e85209129ee542560e678230f19b7be790565f7e6e9a9a248298b2b2e97910231fe67a9bafe1d1edec0f3e2659e1ae6ddc209f56f6fc4a3af0b7560acd648c68ee24f28e88169f1ceb0c7f841b3a634914118de33e71c56df9ca96044752937f6f3be68201581cb48984c64da1b269c5580ba441b178f1fc98aad7f8ed50ce7b49974dc24c2f7324bdd1dda3aeebc8d38ce12e0e9fe7d913331182743d210f4fc95e93a3394b480b2ec97df1ac30c5ff5be4ff4e5c597747d3519925c8553b06d5a412d7efefed974b343c1ecd55edab10fde0ad53a7a7c06e34f0e6badc11bd1dd4d7e1e94f8894d4960619fb585aa1fa78cd4e6efc64e81ebb74343395b338b0bf8698a802d9bb9a1d97b9bc17d256c1a2b109ce9c2df2a9c705728078cea6143a57f3102f2f1febab6185103ef0dfe282bad116261b9018b5e18044d6fbbeb70a23362f441525c2ae81f48cf632fb3ee428cb195b84ff62b41e404636f384bc602ba9539ca3911c64cf460043a5d480cec72370eaa51c39558368c415a59439cb373be008efe2479a3b3aa100198dc10b77eb7b4029daa33ec200960ccd83f25111e2879b0b612b7745d8390baa7a7d63cdfc61abd6ff0ae2c962f2e5ab752a6b4f5156295c8192ea4e21d8e20ca5c8f2cda3fe13035ef1c03c445bc378f83a8f051ba868843ea10c08e72cb59b8baf235034e6b4e5b482578790e51aa04d140d53b2a01d384c0e2f0611236adaba22fd13e588bd05b9cc3e7506d30fab1df9d739a6cfede6dcf8a6615cc90980de34557ba1ec6e34a3d4c97640c921c834d1d1d859e60770b422abb59539fac4f51d7cecfd1ca95dbf4450ae153499bb44d942ba4242acc9ca252321f0d996006d78fabf9387b606c7654b75b39ac10f21c3bec62ef670b0d776b7569ae65084411542e4b760d04d0c0156df14756144a06d71d2d6d53970a5a43adec595c30a4bb88389b00e6386ab845b00a7695b22065f3dd20a2717b42106fa43bcc92822c53fe78cd77ac671abfc10fe00c038d5d6279b9437361508d7124a0d4087eebc662fbea3b80bb83f312032afeaa5a91973eff7b06434878fc1de4011d0e2f004881b97c9d63c0a27e411f022e167f19f529be5af36fce99ad20f2644bdd49da7a5174884b5c16e0665078343bfad2c497be6655186e8d939a484e46dd6774c6d5dcdad0e93b221bfb2f22aac317376ce52c39840b03548375a156808e1766d2c97a9e9fd0624f0960b696449b3085b6ac456239e96e7335768ecb3402576ecbb5e499af1a080ff425bf94a3fe1e93effebd0f4c297297aa625dab50d89ee07bba4c3febc418334747af5e4d0a0a9d0021c49c5cf63beef105b86fcc7abaa8247130d08f33abd38eb29cae359bfa319dc19aea1fc26b3177355ba76fe7ff</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请在此输入密码">请在此输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>感情</category>
      </categories>
      <tags>
        <tag>沟通</tag>
        <tag>曾曾</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0104 回文排列</title>
    <url>/archives/d4029378.html</url>
    <content><![CDATA[<h3 id="题目回文排列">题目：<a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/submissions/">回文排列</a></h3>
<h3 id="解题方法">解题方法：</h3>
<ol type="1">
<li>位运算：统计某个字符出现的次数是奇数还是偶数，可以用<code>异或^</code>来统计</li>
<li>哈希计数</li>
<li>桶计数（较简单，未给出代码）</li>
</ol>
<div class="note primary">
            <ul><li><p>原理都是统计字符串中每个字符出现的频数，如果奇数的个数小于等于1，则可以产生回文排列，否则不行</p></li><li><p>三种方法时间复杂度相同，但所用到的空间不同，<code>1 &lt; 2 &lt; 3</code></p></li></ul>
          </div>
<span id="more"></span>
<h3 id="方法一位运算">方法一：位运算</h3>
<div class="note primary">
            <ul><li>代码只存了小写和大写字母，其实可以用两个long int型的来存128个字符，使得代码鲁棒性更强</li><li>用异或操作来存储字符出现的奇偶，如果奇数则为1，偶数为0</li><li>最后判断s中字符出现的奇偶次数，奇数个数小于等于1时返回true<ul><li>奇数个数为1，此时<code>mark</code>为<span class="math inline">\(2^x\)</span>，也就是<span class="math inline">\(00..010..0\)</span>这种形式，此时可以用<span class="math inline">\(mark-1\)</span>，变为<span class="math inline">\(00...001...1\)</span>的形式，此时两者用与操作，则为0</li><li>奇数个数为0，此时mark为0，mark-1为<span class="math inline">\(111...1\)</span>，此时与操作也是0</li></ul></li></ul>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPermutePalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">int</span> mark = <span class="number">0</span>;<span class="comment">// 用bit来存储</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in"><span class="keyword">int</span></span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=<span class="number">0</span> &amp;&amp; tmp&lt;=<span class="number">25</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">int</span> num = <span class="built_in"><span class="keyword">long</span></span>(<span class="number">1</span>) &lt;&lt; tmp;</span><br><span class="line">                mark = mark ^ num; <span class="comment">// 异或</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp2 = <span class="built_in"><span class="keyword">int</span></span>(s[i] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmp2&gt;=<span class="number">0</span> &amp;&amp; tmp2&lt;=<span class="number">25</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">int</span> num = <span class="built_in"><span class="keyword">long</span></span>(<span class="number">1</span>) &lt;&lt; (tmp2 + <span class="number">26</span>);</span><br><span class="line">                mark = mark ^ num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s中最多只能有一个字母出现的频数是奇数</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(mark == 0) return true;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;64; ++i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            long int num = long(1) &lt;&lt; i;</span></span><br><span class="line"><span class="comment">            if(num == mark) return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 以上注释地方可以用这个替换</span></span><br><span class="line">        <span class="keyword">return</span> ((mark &amp; (mark<span class="number">-1</span>)) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二哈希">方法二：哈希</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPermutePalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">int</span> count_odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            map[s[i]] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count_odd++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count_odd &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>位运算</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0103 URL化</title>
    <url>/archives/a7735c82.html</url>
    <content><![CDATA[<h3 id="题目url化">题目：<a href="https://leetcode-cn.com/problems/string-to-url-lcci/">URL化</a></h3>
<h3 id="解题方法">解题方法：</h3>
<ol type="1">
<li>新建字符串，双指针法</li>
<li>在<code>S</code>上从后往前，双指针法</li>
</ol>
<div class="note primary">
            <p>两种解法时间复杂度一样，都是<span class="math inline">\(O(n)\)</span>，解法二不需要额外的空间</p>
          </div>
<span id="more"></span>
<h3 id="解法一">解法一：</h3>
<div class="note warning">
            <ul><li>这里可以通过初始化一个和<code>S</code>相同大小的<code>string</code>来存储新的序列，这里直接用<code>[p2]</code>来寻址就可以了，最后用<code>erase(int pos, int len)</code>来删除从<code>pos</code>开始长度为<code>len</code>的字符串</li><li>也可以新建一个空的字符串，用<code>insert(int pos, string s)</code>来在<code>pos</code>处插入<code>string</code>字符串，或用<code>push_back(char c)</code>来在<code>string</code>末尾添加<code>char</code>字符</li></ul>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpaces</span><span class="params">(string S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        string S2 = S; <span class="comment">// 不初始化就不能用S2[p2]这样的寻址方法，而应该用push_back(char c)</span></span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p1=<span class="number">0</span>; p1&lt;length; ++p1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[p1] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                S2[p2++] = S[p1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                S2[p2++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                S2[p2++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                S2[p2++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        S2.<span class="built_in">erase</span>(p2); <span class="comment">// erase(int start [, int len])，从start开始，删除len个长度，没有len的话会删除start开始的所有字符</span></span><br><span class="line">        <span class="keyword">return</span> S2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpaces</span><span class="params">(string S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        string s2;</span><br><span class="line">        s2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s2.<span class="built_in">insert</span>(j++, <span class="string">&quot;%&quot;</span>); <span class="comment">// 注意这里insert后面用的是string类型 或者是char *，即字符数组，而不是char &#x27;%&#x27;</span></span><br><span class="line">                s2.<span class="built_in">push_back</span>(<span class="string">&#x27;2&#x27;</span>); <span class="comment">// 这里可以用push_back()，此时就是char类型，而不是char *</span></span><br><span class="line">                j++;</span><br><span class="line">                s2.<span class="built_in">insert</span>(j++, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                string <span class="built_in">tmp</span>(<span class="number">1</span>, S[i]); <span class="comment">// 将S[i]转化为字符串类型，再使用insert</span></span><br><span class="line">                s2.<span class="built_in">insert</span>(j++, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s2.insert(0, &quot;abc&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二">解法二：</h3>
<div class="note warning">
            <p>因为题目中说<code>S</code>的长度够长，因此可以利用双指针，一个从<code>S</code>的末尾开始，一个从给定字符串长度开始，从后往前遍历。最后删掉<code>S</code>前面多余的部分即可</p>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpaces</span><span class="params">(string S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = S.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                S[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                S[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                S[j--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                S[j--] = S[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        S.<span class="built_in">erase</span>(<span class="number">0</span>, j+<span class="number">1</span>); <span class="comment">// j多减了1，因此要加回来</span></span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0102 判断是否互为字符重排</title>
    <url>/archives/d48fbf58.html</url>
    <content><![CDATA[<h3 id="题目判定是否互为字符重排">题目：<a href="https://leetcode-cn.com/problems/check-permutation-lcci/">判定是否互为字符重排</a></h3>
<h3 id="解题方法">解题方法：</h3>
<ol type="1">
<li>用哈希表<code>unordered_map&lt;char, int&gt;</code>，记录<code>s1</code>中字符出现数，并于<code>s2</code>做对比</li>
<li>用<code>int count[256]</code>的数组来完成上述工作<strong>（桶计数）</strong></li>
<li>没想到的方法：将<code>s1</code>和<code>s2</code>内部按照字符升序排序，最后判定两者是否相等即可</li>
</ol>
<div class="note primary">
            <p>2的时间复杂度为<span class="math inline">\(O(N)\)</span>，因为<span class="math inline">\(N &lt;= 100\)</span>，因此可以理解为<span class="math inline">\(O(1)\)</span></p>
          </div>
<span id="more"></span>
<h3 id="解法一">解法一：</h3>
<div class="note warning">
            <p>用到了C++ std中的<code>unordered_map</code>类，需要注意是否可以修改<code>pair</code>中的值！</p><p><code>it</code>的类型是什么！！？？</p><p><code>unordered_map&lt;char, int&gt;</code>中，添加新hash对时，初值为0？？</p>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">CheckPermutation</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            map[s1[i]] += <span class="number">1</span>; <span class="comment">// 初值是0吗？</span></span><br><span class="line">            map[s2[i]] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// unordered_map&lt;char, int&gt;::iterator it;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : map) <span class="comment">// 这里it的类型是？</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(it.second != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二">解法二：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">CheckPermutation</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">256</span>];</span><br><span class="line">        <span class="built_in">memset</span>(count, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(count));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            count[<span class="built_in"><span class="keyword">int</span></span>(s1[i])]++;</span><br><span class="line">            count[<span class="built_in"><span class="keyword">int</span></span>(s2[i])]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法三">解法三</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">CheckPermutation</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s1 == s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>面试金典0101 判定字符是否唯一</title>
    <url>/archives/15f7c05f.html</url>
    <content><![CDATA[<h3 id="题目判定字符是否唯一">题目：<a href="https://leetcode-cn.com/problems/is-unique-lcci/">判定字符是否唯一</a></h3>
<ul>
<li><p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 样例1</span></span><br><span class="line">输入: s = <span class="string">&quot;leetcode&quot;</span></span><br><span class="line">输出: false</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 样例2</span></span><br><span class="line">输入: s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>
<h3 id="解题方法">解题方法：</h3>
<ol type="1">
<li>用哈希表<code>unordered_map</code>，记录目前为止出现的字符</li>
<li>用bool数组来完成记录功能<strong>（桶计数）</strong></li>
<li>用位运算代替bool数组的记录功能</li>
</ol>
<div class="note primary">
            <p>以上三种算法的时间复杂度均为<span class="math inline">\(O(n)\)</span>，差别在于空间利用的大小，其实量级也都是<span class="math inline">\(O(1)\)</span>，但是实际利用的比特数不同</p>
          </div>
<h3 id="解法一">解法一：</h3>
<div class="note warning">
            <p>用到了C++ std中的<code>unordered_map</code>类，需要注意如何插入和查找</p>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnique</span><span class="params">(string astr)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; map;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;astr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((it = map.<span class="built_in">find</span>(astr[i])) != map.<span class="built_in">end</span>()) <span class="comment">// delete &#x27;it&#x27; will get the same result.</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(astr[i], <span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">        <span class="comment">// 赋值语句返回值为所赋的值，这也是连等的合法性</span></span><br><span class="line">        <span class="comment">// int a=3, b=2;</span></span><br><span class="line">        <span class="comment">// if((a=2) == b)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; (a = b = 3) &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二">解法二：</h3>
<div class="note warning">
            <p>ASCII码表原本是只有128个字符的（对应7bits的空间 <span class="math inline">\(2^7=128\)</span>），但为了有更多的字符而扩充到了256个字符（对应8bits空间 <span class="math inline">\(2^8=256\)</span>）</p>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnique</span><span class="params">(string astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> A[<span class="number">256</span>]; <span class="comment">// record; ASCII augmentation includes 256 characters</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">memset</span>(A, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(A));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;astr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!A[<span class="built_in"><span class="keyword">int</span></span>(astr[i])]) <span class="comment">// current character has not appeared</span></span><br><span class="line">            &#123;</span><br><span class="line">                A[<span class="built_in"><span class="keyword">int</span></span>(astr[i])] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法三">解法三：</h3>
<div class="note warning">
            <p><a href="https://leetcode-cn.com/problems/is-unique-lcci/solution/wei-yun-suan-fang-fa-si-lu-jie-shao-by-zhen-zhu-ha/">解题参考</a> 注意原作者只考虑小写字母的情况，如果是整个ASCII表的话，有128个字符，需要两个long int型来存储（32位机上int型是4字节32bits，long int是8字节64bits），每部分的逻辑一样，只是外层加入是否大于64而已</p>
          </div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnique</span><span class="params">(string astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// noticed &#x27;left&#x27; should be equal to 0</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;astr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_num = <span class="built_in"><span class="keyword">int</span></span>(astr[i]);</span><br><span class="line">            <span class="keyword">if</span>(cur_num &gt;= <span class="number">64</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">int</span> cur = <span class="built_in"><span class="keyword">long</span></span>(<span class="number">1</span>) &lt;&lt; (cur_num - <span class="number">64</span>); <span class="comment">// noticed &#x27;1&#x27; should be the type of &#x27;long int&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>((left &amp; cur) == <span class="number">0</span>) <span class="comment">// noticed the priority of the &#x27;&amp;&#x27; and &#x27;==&#x27;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left = left | cur;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">int</span> cur = <span class="built_in"><span class="keyword">long</span></span>(<span class="number">1</span>) &lt;&lt; cur_num;</span><br><span class="line">                <span class="keyword">if</span>((right &amp; cur) == <span class="number">0</span>) <span class="comment">// noticed the priority of the &#x27;&amp;&#x27; and &#x27;==&#x27;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right = right | cur;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>位运算</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>21年华为秋招</title>
    <url>/archives/36ae25f5.html</url>
    <content><![CDATA[<blockquote>
<p>分为机考和面试两个部分，机考240/600，面试三轮，前两轮技术，最后一轮简历，积累了一点自信，但也看到了差距，之后要好好刷题，争取更加从容，加油！</p>
</blockquote>
<span id="more"></span>
<h2 id="一机考">一、机考</h2>
<blockquote>
<p>上周12.8参加了华为秋招的机试，不是在牛客网，是自己的平台，手机没有被绑定。三道编程题，都非常的不友好，最终只做出来了第二题，拿到了200分。</p>
</blockquote>
<ul>
<li>经验总结：
<ol type="1">
<li>有时第一题看起来简单，但是很复杂，分值又低，如果非常难搞，建议先完成后面的题目</li>
<li>题目给出的测试样例很少，有一些特殊的场景需要自己去想到，比如第二题计算并行任务数时，在第一个时间戳之前是可以有任务存在的，这里是个大坑</li>
<li>第一题和第三题没做出来，之后有机会先把第三题做了，再做第一题</li>
</ol></li>
</ul>
<h2 id="二面试">二、面试</h2>
<blockquote>
<p>本周一12.13日（南京大屠杀纪念日）完成了三轮面试，积累了一定的自信，但还要继续努力，毕竟面试官比较熟悉，题目也比较熟悉，之后的面试必然不会这么简单。</p>
</blockquote>
<h3 id="第一轮面试王云鹤">第一轮面试：王云鹤</h3>
<ul>
<li><p>面试流程：</p>
<ul>
<li>Part1：自我介绍+工作讲解+提问细节+概率题（共30min）</li>
<li>Part2：编程（解数独，自己写输入输出）</li>
</ul></li>
<li><p>经验总结：</p>
<ul>
<li>Part1中没有过多刁难，但是有些项目细节还需要进一步熟悉和搞懂</li>
<li>由于之前做过解数独这道题，所以做起来思路上是清晰的，但是最后还是代码有细节上的bug，std库用的也不是很好，导致最后没有了debug的时间</li>
</ul></li>
<li><p>概率题：宝剑升级</p></li>
<li><p>编程题：解数独</p>
<ul>
<li>方法：dfs搜索每一个空白位置，每一个位置依次尝试1-9这九个数字，符合要求则继续深搜，不符合则回溯，注意回溯时需要将相应的flag修改回来</li>
<li><strong>技巧：</strong>
<ul>
<li>为每行每列每个block都建立一个bool型的数组，用于存放当前行、列、block内，当前数字是否已被用过</li>
<li>存储空白点的位置，存入vector中，然后直接这些位置，而不用类似于迷宫再去上下左右的走</li>
</ul></li>
<li>编程实现：
<ul>
<li><code>vector&lt;pair&lt;int, int&gt;&gt;</code>的使用，用于存储空白点位置</li>
<li><code>pair&lt;int, int&gt;</code>：可以存储“变量当前值”，和vector配合使用时，要用<code>emplace_back()</code>，提取时用<code>.first</code>和<code>.second</code></li>
</ul></li>
<li>Debug：
<ul>
<li><code>block[x/3][y/3][num]</code>这里忘记除以3了</li>
<li><code>char(i + '1')</code>才可以把i变为相应的字符型，如果是<code>char(i)+1</code>则和前者的效果不一样</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> board[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">bool</span> row[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">bool</span> colum[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">bool</span> block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pos;</span><br><span class="line"><span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cur == pos.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		result = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x = pos[cur].first;</span><br><span class="line">	<span class="keyword">int</span> y = pos[cur].second;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; x &lt;&lt; y;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span>(!result &amp;&amp; !row[x][i] &amp;&amp; !colum[y][i] &amp;&amp; !block[x/<span class="number">3</span>][y/<span class="number">3</span>][i])</span><br><span class="line">		&#123;</span><br><span class="line">			row[x][i] = colum[y][i] = block[x/<span class="number">3</span>][y/<span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">			board[x][y] = <span class="built_in"><span class="keyword">char</span></span>(i + <span class="string">&#x27;1&#x27;</span>); <span class="comment">// char(i) + &#x27;1&#x27; is not right!! </span></span><br><span class="line">			<span class="built_in">dfs</span>(cur+<span class="number">1</span>);</span><br><span class="line">			row[x][i] = colum[y][i] = block[x/<span class="number">3</span>][y/<span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(row, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(row));</span><br><span class="line">	<span class="built_in">memset</span>(colum, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(colum));</span><br><span class="line">	<span class="built_in">memset</span>(block, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(block));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">        cin.<span class="built_in">get</span>();</span><br><span class="line">		cin.<span class="built_in">get</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			cin.<span class="built_in">get</span>();</span><br><span class="line">			cin &gt;&gt; c;</span><br><span class="line">			board[i][j] = c;</span><br><span class="line">			<span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				pos.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">		 	    <span class="keyword">int</span> num = <span class="built_in"><span class="keyword">int</span></span>(c - <span class="string">&#x27;0&#x27;</span>) - <span class="number">1</span>;</span><br><span class="line">				row[i][num] = <span class="literal">true</span>;</span><br><span class="line">				colum[j][num] = <span class="literal">true</span>;</span><br><span class="line">				block[i/<span class="number">3</span>][j/<span class="number">3</span>][num] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cin.<span class="built_in">get</span>();</span><br><span class="line">			cin.<span class="built_in">get</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; board[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第二轮面试陈醒濠">第二轮面试：陈醒濠</h3>
<ul>
<li><p>面试流程：同上</p></li>
<li><p>经验总结：意识到了一些自己之前工作中可以继续深挖的点，非常感谢醒濠，之后一定会做出尝试的</p></li>
<li><p>编程题：9键字符序列对应的全排列</p>
<ul>
<li>方法：对于字符串中的的每一个数字，递归遍历他对应的字符，加入到当前排列中，回溯时，删除当前字符</li>
</ul></li>
<li>技巧：
<ul>
<li>将数字与字符的对应关系提前存好，下标关系对应即可，有时用空间换思路上的简单明了也是可以的</li>
</ul></li>
<li>编程实现：
<ul>
<li>用<code>vector&lt;string&gt;</code>存取全部的排列结果</li>
<li>用<code>string</code>存取当前排列结果
<ul>
<li><code>push_back()</code>：可以在string后加入char</li>
<li><code>pop_back()</code>：删除string后面的一个char</li>
</ul></li>
<li>Debug：
<ul>
<li>加入特殊字符的判定，全局加入<code>bool flag = false;</code></li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Map[<span class="number">8</span>][<span class="number">4</span>] = &#123;&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;, &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;,</span><br><span class="line">	 		   	  &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;, &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;, &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">	 		   	  &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;, &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;&#125;;</span><br><span class="line">string s;</span><br><span class="line">string rst;</span><br><span class="line">vector&lt;string&gt; result;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(string &amp; rst, <span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cur == s.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		result.<span class="built_in">push_back</span>(rst);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in"><span class="keyword">int</span></span>(s[cur] - <span class="string">&#x27;0&#x27;</span>) - <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(num&lt;<span class="number">0</span> || num&gt;<span class="number">7</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(Map[num][i] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			rst.<span class="built_in">push_back</span>(Map[num][i]);</span><br><span class="line">			<span class="built_in">permute</span>(rst, cur+<span class="number">1</span>);</span><br><span class="line">			rst.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="built_in">permute</span>(rst, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[]&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;result.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">		    cout &lt;&lt; result[i] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>​</p>
<h3 id="第三轮面试蒋欣nlp大佬">第三轮面试：蒋欣（NLP大佬）</h3>
<ul>
<li>面试流程：只有半小时的简历面</li>
<li>问题：
<ul>
<li>简短介绍之前工作</li>
<li>之前项目最大的挑战</li>
<li>公司价值观是否认同以及匹配</li>
<li>长期规划</li>
<li><strong>反问：</strong>科研和项目的部门是否分开？</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之动态规划</title>
    <url>/archives/1117fa0c.html</url>
    <content><![CDATA[<p>动态规划实在是同重要了，而且饱含了计算机之美，虽然多次被虐，但还是决定要认真牢记！</p>
<ul>
<li>主要思想：用空间换时间，从而避免递归中不必要的重复计算。</li>
<li>难点：定义<span class="math inline">\(dp[i]\)</span>的含义，以及动态转移方程</li>
</ul>
<span id="more"></span>
<h2 id="线性dp">线性DP</h2>
<h3 id="连续子数组最大和存在负数">1. 连续子数组最大和（存在负数）</h3>
<ul>
<li>解题思路：
<ul>
<li><span class="math inline">\(dp[i]:\)</span> 定义为在前<span class="math inline">\(i\)</span>个数中，以第<span class="math inline">\(i\)</span>个数为结尾的子数组最大连续和</li>
<li>动态转移方程：<span class="math inline">\(dp[i] = max(dp[i-1]+dp[i],\ dp[i])\)</span> （如果到目前为止你的过去是负担，那就放下吧，每天都是新的开始~）</li>
</ul></li>
<li>代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span>&gt; <span class="title">A</span><span class="params">(n+<span class="number">10</span>, <span class="number">0</span>)</span></span>; <span class="comment">// notice the range of each value!</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">long</span> sum_max = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = <span class="built_in">max</span>(A[i<span class="number">-1</span>] + A[i], A[i]);</span><br><span class="line">        sum_max = <span class="built_in">max</span>(A[i], sum_max);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum_max &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="不相邻取数的子数组最大和均为正数">2. 不相邻取数的子数组最大和（均为正数）</h3>
<ul>
<li>解题思路：
<ul>
<li><span class="math inline">\(dp[i]:\)</span> 定义为在前<span class="math inline">\(i\)</span>个数中，以第<span class="math inline">\(i\)</span>个数为结尾的不相邻数的最大和</li>
<li>动态转移方程：<span class="math inline">\(dp[i] = max(dp[i-2]+dp[i],\ dp[i-3]+dp[i])\)</span> （只考虑<span class="math inline">\(a_i\)</span>为正数的情况，需要求一堆数的max）</li>
</ul></li>
<li>代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span>&gt; <span class="title">A</span><span class="params">(n+<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">long</span> rst = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rst = <span class="built_in">max</span>(rst, A[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        A[<span class="number">2</span>] = A[<span class="number">0</span>]+A[<span class="number">2</span>];</span><br><span class="line">        rst = <span class="built_in">max</span>(A[<span class="number">1</span>], A[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// notice all the elems in A are positive number</span></span><br><span class="line">            <span class="comment">// otherwise need to max&#123;A[i]+A[0],...,A[i]+A[i-2]&#125;</span></span><br><span class="line">            A[i] = <span class="built_in">max</span>(A[i] + A[i<span class="number">-2</span>], A[i] + A[i<span class="number">-3</span>]); </span><br><span class="line">            rst = <span class="built_in">max</span>(rst, A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; rst &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="括号生成">3. 括号生成</h3>
<ul>
<li><p>题目表述：数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">&quot;((()))&quot;</span>,<span class="string">&quot;(()())&quot;</span>,<span class="string">&quot;(())()&quot;</span>,<span class="string">&quot;()(())&quot;</span>,<span class="string">&quot;()()()&quot;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>动态规划解题思路：（同样可以用带回溯的递归来解题，后附代码）</p>
<ul>
<li><span class="math inline">\(dp[i]\)</span>：表示当有 <span class="math inline">\(i\)</span> 组括号时，可能的全部排列方式（字符串集合<code>vector&lt;string&gt;</code>）</li>
<li>动态转移方程：<code>dp[i] = for(j=0; j&lt;i; ++j)&#123;第i个括号里有j组括号，右边有i-j-1组括号&#125;</code>
<ul>
<li>第i组括号的左括号加在字符串最左边，右括号加在p，q之间，其中p和q分别是dp[j]和dp[i-j-1]内任意的数组，其中j可以从0取到i-1</li>
</ul></li>
</ul></li>
<li><p>动归代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="string">&quot;()&quot;</span>&#125;;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>); <span class="comment">// 这里是1维dp</span></span><br><span class="line">        dp[<span class="number">0</span>] = &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        dp[<span class="number">1</span>] = &#123;<span class="string">&quot;()&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(string p : dp[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(string q : dp[i-j<span class="number">-1</span>]) <span class="comment">// 这里i就是n，n-j-1+j = n-1，即p+q是n-1组括号</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i].<span class="built_in">push_back</span>(<span class="string">&quot;(&quot;</span> + p + <span class="string">&quot;)&quot;</span> + q);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>带回溯的递归代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(vector&lt;string&gt; &amp; result, string &amp; cur, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="built_in">size</span>() == total)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; total/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="built_in">generate</span>(result, cur, left, right, total);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)</span><br><span class="line">        &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="built_in">generate</span>(result, cur, left, right, total);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string current;</span><br><span class="line">        <span class="built_in">generate</span>(result, current, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*n); <span class="comment">// 传入左右括号的个数</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="最长有效括号">4. 最长有效括号</h3>
<ul>
<li><p>题目描述：给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(()&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">&quot;()&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>解题思路：</p>
<ul>
<li><p><code>dp[i]</code>：表示以 <code>s[i]</code> 为结尾的最长有效子字符串的长度</p></li>
<li><p>动态转移方程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">    dp[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> :</span><br><span class="line">    <span class="comment"># 为&quot;(...)()&quot;类型</span></span><br><span class="line">    <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> : </span><br><span class="line">        dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span> <span class="comment">#要保证i - 2 &gt;= 0</span></span><br><span class="line">    <span class="comment"># 为&quot;(...)((...))&quot;类型</span></span><br><span class="line">    <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] + <span class="number">2</span> <span class="comment">#要保证i - dp[i - 1] - 2 &gt;= 0</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化：全部为0（主要是dp[0]=0）</p></li>
<li><p>求解：<span class="math inline">\(max_i\{dp[i]\}\)</span></p></li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i) <span class="comment">// 第一个不管是什么，dp[0]都是1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i<span class="number">-2</span> &gt; <span class="number">0</span>) dp[i] = <span class="number">2</span> + dp[i<span class="number">-2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i<span class="number">-1</span>] &gt; <span class="number">0</span>) <span class="comment">// 表示s[i-1]==&#x27;)&#x27;且有匹配</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>) <span class="comment">// 判断边界</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-2</span> &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i] = dp[i] + dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]; <span class="comment">// 判断边界</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接雨水">5. 接雨水</h3>
<ul>
<li><p>题目描述：给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水</p>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/lc42接雨水.png" width="50%" height="50%" align="center"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：height = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上面是由数组 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="number">6</span> 个单位的雨水（蓝色部分表示雨水）</span><br></pre></td></tr></table></figure></li>
<li><p>解题思路：</p>
<ol type="1">
<li>动归：
<ul>
<li>部分利用动归，只是起到存储，不用重复计算的功能，本题用来计算节点 <code>i</code> 左侧的最大值（包括i）和右侧的最大值 <code>maxLeft[i]和maxRight[i]</code></li>
<li><code>ans += min(maxLeft[i], maxRight[i]) - height[i]</code> 遍历所有的i</li>
</ul></li>
<li>双指针：
<ul>
<li><code>left和right</code>指针分别从左右两侧向中间靠拢，<code>maxLeft和maxRight</code>分别记录当前左侧和右侧的最大值</li>
<li>如果<code>height[left]&lt;height[right]</code>时，则 <code>i</code> 位置的存雨量取决于左侧的最大值和当前高度差，即<code>maxLeft-height[left] if(maxLeft&gt;height[left])</code>，如果左侧最大值小于当前高度，则只用更新<code>maxLeft</code>即可</li>
</ul></li>
</ol></li>
<li><p>动归思想代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxLeft</span><span class="params">(size, <span class="number">0</span>)</span>, <span class="title">maxRight</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line">        maxLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            maxLeft[i] = <span class="built_in">max</span>(height[i], maxLeft[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxRight[size<span class="number">-1</span>] = height[size<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=size<span class="number">-2</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            maxRight[i] = <span class="built_in">max</span>(maxRight[i+<span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">min</span>(maxLeft[i], maxRight[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>双指针思路代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = size<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLeft = <span class="number">0</span>, maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right]) <span class="comment">// 此时注水高度取决于左侧最高点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(maxLeft &gt; height[left]) ans += maxLeft - height[left];</span><br><span class="line">                <span class="keyword">else</span> maxLeft = height[left];</span><br><span class="line">                left++; <span class="comment">// 注意无论ifelse，都需要++</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 注水高度取决于右侧最高点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(maxRight &gt; height[right]) ans += maxRight - height[right];</span><br><span class="line">                <span class="keyword">else</span> maxRight = height[right];</span><br><span class="line">                right--; <span class="comment">// 注意这里是--</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>[TOC]</p>
<h2 id="二维dp">二维DP</h2>
<h3 id="最长回文子串除dp外还有两种更优解法待学习">1. <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">最长回文子串</a>（除DP外还有两种更优解法待学习！）</h3>
<ul>
<li><p>题目描述：给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 样例一</span></span><br><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure></li>
<li><p>解题思路：</p>
<ul>
<li><code>dp[i][j]​</code>：表示从 <code>s</code> 的第 <code>i</code> 位到第 <code>j</code> 位是否为回文串</li>
<li>动态转移方程：<code>dp[i][j] = dp[i+1][j-1] &amp;&amp; (s[i]==s[j])</code></li>
<li>初始化：<code>i==j</code> 时，<code>dp[i][i]=true;</code> <code>j-i=2</code>时，<code>dp[i][j] = (s[i]==s[j])</code></li>
</ul></li>
<li><p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> MaxLen = <span class="number">1</span>; <span class="comment">// 初值为1</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 边界条件 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">2</span>; L&lt;=s.<span class="built_in">size</span>(); ++L)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+L<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= s.<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(L == <span class="number">2</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]; <span class="comment">// 动态转移方程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只有dp[i][j]==true时，才可能更新MaxLen和begin</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; MaxLen &lt; j-i+<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    begin = i;</span><br><span class="line">                    MaxLen = j-i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt; begin&lt;&lt;&quot;#&quot;&lt;&lt;MaxLen;</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, MaxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 220629 B站实习面试第一轮</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> len = j-i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(len &lt;=<span class="number">2</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = (s[i]==s[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len&gt;<span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; len &gt; maxlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = len;</span><br><span class="line">                    l = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = s.<span class="built_in">substr</span>(l, maxlen);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="正则表达式匹配">2. 正则表达式匹配</h3>
<ul>
<li><p>题目描述：给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'（匹配任意单个字符）</code> 和 <code>'*'（匹配零个或多个前面的那一个元素）</code> 的正则表达式匹配。所谓匹配，是要涵盖<strong>整个</strong>字符串 <code>s</code> 的，而不是部分字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ab&quot;</span>, p = <span class="string">&quot;abc*&quot;</span></span><br><span class="line">输出：true</span><br><span class="line">解释：当<span class="string">&quot;c*&quot;</span>匹配<span class="number">0</span>个<span class="string">&quot;c&quot;</span>时，p = <span class="string">&quot;ab&quot;</span> = s </span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;ab&quot;</span>, p = <span class="string">&quot;.*&quot;</span></span><br><span class="line">输出：true</span><br><span class="line">解释：<span class="string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="string">&#x27;*&#x27;</span>）任意字符（<span class="string">&#x27;.&#x27;</span>）</span><br></pre></td></tr></table></figure></li>
<li><p>解题思路：</p>
<ul>
<li><p><code>dp[i][j]</code>：表示 <code>s</code> 的前 <code>i</code> 个字符与 <code>p</code> 中的前 <code>j</code> 个字符是否能够匹配</p></li>
<li><p>动态转移方程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> p[j] == s[i] : dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> p[j] == <span class="string">&#x27;.&#x27;</span> : dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> p[j] == <span class="string">&#x27;*&#x27;</span>：</span><br><span class="line">	<span class="keyword">if</span> p[j-<span class="number">1</span>] != s[i] : dp[i][j] = dp[i][j-<span class="number">2</span>] // 此时相当于把p[j-<span class="number">1</span>:j] = <span class="string">&#x27;a*&#x27;</span>整体抛弃</span><br><span class="line">	<span class="keyword">if</span> p[j-<span class="number">1</span>] == s[i] <span class="keyword">or</span> p[i-<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>： // 相当于p[j-<span class="number">1</span>:j]和s[i]匹配了，因此只用考虑两者的前面是否匹配</span><br><span class="line">		dp[i][j] = dp[i-<span class="number">1</span>][j] // 看s中a多不多，去掉一个是否还能匹配上 <span class="keyword">in</span> this case, a* counts <span class="keyword">as</span> multiple a</span><br><span class="line">		<span class="keyword">or</span> dp[i][j] = dp[i][j-<span class="number">1</span>] // <span class="keyword">in</span> this case, a* counts <span class="keyword">as</span> single a	可以和上一个情况合并</span><br><span class="line">		<span class="keyword">or</span> dp[i][j] = dp[i][j-<span class="number">2</span>] // <span class="keyword">in</span> this case, a* counts <span class="keyword">as</span> empty</span><br></pre></td></tr></table></figure></li>
<li><p>初始化：在 <code>s</code> 和 <code>p</code> 之前都添加一个 <code>' '</code> 字符，这样就可以避免 <code>s='',p='a*'</code> 这种情况</p></li>
</ul></li>
<li><p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        s=<span class="string">&quot; &quot;</span>+s;<span class="comment">//防止该案例：&quot;&quot;\n&quot;c*&quot;</span></span><br><span class="line">        p=<span class="string">&quot; &quot;</span>+p;</span><br><span class="line">        <span class="keyword">int</span> m=s.<span class="built_in">size</span>(),n=p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="literal">false</span>,(m+<span class="number">1</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)&#123; <span class="comment">// j=1时，不可能进入这个判断内部，因此p[j-2]不会越界</span></span><br><span class="line">                    <span class="keyword">if</span>(s[i<span class="number">-1</span>]!=p[j<span class="number">-2</span>] &amp;&amp; p[j<span class="number">-2</span>]!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        dp[i][j]=dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j]=dp[i][j<span class="number">-1</span>] || dp[i][j<span class="number">-2</span>] || dp[i<span class="number">-1</span>][j];</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之排序</title>
    <url>/archives/db4eb545.html</url>
    <content><![CDATA[<p>排序算法中有非常经典的算法思想蕴含其中，本篇主要实现了几种经典的排序算法，希望常常回看，彻底牢记！</p>
<ul>
<li>定义：将数组中的数按照升序或降序进行排列</li>
<li>时间复杂度：
<ul>
<li><span class="math inline">\(O(NlogN)\)</span>：快速排序、归并排序、堆排序等</li>
<li><span class="math inline">\(O(N^2)\)</span>：冒泡排序，插入排序等</li>
</ul></li>
</ul>
<span id="more"></span>
<blockquote>
<p>测试样例：</p>
<p>1 0 30 22 21 21 28 8 6 4 -1</p>
</blockquote>
<h2 id="快速排序">快速排序</h2>
<blockquote>
<p>思路参考：https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html</p>
<p>代码参考：http://runoob.com/w3cnote/quick-sort-2.html</p>
</blockquote>
<ul>
<li><p>解题思路：将问题分解为以下三步</p>
<ol type="1">
<li>找到基准点pivot，用partition()分区函数，使得基准点左侧均小于基准点，右侧均大于等于基准点【从小到大排序】</li>
<li>递归完成pivot左侧的数组排序</li>
<li>递归完成pivot右侧的数组排序</li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; A, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value = A[start];</span><br><span class="line">	<span class="keyword">while</span>(start &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end &amp;&amp; A[end] &gt;= value)</span><br><span class="line">		&#123;</span><br><span class="line">			--end;</span><br><span class="line">		&#125;</span><br><span class="line">		A[start] = A[end];</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end &amp;&amp; A[start] &lt;= value)</span><br><span class="line">		&#123;</span><br><span class="line">			++start;</span><br><span class="line">		&#125;</span><br><span class="line">		A[end] = A[start];</span><br><span class="line">	&#125;</span><br><span class="line">	A[start] = value;</span><br><span class="line">	<span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; A, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> <span class="comment">// notice that it is the &amp; of A</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pivot = <span class="built_in">Partation</span>(A, start, end);</span><br><span class="line">		<span class="built_in">quickSort</span>(A, start, pivot - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">quickSort</span>(A, pivot + <span class="number">1</span>, end);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; a &amp;&amp; a != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		A.<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Ascending Order:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">quickSort</span>(A, <span class="number">0</span>, A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：快排的平均时间复杂度是<span class="math inline">\(O(NlogN)\)</span>，但是最坏时间复杂度是<span class="math inline">\(O(N^2)\)</span>，具体证明后续补充。空间复杂度<span class="math inline">\(O(N)\)</span></p></li>
<li><p>稳定性：不稳定的</p></li>
</ul>
<hr />
<h2 id="归并排序">归并排序</h2>
<blockquote>
<p>思路参考：https://blog.csdn.net/dugudaibo/article/details/79508198</p>
<p>递归法代码参考：https://www.runoob.com/w3cnote/merge-sort.html</p>
<p>迭代法代码参考：https://blog.csdn.net/dugudaibo/article/details/79508198</p>
</blockquote>
<ul>
<li><p><strong>递归</strong>解题思路：将问题分解为以下三步</p>
<ol type="1">
<li>按照中点，将序列分为前后两部分，并递归下去</li>
<li>每部分只有1个元素时（此时不同部分都是按照增序或降序排列的），开始按照规则合并，规则为将两个part进行归并，使得总顺序递增或递减（两个指针）</li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX 0x7fffffff <span class="comment">// notice that there is no &quot;=&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; A, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a1</span><span class="params">(A.begin() + start, A.begin() + mid + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(A.begin() + mid + <span class="number">1</span>, A.begin() + end + <span class="number">1</span>)</span></span>;</span><br><span class="line">    a1.<span class="built_in">insert</span>(a1.<span class="built_in">end</span>(), MAX);</span><br><span class="line">    a2.<span class="built_in">insert</span>(a2.<span class="built_in">end</span>(), MAX);</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; ++i) <span class="comment">// notice that i could &#x27;equal to end&#x27;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a1[index1] &lt; a2[index2])</span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = a1[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = a2[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; A, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> <span class="comment">// notice that it is the &amp; of A</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = start/<span class="number">2</span> + end/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">mergeSort</span>(A, start, mid);</span><br><span class="line">		<span class="built_in">mergeSort</span>(A, mid + <span class="number">1</span>, end);</span><br><span class="line">   		<span class="built_in">Merge</span>(A, start, mid, end);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; a &amp;&amp; a != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		A.<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Ascending Order:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">mergeSort</span>(A, <span class="number">0</span>, A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：快排的平均时间复杂度是<span class="math inline">\(O(NlogN)\)</span>，但是最坏时间复杂度是<span class="math inline">\(O(N^2)\)</span>，具体证明后续补充。空间复杂度<span class="math inline">\(O(N)\)</span></p></li>
<li><p>稳定性：不稳定的</p></li>
</ul>
<hr />
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv在win10上部署</title>
    <url>/archives/8901be7f.html</url>
    <content><![CDATA[<blockquote>
<p>参考：https://blog.csdn.net/print_out/article/details/88558841</p>
<p>安装版本：opencv3.4.0</p>
<p>编译环境：visual studio 2017</p>
</blockquote>
<span id="more"></span>
<ol type="1">
<li><p>在系统环境变量中加入：<code>opencv安装路径\build\x64\vc15\bin</code> 并重启电脑</p></li>
<li>右侧项目名（右击）-属性，选择debug-X64版本
<ol type="1">
<li>通用属性-VC++目录-包含目录：添加
<ul>
<li><code>*\include</code></li>
<li><code>*\include\opencv</code></li>
<li><code>*\include\opencv2</code></li>
</ul></li>
<li>通用属性-VC++目录-库目录：添加
<ul>
<li><code>*\lib</code></li>
<li><code>*\lib\vc15\lib</code></li>
</ul></li>
<li>通用属性-链接器-输入-附加依赖性：添加
<ul>
<li><code>opencv_world*.lib // Release模式库文件</code></li>
<li><code>opencv_world*d.lib // Debug模式库文件</code></li>
</ul></li>
<li>一定要点击应用！！</li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>HOG特征</title>
    <url>/archives/6a4ff405.html</url>
    <content><![CDATA[<ul>
<li>简介：HOG全称<strong>histogram of oriented gradients</strong>，中文是<strong>方向梯度直方图</strong>。它可以用来表示图像的物体特征，主要是轮廓特征，因此能够用于图像的分类等任务。</li>
<li>主要思想：在一副图像中，局部目标的appearance和shape能够被梯度或边缘的方向密度分布很好地描述</li>
<li>本质：梯度的统计信息，而梯度主要存在于边缘的地方</li>
<li>优点：
<ol type="1">
<li>由于HOG是在图像的局部方格单元上操作，所以它对图像几何的和光学的形变都能保持很好的不变性，这两种形变只会出现在更大的空间领域上</li>
<li>在粗的空域抽样、精细的方向抽样以及较强的局部光学归一化等条件下，只要行人大体上能够保持直立的姿势，可以容许行人有一些细微的肢体动作，这些细微的动作可以被忽略而不影响检测效果。因此HOG特征是特别适合于做图像中的人体检测的</li>
</ol></li>
</ul>
<span id="more"></span>
<h2 id="hog的原理">HOG的原理</h2>
<ol type="1">
<li>图像预处理：伽马校正和灰度化，也可不做，对实验影响不大。
<ul>
<li>伽马校正是减少光度对实验的影响</li>
<li>灰度化是将彩色图片变成灰度图。其实彩色图片也可以直接处理，不过是分别对三通道的颜色值进行梯度计算，最后选择梯度最大的那个</li>
<li>为简单起见，假设输入为灰度图，同时大小是**64*128**</li>
</ul></li>
<li>计算每个像素点的梯度大小和梯度方向
<ul>
<li>水平<span class="math inline">\(x\)</span>方向梯度<span class="math inline">\(\frac{\mathrm{d}f}{\mathrm{d} x}=\frac{f(x+1)-f(x-1)}{2}\approx f(x+1)-f(x-1)\)</span></li>
<li>竖直<span class="math inline">\(y\)</span>方向的梯度<span class="math inline">\(\frac{\mathrm{d} f}{\mathrm{d} y}=\frac{f(y+1)-f(y-1)}{2}\approx f(y+1)-f(y-1)\)</span></li>
<li>梯度大小<span class="math inline">\(||f&#39;|| = \sqrt{(\frac{\mathrm{d} f}{\mathrm{d} x})^2+(\frac{\mathrm{d} f}{\mathrm{d} y})^2}\)</span></li>
<li>梯度方向<span class="math inline">\(\theta=tan^{-1}{(\frac{\mathrm{d} f}{\mathrm{d} y}/\frac{\mathrm{d} f}{\mathrm{d} x})}\)</span></li>
</ul></li>
<li>每8*8个pixel为一个cell，根据梯度方向的大小划分为9个bins，并将梯度大小根据梯度方向投递到不同的bin中，计算直方图</li>
<li><span class="math inline">\(2*2\)</span>的cell为一个block，计算对block中<span class="math inline">\(2*2*9\)</span>个数字进行归一化，每个block得到一个大小为<span class="math inline">\(36\)</span>的特征向量</li>
<li>对于<span class="math inline">\(64*128\)</span>大小的输入图像，用stride为1的block逐一计算每个block的特征向量，共得到<span class="math inline">\((8-1)*(16-1)\)</span>个<span class="math inline">\(36\)</span>维的特征向量，将其拉成一个concat成一个<span class="math inline">\(7*15*36=3780\)</span>维的特征向量，即为HOG特征</li>
</ol>
<div class="note primary">
            <p>参考文献：</p><ol type="1"><li>https://zhuanlan.zhihu.com/p/40960756</li><li>https://blog.csdn.net/zouxy09/article/details/7929348?utm_term=hog%E7%89%B9%E5%BE%81%E5%9B%BE&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2<sub>all</sub>sobaiduweb~default-1-7929348&amp;spm=3001.4430</li></ol>
          </div>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>图像边缘信息提取</tag>
      </tags>
  </entry>
  <entry>
    <title>数据预处理</title>
    <url>/archives/e92b12e5.html</url>
    <content><![CDATA[<blockquote>
<p>做为至少学了两遍ML的人，目前在上悉尼大学COMP5318，打算系统总结一下知识点，方便自己记忆更深。</p>
</blockquote>
<p>今天主要讲的内容是数据的预处理，包括去噪、去丢失值、提特征、特征转化、标准化、相似度度量和计算等等</p>
<span id="more"></span>
<h1 id="basic-concepts">Basic Concepts</h1>
<h2 id="nominal-vs.-numeric">Nominal vs. Numeric</h2>
<ul>
<li>Nominal(Categorical) Attributes: 取值是某个类别，类别属于一个特定的数据集，可以有序也可以无序。处理这类数据时，可以根据一定方法转化为Numeric的数据再处理。</li>
<li>Numeric(continuous) Attributes: 取值是一个数值，有的可比（定比）有的不可比（定距），通常也要去量纲后才能在类别之间比较</li>
</ul>
<h2 id="type-of-data">Type of Data</h2>
<ol type="1">
<li>Data matrix</li>
<li>Sequential</li>
<li>graph</li>
<li>transaction data</li>
<li>spatio-temporal</li>
</ol>
<h2 id="noise">Noise</h2>
<ol type="1">
<li>Distortion of values: 例如语音中的噪声</li>
<li>Adding of spurious examples</li>
<li>Inconsistent and duplicate data</li>
</ol>
<blockquote>
<p>最后一类是比较好处理的，前两类噪声可以通过信号、图像处理等方式处理，也可以通过机器学习的算法来消除，后者更准确</p>
</blockquote>
<h2 id="missing-values">Missing values</h2>
<ol type="1">
<li>删除有缺失值的数据项</li>
<li>给缺失值赋值
<ol type="1">
<li>Nominal特征：采用多数投票方式，有以下两种方式
<ul>
<li>在总体中投票</li>
<li>在该类别中投票</li>
</ul></li>
<li>Numerical特征：用k近邻点的均值赋值（最相似样本）</li>
</ol></li>
</ol>
<h1 id="data-preprocessing">Data Preprocessing</h1>
<h2 id="data-aggregation">Data aggregation</h2>
<ol type="1">
<li>定义：将两个或多个特征combine到一起</li>
<li>目的：
<ul>
<li>减少数据维度</li>
<li>减少计算量</li>
<li>降低数据方差，使得数据更平稳</li>
<li>缺点：有损失重要特征的风险</li>
</ul></li>
<li>降维方法Dimensionality reduction：
<ul>
<li>待补充</li>
</ul></li>
</ol>
<h2 id="feature-extraction">Feature extraction</h2>
<ol type="1">
<li>定义：从原始数据中提取特征</li>
<li><h2 id="目的得到更容易理解的数据">目的：得到更容易理解的数据</h2></li>
</ol>
<h2 id="feature-subset-selection">Feature subset selection</h2>
<h2 id="converting-attributes-from-one-type-to-another">Converting attributes from one type to another</h2>
<h2 id="normalization">Normalization</h2>
]]></content>
      <categories>
        <category>计算机</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>挖坑</tag>
        <tag>数据预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：Analysis of Human Back Shape Using Surface Curvatures</title>
    <url>/archives/8918aa0c.html</url>
    <content><![CDATA[<p>给出一种评测标准，使其不受坐标系和病人位置的影响，这种方法叫做surface curvature表面曲率</p>
<span id="more"></span>
<h3 id="introduction">Introduction</h3>
<ul>
<li>Moire topogram不可以很好的刻画脊柱侧弯，因受坐标系和人体朝向的影响</li>
<li>kyphosis 驼背可以通过图像表面特征用数字的方式得到较高的准确判断</li>
<li>因此作者尝试并找到了Surface Curvature表面曲率的方法，该指标不受坐标系和人体位置的影响</li>
</ul>
<h3 id="curvature-shape">Curvature &amp; Shape</h3>
<ul>
<li>几何图形的两种表示形式：
<ul>
<li>将所有点的坐标存储，用以表示</li>
<li>记录位置、朝向、大小、形状等来表示</li>
</ul></li>
<li>Global invariants：距离、面积、体积、角度</li>
<li>Local invariants：只依赖于周围点的环境，表面曲率是一个局部不变量</li>
<li>等高线图可以较好的描述平面曲率，不同角度的照片生成的等高线图不一致，无法直接比大小</li>
<li>但同样的物体曲率是相同的</li>
</ul>
<h3 id="calculation-of-surface-curvature-from-photogrammetric-measurements">Calculation of Surface Curvature from Photogrammetric Measurements</h3>
<ul>
<li>用偏差来表示局部曲率，二维图像需要用两个独立方向的向量才可以描述局部形状，通常用两个正交的方向，每个方向对应一个<span class="math inline">\(k\)</span>值</li>
<li>曲率<span class="math inline">\(k\)</span>：<span class="math inline">\(k=1/R\)</span>对应曲率圆半径的导数，曲率<span class="math inline">\(k=lim_{n-&gt;inf}弧长/圆心角\)</span>https://www.zhihu.com/question/30236122</li>
<li>高斯曲率：<span class="math inline">\(K=k_1*k_2\)</span>，用高斯曲率的符号可以区分椭圆面(&gt;0)和马鞍面(&lt;0)</li>
<li>主曲率：<span class="math inline">\(H=(k_1+k_2)/2\)</span>，其正负可以表示抛物面和椭圆面的凹凸关系(&gt;0凸，&lt;0凹)，但马鞍面会捣乱</li>
</ul>
<blockquote>
<p>感谢Dr. Body的Jackal Xu，非常感谢他耐心的指引方向和讲解，虽然最终没能去实地实习，但非常感谢他对我的信任和指导，这种事情要记一辈子的！也希望你的事业有成，我很看好你的产品，加油！</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>脊柱侧弯检测</tag>
        <tag>表面曲率</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之递归</title>
    <url>/archives/b96f43ef.html</url>
    <content><![CDATA[<p>递归是计算机算法中一类较为经典的问题。本文首先总结递归的思想，然后上例题和代码</p>
<ul>
<li><p>定义：从程序设计的角度来看，递归就是让程序自己调用自己的一种编程技巧</p></li>
<li><p>作用：递归通常可以将大型复杂问题转化为一个与原始问题相似的较小规模的问题来求解</p></li>
<li><p><strong>应用场景：</strong>①子问题和原问题要执行的操作一样，且子问题规模更小；②不能无限制调用自身，需要有出口</p></li>
<li><p><strong>思想：</strong>将待求解问题的解看作输入变量<span class="math inline">\(x\)</span>的函数<span class="math inline">\(f(x)\)</span>，通过寻找递归函数<span class="math inline">\(g\)</span>，使得<span class="math inline">\(f(x)=g(f(x-1))\)</span>，同时<span class="math inline">\(f(0)\)</span>已知，根据递归函数和递归终止条件，就可递归求解了</p></li>
<li><p><strong>推广：</strong>可以推广至多变量，也可以推广至<span class="math inline">\(x-2\)</span>等，只要递归朝着出口方向前进即可</p></li>
</ul>
<span id="more"></span>
<h2 id="汉诺塔问题">汉诺塔问题</h2>
<blockquote>
<p>白皮算法书4.3:</p>
</blockquote>
<ul>
<li><p>解题思路：将问题分解为以下三步</p>
<ol type="1">
<li>将A下面的n个盘子，以C为中转，移动到B</li>
<li>将A最下面的一个盘子移动到C</li>
<li>将B下面的n-1个盘子，以A为中转，移动到C</li>
</ol>
<p>上面的1和3步同原问题形式相同，规模减一，满足应用场景①，递归终止条件为，当n=1时，直接把A的盘子移动到C即可，因此满足递归的应用场景。</p></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Hanoi函数作用：将src上的n个盘子，以mid为中转，移动到dest上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> src, <span class="keyword">char</span> mid, <span class="keyword">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="comment">// 递归终止条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;src&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;dest&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将src上的n-1个盘子，经dest，移动到mid上</span></span><br><span class="line">    <span class="built_in">Hanoi</span>(n<span class="number">-1</span>, src, dest, mid);</span><br><span class="line">    <span class="comment">// 将src上的第n个盘子，直接放到dest上</span></span><br><span class="line">    cout&lt;&lt;src&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;dest&lt;&lt;endl; <span class="comment">// Hanoi(1, src, mid, dest);</span></span><br><span class="line">    <span class="comment">// 将mmid上的n-1个盘子，经src，移动到dest上</span></span><br><span class="line">    <span class="built_in">Hanoi</span>(n<span class="number">-1</span>, mid, src, dest);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;汉诺塔问题求解，请输入一个正整数n，代表初始盘子的数量：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;n; <span class="comment">// 输入盘子的数量n</span></span><br><span class="line">    <span class="built_in">Hanoi</span>(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：</p>
<p>递归算法的复杂度通常用递推公式推导。假设问题规模为<span class="math inline">\(n\)</span>，<span class="math inline">\(T(n)\)</span>为所需的步骤，那么<span class="math inline">\(T(n)=1+2*T(n-1)=2^n-1+2^{n-1}T(1)=O(2^n)\)</span></p></li>
</ul>
<h2 id="小游戏">小游戏</h2>
<blockquote>
<p>白皮算法书4.3:</p>
</blockquote>
<ul>
<li><p>解题思路：迷宫求解问题，自相似性表现在每走一步的探测方式相同，因此可用递归求解。</p>
<ul>
<li>通过穷举的方式找到起点到终点的路径，朝一个方向走下去，如果走不通，则换一个方向走；四个方向都走不通，则回退到上一步，再换个方向走；依次走下去，直到终点</li>
<li>记录上一步走的方向，如果和下一步相同，则路径数不变，如果不同，则加一</li>
<li>用一个二维数组记录每个节点是否被走过</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span> <span class="comment">// memset(数组名，值，sizeof(数组名))</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 75</span></span><br><span class="line"><span class="keyword">char</span> board[MAX_SIZE+<span class="number">2</span>][MAX_SIZE+<span class="number">2</span>]; <span class="comment">// 定义地图</span></span><br><span class="line"><span class="keyword">bool</span> mark[MAX_SIZE+<span class="number">2</span>][MAX_SIZE+<span class="number">2</span>]; <span class="comment">// 记录是否走过</span></span><br><span class="line"><span class="keyword">int</span> minSeg=<span class="number">100000</span>, boardNum=<span class="number">0</span>, w=<span class="number">0</span>, h=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> to[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">// 定义方向：东南西北</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">XXXXX</span></span><br><span class="line"><span class="comment">X   X</span></span><br><span class="line"><span class="comment">XXX X</span></span><br><span class="line"><span class="comment"> XXX </span></span><br><span class="line"><span class="comment">2 3 5 3</span></span><br><span class="line"><span class="comment">1 3 4 4</span></span><br><span class="line"><span class="comment">2 3 3 4</span></span><br><span class="line"><span class="comment">0 0 0 0</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数DFS：输入为当前位置，结束位置，最短线段数seg和上一步的前进方向dir</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> currentX, <span class="keyword">int</span> currentY, <span class="keyword">int</span> endX, <span class="keyword">int</span> endY, <span class="keyword">int</span> seg, <span class="keyword">int</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg&gt;=minSeg) <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(currentX == endX &amp;&amp; currentY == endY) <span class="comment">// 递归边界条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(seg&lt;minSeg)</span><br><span class="line">            minSeg = seg;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = currentX+to[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> y = currentY+to[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 这里的if条件只需要判断是否可以走，而不用管不可以走的</span></span><br><span class="line">        <span class="keyword">if</span>((x&gt;=<span class="number">0</span> &amp;&amp; x&lt;=w+<span class="number">1</span> &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;=h+<span class="number">1</span>) </span><br><span class="line">           &amp;&amp; ((board[y][x]==<span class="literal">false</span> &amp;&amp; mark[y][x]==<span class="string">&#x27; &#x27;</span>)||(board[y][x]==<span class="string">&#x27;X&#x27;</span> &amp;&amp; x==endX &amp;&amp; y==endY)))</span><br><span class="line">        &#123;</span><br><span class="line">            mark[y][x]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==dir) <span class="comment">// 方向与上一步相同</span></span><br><span class="line">                <span class="built_in">DFS</span>(x,y,endX,endY,seg,i);</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 方向与上一步不同</span></span><br><span class="line">                <span class="built_in">DFS</span>(x,y,endX,endY,seg+<span class="number">1</span>, i);</span><br><span class="line">            mark[y][x]=<span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;w&gt;&gt;h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">0</span>&amp;&amp;h==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        boardNum+=<span class="number">1</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Board #&quot;</span>&lt;&lt;boardNum&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX_SIZE+<span class="number">2</span>; ++i)</span><br><span class="line">            board[<span class="number">0</span>][i]=board[i][<span class="number">0</span>]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=h; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">getchar</span>(); <span class="comment">// 读入上一行回车</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=w; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                board[i][j]=<span class="built_in">getchar</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=h+<span class="number">1</span>; ++i)</span><br><span class="line">            board[w+<span class="number">1</span>][i]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=w+<span class="number">1</span>; ++j)</span><br><span class="line">            board[h+<span class="number">1</span>][j]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> startX, startY, endX, endY, count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((cin &gt;&gt; startX &gt;&gt; startY &gt;&gt; endX &gt;&gt; endY) &amp;&amp; startX&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            minSeg = <span class="number">1000000</span>;</span><br><span class="line">            <span class="built_in">memset</span>(mark, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mark));</span><br><span class="line">            <span class="built_in">DFS</span>(startX, startY, endX, endY, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(minSeg&lt;<span class="number">1000000</span>)</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Pair &quot;</span>&lt;&lt;count&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;minSeg&lt;&lt;<span class="string">&quot; Segments.&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Pair &quot;</span>&lt;&lt;count&lt;&lt;<span class="string">&quot;:impossible.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现技巧：</p>
<ol type="1">
<li><p>可以使用一个二维数组来表示四个搜索方向，以东南西北四个搜索方向为例，可以定义为：</p>
<p><code>int to[4][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</code></p></li>
<li><p>判断下一步是否符合要求时，if条件为下一步可以走的地方，该地方满足两个条件，首先是在界内，其次没走过且为空格，或是终点</p></li>
<li><p>注意将mark的标记和回溯问题，一般回溯都紧跟在递归方程后</p></li>
</ol></li>
<li><p>复杂度分析：暂不分析</p></li>
</ul>
<h2 id="棋盘分割">棋盘分割</h2>
<blockquote>
<p>白皮算法书4.4:</p>
</blockquote>
<ul>
<li><p>解题思路：自相似性表现在对于未分割棋盘也是同样的问题，只是规模减小了，因此利用递归计算</p>
<ul>
<li><span class="math inline">\(\sigma=\sqrt{\frac{\Sigma_{i=1}^{n}(x_i-\bar{x})^2}{n}}=\frac{\Sigma{x_i^2}}{n}-\bar{x}^2\)</span>，因此只需要计算最小的<span class="math inline">\(\Sigma{x_i^2}\)</span>即可，其中<span class="math inline">\(x_i\)</span>为第i块矩形棋盘的和</li>
<li>设目标函数为<span class="math inline">\(Fun(n,x_1,y_1,x_2,y_2)\)</span>为左上角为<span class="math inline">\((x_1,y_1)\)</span>，右下角为<span class="math inline">\((x_2,y_2)\)</span>的棋盘，分割<span class="math inline">\(n\)</span>次后，该种分割所有棋盘内分数和的平方，求和最小</li>
<li>递归方程为min{四个方向切<strong>（其实只有两个方向）</strong>哪个方向的平方最小{min{固定方向，切在哪里后两侧平方和最小}}</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span> <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span> <span class="comment">// cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(3)&lt;&lt;result&lt;&lt;endl;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span> res[<span class="number">15</span>][<span class="number">9</span>][<span class="number">9</span>][<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">9</span>][<span class="number">9</span>]; <span class="comment">// 记录(1,1)(i,j)围成矩形的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 3</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 0</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 0 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：1.633</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalSum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[x2][y2]-sum[x1<span class="number">-1</span>][y2]-sum[x2][y1<span class="number">-1</span>]+sum[x1<span class="number">-1</span>][y1<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fun</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res[n][x1][y1][x2][y2]!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> res[n][x1][y1][x2][y2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res[n][x1][y1][x2][y2]=<span class="built_in">pow</span>(<span class="built_in">CalSum</span>(x1,y1,x2,y2),<span class="number">2</span>); </span><br><span class="line">        <span class="keyword">return</span> res[n][x1][y1][x2][y2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> MIN = <span class="number">0xffffff</span>;</span><br><span class="line">    <span class="comment">// 沿x方向切</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x1; i&lt;x2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="built_in">CalSum</span>(x1,y1,i,y2);</span><br><span class="line">        <span class="keyword">int</span> down = <span class="built_in">CalSum</span>(i+<span class="number">1</span>,y1,x2,y2);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">min</span>(<span class="built_in">Fun</span>(n<span class="number">-1</span>,x1,y1,i,y2)+down*down, <span class="built_in">Fun</span>(n<span class="number">-1</span>,i+<span class="number">1</span>,y1,x2,y2)+up*up); <span class="comment">// 用上半部分继续切还是下半部分继续切</span></span><br><span class="line">        MIN = <span class="built_in">min</span>(MIN, temp); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 沿y方向切</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=y1; j&lt;y2; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">CalSum</span>(x1,y1,x2,j);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">CalSum</span>(x1,j+<span class="number">1</span>,x2,y2);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">min</span>(<span class="built_in">Fun</span>(n<span class="number">-1</span>,x1,y1,x2,j)+right*right,<span class="built_in">Fun</span>(n<span class="number">-1</span>,x1,j+<span class="number">1</span>,x2,y2)+left*left); <span class="comment">// 用左边还是右边继续切</span></span><br><span class="line">        MIN = <span class="built_in">min</span>(MIN, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    res[n][x1][y1][x2][y2]=MIN;</span><br><span class="line">    <span class="keyword">return</span> res[n][x1][y1][x2][y2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(res,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line">    <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sum));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>, rowSum=<span class="number">0</span>; j&lt;<span class="number">9</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">            rowSum += s[i][j];</span><br><span class="line">            sum[i][j] = sum[i<span class="number">-1</span>][j] + rowSum; <span class="comment">// 以积分形式计算子块和</span></span><br><span class="line"><span class="comment">//            cout&lt;&lt;sum[i][j]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">double</span> result = <span class="built_in">sqrt</span>((n*<span class="built_in">Fun</span>(n,<span class="number">1</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>) - <span class="built_in">pow</span>(sum[<span class="number">8</span>][<span class="number">8</span>],<span class="number">2</span>))/(n*n));</span><br><span class="line">	<span class="comment">// double result = sqrt(Fun(n,1,1,8,8)/n - pow(sum[8][8],2)/pow(n,2)); 注意这里虽然数学上一样，但是程序计算时和上方公式有一定的误差</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::fixed)&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>实现技巧：</p>
<ol type="1">
<li>如果每一个<span class="math inline">\(Fun(n,x_1,y_1,x_2,y_2)\)</span>都要重新计算，那么计算量一定会超时的，因此设立数组<code>res[n][x1][y1][x2][y2]</code>用来存储中间已经计算过的，防止重复计算</li>
<li>用<code>sum[i][j]</code>数组来存储<span class="math inline">\((1,1)\)</span>和<span class="math inline">\((i,j)\)</span>所构成矩形的分数之和，并在输入矩阵是用当前行积分的形式，计算<code>sum[i][j]</code></li>
<li>注意如果最终结果只差一点点时，考虑是否是因为计算机数值计算时导致的误差造成的</li>
<li>如何记录下切割方案？</li>
</ol></li>
<li><p>复杂度分析：</p>
<ul>
<li>因为需要遍历不同的切割方式，因此需要尝试7<em>7</em>6<em>6</em>5*5...次（乘法次数为n-1），每次切割的计算为O(1)</li>
</ul></li>
</ul>
<h2 id="八皇后问题">八皇后问题</h2>
<blockquote>
<p>白皮算法书4.5: http://bailian.openjudge.cn/practice/2754</p>
</blockquote>
<ul>
<li><p>解题思路：自相似性表现在，对于前i行已经码好的情况下，只用遵循限制条件，将第i+1层码好即可（带回溯）</p>
<ul>
<li>考虑将92个解全部解出并存储，避免后续重复计算</li>
<li>从第一个皇后的位置开始一个个的测试当前码放是否可行，不行的话进行回溯</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res[<span class="number">92</span>][<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> row[<span class="number">8</span>]; <span class="comment">// 第i行存放在了第row[i]列 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">92</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">15863724</span></span><br><span class="line"><span class="comment">84136275</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queen</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">8</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			res[cnt][i] = row[i];</span><br><span class="line">		&#125;</span><br><span class="line">		cnt++;</span><br><span class="line">	 	<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">8</span>; ++i) <span class="comment">// 将当前皇后逐一尝试放在不同的列，每列对应一组解 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; ++j) <span class="comment">// 判断当前放置位置(n,i)是否和上方码好的皇后冲突(因此回溯时不用将下方的row值改回来) </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 如果（n行，i列） 这个点的同列中有queen，即遍历row[j]，如果row[j]==i，则break </span></span><br><span class="line">			<span class="comment">// 或者（8-1行，i列） 这个位置的对角线上有queen也要break，即当前码放点和之前码放点横纵坐标分别求差的绝对值相等 </span></span><br><span class="line">			<span class="keyword">if</span>(row[j]==i || <span class="built_in">abs</span>(n-j)==<span class="built_in">abs</span>(i-row[j]))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	 	<span class="keyword">if</span>(j == n) <span class="comment">// 如果当前方置位置(n,i)和上方皇后都不冲突 </span></span><br><span class="line">	 	&#123;</span><br><span class="line">	 		row[n] = i; <span class="comment">// 记录当前位置 </span></span><br><span class="line">	 		<span class="built_in">queen</span>(n+<span class="number">1</span>); <span class="comment">// 递归寻找下一层 </span></span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(row, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(row));</span><br><span class="line">	<span class="built_in">memset</span>(res, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line">	<span class="built_in">queen</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;res[num<span class="number">-1</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现技巧：</p>
<ul>
<li>将92种方案一次性算出来，而不是每次输入一个序号，就要从新训练一次</li>
<li>这里需要回溯，但是不用修改数组内容</li>
<li>是否在同一个斜线上的判断用的是<code>abs(x1-x2)==abs(y1-y2)</code></li>
</ul></li>
<li><p>复杂度分析：每一行都要试8个位置，每次尝试是<span class="math inline">\(O(1)\)</span>的，一共有8行，因此复杂度是<span class="math inline">\(O(8^8)\)</span>。</p></li>
</ul>
<h2 id="文件结构图">文件结构图</h2>
<blockquote>
<p>白皮算法书4.6: http://bailian.openjudge.cn/practice/2775/</p>
</blockquote>
<ul>
<li><p>解题思路：文件的结构就是递归的结构，每个目录都是一个小的文件结构。</p>
<ul>
<li>当出现新的目录时就是递归的开始</li>
<li>当出现']'时就是当前递归的截至</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span> <span class="comment">// sort(vector.begin(), vector.end());</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fileStructure</span><span class="params">(<span class="keyword">int</span> level, string dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;string&gt; file; <span class="comment">// 用于存储当前目录下的文件 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出当前文件目录(根目录需要特殊处理) </span></span><br><span class="line">	<span class="keyword">if</span>(level != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;level; ++i) cout &lt;&lt; <span class="string">&quot;|     &quot;</span>;</span><br><span class="line">		cout &lt;&lt; dir &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">bool</span> rFlag = <span class="literal">false</span>; </span><br><span class="line">	<span class="comment">// 持续输入该文件夹下文件或文件夹 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		<span class="keyword">if</span>(s == <span class="string">&quot;#&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(!rFlag &amp;&amp; level==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;DATA SET &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; dir &lt;&lt; endl; </span><br><span class="line">			rFlag = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(s == <span class="string">&quot;*&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(s == <span class="string">&quot;]&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>) file.<span class="built_in">push_back</span>(s); <span class="comment">// 如果是文件则存入vector中 </span></span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>) <span class="built_in">fileStructure</span>(level+<span class="number">1</span>, s);  <span class="comment">// 如果是文件夹则递归 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 排序当前目录下文件，并输出</span></span><br><span class="line">	<span class="built_in">sort</span>(file.<span class="built_in">begin</span>(), file.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;file.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;level; ++j) cout &lt;&lt; <span class="string">&quot;|     &quot;</span>;</span><br><span class="line">		cout &lt;&lt; file[i] &lt;&lt; endl;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n++;</span><br><span class="line">		flag = <span class="built_in">fileStructure</span>(<span class="number">0</span>, <span class="string">&quot;ROOT&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>实现技巧：</p>
<ul>
<li>每一层递归都新建一个vector用于存储file文件，防止错乱，在当前层结束调用前输出排序输出file</li>
<li>注意<code>string</code>类型的变量需要用<code>&quot;&quot;</code>来定义或赋值</li>
<li>注意根节点输出是特殊情况，需要特殊处理，不能放到主函数中</li>
</ul></li>
<li><p>复杂度分析：这种题目好像无法计算复杂度。</p></li>
</ul>
<h2 id="算24">算24</h2>
<blockquote>
<p>白皮算法书4.7:</p>
</blockquote>
<ul>
<li><p>解题思路：可以随机找到2个数，利用加减乘除进行运算后变为一个数，此时n个数变为了n-1个数，按照此方法规模不断减一，当只有一个数时，判断其是否为24，如果是则输出。</p></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculate24</span><span class="params">(<span class="keyword">float</span>* a, <span class="keyword">int</span> n)</span> <span class="comment">// 注意这里传入的参数应该是float类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> b[<span class="number">3</span>]; <span class="comment">// 对于每两个数的运算都应该从新存入新的数组进行运算</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a[<span class="number">0</span>]<span class="number">-24</span>)&lt;<span class="number">0.0001</span>) ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) <span class="comment">// 对于a中的每一个数，寻找与之配对的另一个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> m = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==i||k==j) <span class="keyword">continue</span>;</span><br><span class="line">                b[m] = a[k];</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            b[m] = a[i]+a[j];</span><br><span class="line">            <span class="built_in">Calculate24</span>(b, m+<span class="number">1</span>);</span><br><span class="line">            b[m] = a[i]-a[j];</span><br><span class="line">            <span class="built_in">Calculate24</span>(b, m+<span class="number">1</span>);</span><br><span class="line">            b[m] = a[i]*a[j];</span><br><span class="line">            <span class="built_in">Calculate24</span>(b, m+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a[j] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b[m] = a[i]/a[j];</span><br><span class="line">                <span class="built_in">Calculate24</span>(b, m+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a[<span class="number">0</span>] &gt;&gt; a[<span class="number">1</span>] &gt;&gt; a[<span class="number">2</span>] &gt;&gt; a[<span class="number">3</span>] &amp;&amp; a[<span class="number">0</span>]+a[<span class="number">1</span>]+a[<span class="number">2</span>]+a[<span class="number">3</span>]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Calculate24</span>(a, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现技巧：</p>
<ul>
<li><p>判断是否等于24：因为涉及除法，因此会产生浮点数，此时应判断<code>if(abs(a-24)&lt;0.0001)</code>来判断是否等于24</p></li>
<li><p>括号运算符：因为每个数字的组合都会出现，且两数之间的每个运算符都会出现，因此隐含的表述了括号的存在</p></li>
<li><p>全局变量<code>ans</code>：该变量用于判定是否可以计算出24，每组样例输入后需要清零。同时递归函数就不用返回值了。数组<code>b[3]</code>也非常巧妙，保证了递归的形式，如果做为全局变量的话肯定不行，数据会脏。</p></li>
<li><p>减少重复计算次数：将递归中第二层循环从<code>for(int j=0; j&lt;n; ++j)</code>变为<code>for(int j=i; j&lt;n; ++j)</code>，此时减少了重复计算的次数，但是有一定的错误，因为四则运算中加法和乘法可以交换位置，但是减法和除法不行，因此需要在内层循环中加入减法和除法的反向操作，改进后递归函数如下，时间从686ms减少到了263ms</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculate24</span><span class="params">(<span class="keyword">float</span>* a, <span class="keyword">int</span> n)</span> <span class="comment">// 注意这里传入的参数应该是float类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> b[<span class="number">3</span>]; <span class="comment">// 对于每两个数的运算都应该从新存入新的数组进行运算</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a[<span class="number">0</span>]<span class="number">-24</span>)&lt;<span class="number">0.0001</span>) ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) <span class="comment">// 对于a中的每一个数，寻找与之配对的另一个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> m = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==i||k==j) <span class="keyword">continue</span>;</span><br><span class="line">                b[m] = a[k];</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            b[m] = a[i]+a[j];</span><br><span class="line">            <span class="built_in">Calculate24</span>(b, m+<span class="number">1</span>);</span><br><span class="line">            b[m] = a[i]-a[j];</span><br><span class="line">            <span class="built_in">Calculate24</span>(b, m+<span class="number">1</span>); <span class="comment">// 加入反向减法</span></span><br><span class="line">            b[m] = a[j]-a[i];</span><br><span class="line">            <span class="built_in">Calculate24</span>(b, m+<span class="number">1</span>);</span><br><span class="line">            b[m] = a[i]*a[j];</span><br><span class="line">            <span class="built_in">Calculate24</span>(b, m+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a[j] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b[m] = a[i]/a[j];</span><br><span class="line">                <span class="built_in">Calculate24</span>(b, m+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != <span class="number">0</span>) <span class="comment">// 加入反向除法</span></span><br><span class="line">            &#123;</span><br><span class="line">                b[m] = a[j]/a[i];</span><br><span class="line">                <span class="built_in">Calculate24</span>(b, m+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>复杂度分析：<span class="math inline">\(O(n!*(n-1)!)\)</span>，对于4个数字的情况，第一次递归要选择两个数，也就是<span class="math inline">\(C_4^2\)</span>次，第二层递归要计算<span class="math inline">\(C_3^2\)</span>次，以此类推</p></li>
</ul>
<h2 id="汉诺塔用栈代替递归">汉诺塔用栈代替递归</h2>
<blockquote>
<p>白皮算法书4.8:</p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>手动维持一个栈，对于当前问题，同样拆解为3步，压入栈中，然后从栈顶开始取元素，以此类推来完成</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>实现技巧：</p>
<ul>
<li>用结构体定义当前状态，用结构体类型的数组完成栈中每个元组的存储。栈的大小不超过n的3倍</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测算法脉络梳理</title>
    <url>/archives/78535d66.html</url>
    <content><![CDATA[<blockquote>
<p>目标检测（Object Detection）是计算机视觉中一个重要分支，其<strong>定义</strong>就是<strong>在给定的图片中精确找到物体所在位置，并标注出物体的类别。</strong>其主流方法包括<strong>R-CNN、Fast R-CNN、Faster R-CNN、YOLO、SSD</strong>等。主要<strong>难点</strong>在于<strong>物体尺寸变化大、物体摆放角度不同、出现位置随机、多物体、多类别</strong>等等。</p>
<p>参考文献：https://www.julyedu.com/question/big/kp_id/32/ques_id/2103</p>
</blockquote>
<span id="more"></span>
<h2 id="目标检测常见算法">目标检测常见算法</h2>
<ol type="1">
<li>传统目标检测算法：
<ul>
<li>算法流程：基于滑动窗口的区域选择策略 + HOG/SIFT（提取特征） + SVM/Adaboost（分类器分类）</li>
<li>主要问题：
<ul>
<li>滑动窗口的策略没有针对性，时间复杂度高，窗口冗余</li>
<li>手工设计特征鲁棒性不高</li>
</ul></li>
</ul></li>
<li>候选框+深度学习分类：
<ul>
<li>算法流程：提取候选区域，并用相应区域以深度学习的方法进行分类，如：
<ul>
<li>R-CNN: Selective Search + CNN + SVM</li>
<li>SPP-net: ROI Pooling</li>
<li>Fast R-CNN: Selective Search + CNN + ROI</li>
<li>Faster R-CNN: RPN +CNN + ROI</li>
<li>R-FCN</li>
</ul></li>
</ul></li>
<li>基于深度学习的回归方法：YOLO/SSD/DenseBox等；以及结合RNN的RRC detection；结合DPM的Deformable CNN等</li>
</ol>
<h2 id="如何解决定位的问题">如何解决定位的问题？</h2>
<blockquote>
<p>因为初期是单目标检测，因此就是分类和定位这两个问题。而图像分类问题已经有很好的网络来提取图像特征了，那么此时如何做定位就是一个问题。</p>
</blockquote>
<ol type="1">
<li><p>思路一：看做回归问题，预测(x,y,w,h)这四个参数</p>
<ol type="1">
<li>先搭建一个图像分类的网络，在这个基础上fine-tuning一下</li>
<li>CNN提取特征部分不变，将网络尾部展开，加上Classification head和Regression head <img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/分类和回归头.png" width="80%" height="80%" align="center"></li>
<li>其中Regression部分利用欧氏距离损失，并使用SGD训练</li>
<li>预测阶段将2个头拼上，完成不同的部分</li>
</ol>
<blockquote>
<p>上述步骤<strong>需要两次fine-tuning</strong>，第一次在AlexNet上；第二次在将头改为regression head后，前面保持不变，做一次fine-tuning。</p>
<p><font color=red>Regression的收敛速度太慢，尝试用Classification代替回归，因此只是fine-tuningregression head，且前面参数值保持不变</font></p>
</blockquote></li>
<li>思路二：先取框，对每个框都利用分类头和回归头，这里分类头输出的是一个score，代表了当前框的分数，<font color=red>而回归头同样也是回归(x,y,w,h)这四个参数，但我没搞懂为什么回归？</font>
<ul>
<li>问题：框要取多大？怎么移动？</li>
<li>取不同大小的框，步长为1的从左上移动到右下。此时时间复杂度高，窗口冗余严重</li>
</ul></li>
</ol>
<blockquote>
<p>以上均是单个目标的检测，而对于多目标的检测而言，需要优化上述滑动窗口的方法</p>
</blockquote>
<h2 id="候选窗深度学习分类">候选窗+深度学习分类</h2>
<h3 id="r-cnnregion-based-convolution-networks">R-CNN：Region-based Convolution Networks</h3>
<ol type="1">
<li>算法步骤</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/R-CNN示意图1.jpg" width="80%" height="80%" align="center"></p>
<h2 id="补充">补充</h2>
<h3 id="什么是iou">什么是IoU？</h3>
<blockquote>
<p>全称为Intersection-over-Union，即交并比，即检测框与GT框之间的交集面积除以并集的面积，用于评估检测框与GT之间的差距。</p>
<p>在目标检测中，模型通常会生成大量（~2000）的候选框，根据每个框的置信度排序，以此计算框与框之间的IoU，并用非极大值抑制NMS删除多余的检测框</p>
<p>**为什么以此计算框与框之间的IoU？NMS具体是什么？</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>CV面试之常识题</title>
    <url>/archives/555d6097.html</url>
    <content><![CDATA[<blockquote>
<p>最近本科毕业，想回顾一下本科的学习内容，同时为实习&amp;找工作的面试做准备，刚好找到了一个网站，有一些“常识题”，自己需要积累并且背下来，加油！</p>
<p>参考：https://www.julyedu.com/question/topic_list/32</p>
<p>​ https://m.julyedu.com/problems/920</p>
</blockquote>
<span id="more"></span>
<h3 id="什么是归一化它和标准化的区别是什么">什么是归一化，它和标准化的区别是什么？</h3>
<ol type="1">
<li>定义
<ul>
<li>归一化：将数值规约到(0,1)或者(-1,1)
<ul>
<li>max-min归一化</li>
<li>小数定标归一化</li>
<li>softmax对数归一化：</li>
<li>L2归一化</li>
</ul></li>
<li>标准化：将对应数据的分布规约到以均值为0，标准差为1的（近高斯）分布上
<ul>
<li>Z-score：减均值除标准差</li>
</ul></li>
</ul></li>
<li>如何选择用哪种？
<ul>
<li>在不用计算距离（例如决策树算法）、计算协方差、不符合正态分布或必须严格控制在[0,1]之间（入RGB图像存储）时，用归一化；有异常点时不适合用归一化</li>
<li>更符合统计假设的，比如数据服从正态分布，用标准化；
<ul>
<li>用到距离：聚类（Kmeans）、用到正则化的线性模型、KNN</li>
<li>PCA降维</li>
</ul></li>
</ul></li>
<li>注意事项：
<ul>
<li>训练集和测试集分别做标准化</li>
<li>两者都可以去除量纲，只有量纲去除后，不同属性间才可以比大小（用来筛出重要或不重要指标）</li>
<li>标准化后，梯度下降算法是在圆形而非椭圆形上寻找，因此收敛速度更快</li>
</ul></li>
</ol>
<blockquote>
<p>https://www.zhongxiaoping.cn/2019/01/15/%E6%A0%87%E5%87%86%E5%8C%96%E4%B8%8E%E6%AD%A3%E5%88%99%E5%8C%96/（）</p>
<p>https://blog.csdn.net/u012768474/article/details/99871942</p>
</blockquote>
<h3 id="如何确定cnn的卷积核通道数和卷积输出层的通道数">如何确定CNN的卷积核通道数和卷积输出层的通道数？</h3>
<ul>
<li><p>CNN的卷积核通道数就是输入张量的通道数</p></li>
<li><p>卷积输出层的通道数是卷积核的数量</p></li>
</ul>
<h3 id="什么是卷积">什么是卷积？</h3>
<ul>
<li>卷积定义：将三维矩阵（长*宽*通道）和一个固定数值的滤波矩阵做内积（逐个元素相乘再相加）</li>
</ul>
<h3 id="什么是池化层池化层如何反向传播">什么是池化层？池化层如何反向传播？</h3>
<ul>
<li>池化：对区域取平均值或最大值，分别叫做平均池化和最大池化</li>
<li>池化作用：减小feature map的尺寸，同时不加入参数量</li>
<li>池化层的反向传播：因为池化层没有参数，因此只是将误差传递到上一层
<ul>
<li>AvgPooling：反向传播时，把一个patch的值分成四块回传，其中每块是patch的平均</li>
<li>MaxPooling：需要在前向传播时几下max id，从而在反向传播时，将一个patch的值赋值给max id，其他三块为0</li>
</ul></li>
</ul>
<h3 id="简述什么是生成对抗网络">简述什么是生成对抗网络？</h3>
<ul>
<li>简介：生成对抗网络GAN（Generative Adversarial Network）。假设有两个模型，一个是生成模型(Generative Model，下文简写为G)，一个是判别模型(Discriminative Model，下文简写为D)，判别模型(D)的任务就是判断一个实例是真实的还是由模型生成的，生成模型(G)的任务是生成一个实例来骗过判别模型(D) ，两个模型互相对抗，发展下去就会达到一个平衡，生成模型生成的实例与真实的没有区别，判别模型无法区分自然的还是模型生成的。</li>
</ul>
<h3 id="roi-pooling-和roi-align区别">ROI Pooling 和ROI Align区别</h3>
<blockquote>
<p>目标检测相关，前者为Faster RCNN提出，后者为其改进，再Mask RCNN中提出</p>
</blockquote>
<ol type="1">
<li><p>ROI Pooling</p></li>
<li><p>ROI Align</p></li>
</ol>
<h3 id="iou评价指标">IOU评价指标</h3>
<p>常用于目标检测，是一个评价指标，具体是指检测结果和GT之间的交集和并集的比值，即为准确率IoU。而通常会用1-IoU做为loss训练。其优点在于据有尺度不变性，非负且对称；缺点在于当交集为0时，无法比较两者远近；当存在交集时，无法知道两者如何相交。</p>
<h3 id="knn和k-means的区别">KNN和K-means的区别</h3>
<ul>
<li>KNN是有监督学习的分类算法，没有前期训练过程，预测时直接统计离该点最近的K个点的类别，多数投票即可。</li>
<li>K-means是聚类算法，属于非监督学习，有明显的训练过程，不断迭代中心点和类别标记，最终达到平衡。其中K是指有K个聚类中心。</li>
</ul>
<h3 id="k-means选择初始点的方法有哪些优缺点是什么">K-means选择初始点的方法有哪些,优缺点是什么?</h3>
<ol type="1">
<li>从样本中随机选取K个点进行初始化</li>
<li>多次随机选取中心点并训练，选择使损失函数最小的那一组做为最优</li>
<li>选择尽量远的K个样本做为中心点</li>
<li>对于文本这种高维稀疏向量，可以选择K个两两正交的做为初始化中心点</li>
</ol>
<h4 id="简述线性分类器的原理">简述线性分类器的原理</h4>
<ul>
<li><p><span class="math inline">\(f(x_i,W,b)=Wx_i+b\)</span>，这是线性分类器的方程，其中参数<span class="math inline">\(W\)</span>是权重矩阵，参数<span class="math inline">\(b\)</span>是偏置向量，在图像分类任务中，<span class="math inline">\(x_i\)</span>的维度是<span class="math inline">\((w*h*c,1)\)</span>，而<span class="math inline">\(W\)</span>的维度是<span class="math inline">\((classNum,w*h*c)\)</span>，<span class="math inline">\(b\)</span>的维度是<span class="math inline">\((classNum,1)\)</span>。</p></li>
<li><p>解释一：此时<span class="math inline">\(W\)</span>就的每一行就可以理解为是一个类别的线性分类器，该行对应的输出就可以理解为图像是这一类的概率是多少。</p></li>
<li><p>解释二：另一种解释方法是认为<span class="math inline">\(W\)</span>的每一行对应一个分类模板，通过内积来比较图像和模板之间的相似程度，从这个角度看，线性分类器就是在利用学习到的模板针对图像做模板匹配。</p></li>
</ul>
<h3 id="什么是softmax层">什么是Softmax层？</h3>
<h3 id="为什么用softmax归一化而不用直接算求和的占比">为什么用Softmax归一化，而不用直接算求和的占比？</h3>
<h3 id="什么是交叉熵损失">什么是交叉熵损失？</h3>
<h3 id="交叉熵损失和最大似然估计之间的关系">交叉熵损失和最大似然估计之间的关系</h3>
<h3 id="激活函数是sigmoid时交叉熵损失和均方误差损失的区别">激活函数是sigmoid时，交叉熵损失和均方误差损失的区别</h3>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>常识题</tag>
        <tag>挖坑</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算之左移右移</title>
    <url>/archives/a957f7b8.html</url>
    <content><![CDATA[<blockquote>
<p>这是大一初学编程时的一道题，当时做了详细的推导，才慢慢搞懂位运算，再次回顾，发现有些知识点确实已经忘记，但再看完后总能叫快速的想起，还是需要温故知新呀！下面附上当时的代码及笔记，并顺带将位运算中的左移&amp;右移运算符进行回顾</p>
</blockquote>
<span id="more"></span>
<h3 id="十进制数转二进制数">十进制数转二进制数</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// char c = &#x27;a&#x27;;</span></span><br><span class="line">	<span class="comment">// c = c &lt;&lt; 1;</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; c &lt;&lt;&quot;c&quot;&lt;&lt;endl; 字符型不可以位运算</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;type in a decimal number n: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Convert n to a binary number:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">	    cout &lt;&lt; (n&lt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>) &lt;&lt; ((i+<span class="number">1</span>)%<span class="number">8</span>==<span class="number">0</span>?<span class="string">&quot; &quot;</span>:<span class="string">&quot;&quot;</span>); <span class="comment">// 问号表达式需要加括号 </span></span><br><span class="line">		n = n&lt;&lt;<span class="number">1</span>; <span class="comment">// 位运算符：左移 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附上当时的解析：</p>
<blockquote>
<p>这个是把输入的十进制转换成二进制输出。cout &lt;&lt; (n&lt;0?1:0) &lt;&lt; (i%8==0?&quot;&quot;:&quot;&quot;);这句话的意思是如果n&lt;0输出1，如果n&gt;=0输出0，后面的(i%8==0?&quot;&quot;:&quot;&quot;)其实没什么用相当于&quot;&quot;（可以用&quot;&quot;带入试试结果），唯一的作用就是把二进制位0或者1连接起来，没有空格。n&lt;&lt;1就是n左移一位，相当于乘以2.</p>
<p>例子：</p>
<p>输入5（0000000000000101）</p>
<p>按上诉程序的步骤：</p>
<p>1.n=5，即n=0000000000000101&gt;0,则输出0,左移1位</p>
<p>2.得到n=0000000000001010&gt;0,则输出0,左移1位</p>
<p>3.得到n=0000000000010100&gt;0,则输出0左移1位</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>29.得到n=0101000000000000&gt;0,则输出0,（此时已经输出为0000000000000）左移1位</p>
<p>30.得到n=1010000000000000&lt;0,则输出1,（此时已经输出为00000000000001）左移1位</p>
<p>31.得到n=0100000000000000&gt;0,则输出0,（此时已经输出为000000000000010）左移1位</p>
<p>32.得到n=1000000000000000&lt;0,则输出1,（此时已经输出为0000000000000101）左移1位</p>
<p>33.得到0000000000000000</p>
<p>循环结束</p>
<p>输出5的二进制表示0000000000000101</p>
<p>结束，LZ慢慢享用.</p>
<p>cout &lt;&lt; (n&lt;0?1:0) &lt;&lt; (i%8==0?&quot;&quot;:&quot;&quot;);//这句中cout是输出流，n&lt;0?1:0是一个问号表达式，如果n小于0则输出1，否则输出0 //整数在内存中用32位补码表示，即如果n的最高位为1，则n为负数；如果n的最高位为0，则n为正数或0。 //于是，当最高位为1时，由于n为负数，即n小于0，所以n&lt;0成立，输出1； //当最高位为0时，由于n为0或正数，所以n&lt;0不成立，输出0； //(i%8==0?&quot; &quot;:&quot;&quot;)首先，我觉得第一对双引号中间应该有一个空格，意思是每输出8位二进制数字之后输出一个空格隔开，方便阅读 //语法是，%为求余，如果i除以8余0则输出一个空格 n = n&lt;&lt;1;//这句的意思是每次输出一个二进制数后，把n左移一位，即把n的次高位移到最高位上，以此类推，这样当下次执行这个循环的时候，n的最高位就是原来的次高位，这样每次循环中，表达式n&lt;0就可以依次检查n在内存中的从最高位到最低位，每个二进制位是0还是1，并输出相应的二进制数。由于VC平台32位机中int类型是32位的，所以循环32次结束。</p>
</blockquote>
<h3 id="位运算左移右移">位运算——左移&amp;右移</h3>
<ol type="1">
<li>左移 &lt;&lt;
<ul>
<li>定义：将数字按位进行左移</li>
<li>用法：<code>a = a&lt;&lt;n;</code></li>
<li>效果：通常情况下，左移n位，则代表将原始数字a乘以<span class="math inline">\(2^n\)</span></li>
<li>注意：
<ul>
<li>一般int类型为32位，最高位代表符号，0为正，1为负</li>
<li>左移时右侧补零</li>
<li>当1移动到，或者移出最高位时，注意数字将变号，且不服从上述“效果”</li>
</ul></li>
</ul></li>
<li>右移 &gt;&gt;
<ul>
<li>定义：将数字按位进行右移</li>
<li>用法：<code>a = a&gt;&gt;n;</code></li>
<li>效果：通常情况下，右移n位，则代表将原始数字a除以<span class="math inline">\(2^n\)</span></li>
<li>注意：
<ul>
<li>一般int类型为32位，最高位代表符号，0为正，1为负</li>
<li>右移时，如果最高位为1，则从左侧补1，将不服从上述“效果”；如果为0，则补0，服从上述“效果”</li>
<li>当a为奇数时，上述“效果”也不成立。你如7&lt;&lt;2=3</li>
</ul></li>
</ul></li>
</ol>
<blockquote>
<p>参考：https://blog.csdn.net/qq_15037231/article/details/76999926</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>Action Spotting Experiments 行为检测实验</title>
    <url>/archives/e7d645d1.html</url>
    <content><![CDATA[<blockquote>
<p>最近在做本科的毕业设计，题目是足球视频中的行为关键帧检测算法设计。在实验过程中，发现有很多细小的想法，但有时一晃而过，可能是一些小的尝试，但很少会做对比试验，因此将这些想法记录下来，方便之后再做改进。</p>
</blockquote>
<span id="more"></span>
<h3 id="对比试验一判断skip-connection在tmm中是否有用">对比试验一：判断skip connection在TMM中是否有用</h3>
<blockquote>
<p>modify3_10 vs modify3_11: 在baseline的基础上加入TMM结构（12 3, 27 3, 40 3, 80 3）</p>
</blockquote>
<ol type="1">
<li>modify3_10：两个TMB都有跳连操作</li>
<li>modify3_11：两个TMB都没有跳连操作</li>
</ol>
<hr />
<h3 id="对比试验二tam模块的作用">对比试验二：TAM模块的作用</h3>
<blockquote>
<p>目前全部加TAM的效果最好</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>实验</th>
<th>设置</th>
<th>screen</th>
<th>nvidia</th>
<th>参数量（万）</th>
<th>s/epoch</th>
<th>ave-mAP on V</th>
<th>ave-mAP on T</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>modify4_1</td>
<td>全部卷积后面都加入TAM</td>
<td>1</td>
<td>0</td>
<td>32</td>
<td>43</td>
<td>55.97</td>
<td>54.74</td>
</tr>
<tr class="even">
<td>modify4_2</td>
<td>只在TMM中加入TAM</td>
<td>2</td>
<td>1</td>
<td>27</td>
<td>36</td>
<td>57.92</td>
<td>54.11</td>
</tr>
<tr class="odd">
<td>modify4_3</td>
<td>只在分类网络内加入TAM</td>
<td>3</td>
<td>2</td>
<td>15</td>
<td>32</td>
<td>55.96</td>
<td>53.52</td>
</tr>
<tr class="even">
<td>modify4_4</td>
<td>所有卷积后都不加TAM</td>
<td>4</td>
<td>3</td>
<td>15</td>
<td>32</td>
<td>57.05</td>
<td>54.98</td>
</tr>
</tbody>
</table>
<h3 id="对比实验三model3_5基础上修改">对比实验三：Model3_5基础上修改</h3>
<table>
<thead>
<tr class="header">
<th>实验</th>
<th>设置</th>
<th>screen</th>
<th>nvidia</th>
<th>参数量（万）</th>
<th>s/epoch</th>
<th>ave-mAP on V</th>
<th>ave-mAP on T</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>model3_5</td>
<td>无TAM结构，TMM：（33，53，73）</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>60.44</td>
<td>59.37</td>
</tr>
<tr class="even">
<td>model3_12</td>
<td>TMM中加入TAM结构</td>
<td>5</td>
<td>4</td>
<td>32</td>
<td>34</td>
<td>57.83</td>
<td>56.32</td>
</tr>
<tr class="odd">
<td>model3_13</td>
<td>无TAM结构，TMM(33, 53, 73, 93)</td>
<td>1</td>
<td>0</td>
<td>26</td>
<td>36</td>
<td>58.48</td>
<td></td>
</tr>
<tr class="even">
<td>model3_14</td>
<td>无TAM结构，TMM(33, 55, 77, 99)</td>
<td>2</td>
<td>1</td>
<td></td>
<td></td>
<td>59.97</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="对比实验四baseline基础上实验tam">对比实验四：baseline基础上实验TAM</h3>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>实验</th>
<th>设置</th>
<th>epoch</th>
<th>screen</th>
<th>nvidia</th>
<th>参数量（万）</th>
<th>s/epoch</th>
<th>ave-mAP on V</th>
<th>ave-mAP on T</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>modify5_0</td>
<td>Baseline</td>
<td>600</td>
<td>8</td>
<td>7</td>
<td>33</td>
<td>16</td>
<td>64.85</td>
<td>61.15</td>
</tr>
<tr class="even">
<td>1</td>
<td>model5_1</td>
<td>只在conv1后加入</td>
<td>600</td>
<td>3</td>
<td>2</td>
<td>35</td>
<td>16</td>
<td><strong>65.55</strong></td>
<td>62.49</td>
</tr>
<tr class="odd">
<td>2</td>
<td>model5_2</td>
<td>只在conv2后加入</td>
<td>600</td>
<td>4</td>
<td>3</td>
<td>35</td>
<td>16</td>
<td>61.52</td>
<td>60.94</td>
</tr>
<tr class="even">
<td>3</td>
<td>model5_3</td>
<td>只在conv3_后加入</td>
<td>600</td>
<td>5</td>
<td>4</td>
<td>39</td>
<td>20</td>
<td>64.30</td>
<td><strong>62.95</strong></td>
</tr>
<tr class="odd">
<td>4</td>
<td>model5_4</td>
<td>在conv1&amp;2后加入</td>
<td>600</td>
<td>6</td>
<td>5</td>
<td>36</td>
<td>17</td>
<td>63.70</td>
<td>61.24</td>
</tr>
<tr class="even">
<td>5</td>
<td>model5_5</td>
<td>在conv1&amp;2&amp;3都加入</td>
<td>600</td>
<td>7</td>
<td>6</td>
<td>42</td>
<td>19</td>
<td>64.61</td>
<td>61.45</td>
</tr>
<tr class="odd">
<td>6</td>
<td>5_6</td>
<td>同5_1</td>
<td>1000</td>
<td>3</td>
<td>2</td>
<td>35</td>
<td>16</td>
<td>63.28</td>
<td>62.20</td>
</tr>
<tr class="even">
<td>7</td>
<td>5_7</td>
<td>5_2</td>
<td>1000</td>
<td>4</td>
<td>3</td>
<td></td>
<td></td>
<td>63.97</td>
<td>62.48</td>
</tr>
<tr class="odd">
<td>8</td>
<td>5_8</td>
<td>5_3</td>
<td>1000</td>
<td>5</td>
<td>4</td>
<td></td>
<td></td>
<td>65.04</td>
<td>61.94</td>
</tr>
<tr class="even">
<td>9</td>
<td>5_9</td>
<td>5_4</td>
<td>1000</td>
<td>6</td>
<td>5</td>
<td></td>
<td></td>
<td>65.09</td>
<td>62.14</td>
</tr>
<tr class="odd">
<td>10</td>
<td>5_10</td>
<td>5_5</td>
<td>1000</td>
<td>7</td>
<td>6</td>
<td></td>
<td></td>
<td>61.03</td>
<td></td>
</tr>
<tr class="even">
<td>13</td>
<td>5_11</td>
<td>5_0</td>
<td>1000</td>
<td>8</td>
<td>7</td>
<td></td>
<td></td>
<td>64.42</td>
<td>62.39</td>
</tr>
<tr class="odd">
<td>14</td>
<td>5_12</td>
<td>5_3 加入BN</td>
<td>600</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="对比试验五在baseline的基础上实验tmm">对比试验五：在baseline的基础上实验TMM</h3>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>实验</th>
<th>设置</th>
<th>epoch</th>
<th>screen</th>
<th>nvidia</th>
<th>参数量（万）</th>
<th>s/epoch</th>
<th>ave-mAP on V</th>
<th>ave-mAP on T</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>6_1</td>
<td>baseline TMM(33, 53, 73)</td>
<td>600</td>
<td>2</td>
<td>2</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td>6_2</td>
<td>36+TMM(53, 73, 93)+add</td>
<td>600</td>
<td>3</td>
<td>3</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td>6_5</td>
<td>36+TMM(33, 93, 27 3)+add</td>
<td>600</td>
<td>6</td>
<td>6</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>6</td>
<td>6_6</td>
<td>36+TMM(73, 14 3, 21 3)+add</td>
<td>600</td>
<td>7</td>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>3</td>
<td>6_3</td>
<td>36+TMM(33, 73, 11 3)+add</td>
<td>600</td>
<td>4</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>4</td>
<td>6_4</td>
<td>36+TMM(53, 10 3, 15 3)+add</td>
<td>600</td>
<td>5</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>毕业设计</tag>
        <tag>足球</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本命令</title>
    <url>/archives/4b6ea061.html</url>
    <content><![CDATA[<p>在实验室得服务器上运行跑代码时，总是会用到一些Linux的基础命令，在此做一些积累，方便之后不用百度再去查。</p>
<span id="more"></span>
<h2 id="screen">Screen</h2>
<blockquote>
<p>GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。</p>
</blockquote>
<ol type="1">
<li><p>简介：在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p></li>
<li><p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前的screen</span></span><br><span class="line">screen -ls</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入Detached状态的screen</span></span><br><span class="line">screen -r id </span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入Attached状态的screen（踢掉当前的，再次进入，程序会继续执行）</span></span><br><span class="line">screen -D -r id</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建新的screen</span></span><br><span class="line">screen -S name </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 中断当前的screen（只是退出screen，并不会终止程序）</span></span><br><span class="line">Ctrl+A+D # 中断当前screen</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出并销毁当前的screen</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看屏幕上方的输出</span></span><br><span class="line">Ctrl+A+[ </span><br><span class="line">Ctrl+v # 退出该状态</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止屏幕闪烁</span></span><br><span class="line">Ctrl+A Ctrl+G # 两个键依次按下</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果要对所有的screen生效，在~/.screenrc中加入vbell off</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>命令列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&gt; screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]</span></span><br><span class="line"></span><br><span class="line">-A 　将所有的视窗都调整为目前终端机的大小。</span><br><span class="line">-d   &lt;作业名称&gt; 　将指定的screen作业离线。</span><br><span class="line">-h   &lt;行数&gt; 　指定视窗的缓冲区行数。</span><br><span class="line">-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。</span><br><span class="line">-r   &lt;作业名称&gt; 　恢复离线的screen作业。</span><br><span class="line">-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。</span><br><span class="line">-s 　指定建立新视窗时，所要执行的shell。</span><br><span class="line">-S   &lt;作业名称&gt; 　指定screen作业的名称。</span><br><span class="line">-v 　显示版本信息。</span><br><span class="line">-x 　恢复之前离线的screen作业。</span><br><span class="line">-ls或--list 　显示目前所有的screen作业。</span><br><span class="line">-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业</span><br><span class="line"></span><br><span class="line">杀死screen虚拟环境</span><br><span class="line">exit</span><br><span class="line">screen -X -S [session # you want to kill] quit</span><br><span class="line"></span><br><span class="line">快捷键</span><br><span class="line">ctrl + a + c：创建新窗口（create）</span><br><span class="line">ctrl + a + n：切换至下一个窗口（next）</span><br><span class="line">ctrl + a + p：切换至上一个窗口（previous）</span><br><span class="line">ctrl + a + w: 列出所有窗口</span><br><span class="line">ctrl + a + A: 窗口重命名</span><br><span class="line">ctrl + a + d：detach当前会话</span><br><span class="line">ctrl + a + [1-9]: 切换到指定窗口（1-9为窗口号）</span><br><span class="line">ctrl + d：退出（关闭）当前窗口</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="查看文件个数">查看文件个数</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看文件夹下文件数</span></span><br><span class="line">ls -l |grep &quot;^-&quot;|wc -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看文件夹下文件详情</span></span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>
<h2 id="删除文件">删除文件</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf ./*** # r表示递归，f为强制删除没有提醒</span><br><span class="line">rm -r ./***</span><br></pre></td></tr></table></figure>
<h2 id="复制文件">复制文件</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -i ./copy/file/path ./target/path # i表示重名时会提醒(-f为强制)</span><br><span class="line">cp -r ./copy/file/path ./target/path # r的作用是递归，可复制目录，如果复制目录必须加此选项</span><br></pre></td></tr></table></figure>
<h2 id="查看gpu使用情况">查看GPU使用情况</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br><span class="line">watch -n 10 -d nvidia-smi # 间隔10s刷新一次</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Screen</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/archives/3c50d03d.html</url>
    <content><![CDATA[<p>之前只学过一些基础的markdown语法，但今日需要用到表格、行内公式、行内代码、代码段、流程图、引用网址、引用图片等语法，因此在此总结，方便之后使用。</p>
<span id="more"></span>
<h3 id="表格">表格</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 序号 |   中文   |       英文       |</span><br><span class="line">| :--: | :------: | :--------------: |</span><br><span class="line">|  1   | 机器学习 | Machine Learning |</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">序号</th>
<th style="text-align: center;">中文</th>
<th style="text-align: center;">英文</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">机器学习</td>
<td style="text-align: center;">Machine Learning</td>
</tr>
</tbody>
</table>
<h3 id="公式">公式</h3>
<ol type="1">
<li><p>行内公式： <span class="math inline">\(y=ax+b\)</span></p></li>
<li><p>公式段：</p>
<p><span class="math inline">\(f(x)=\alpha x+\beta\)</span></p>
<p><code>$f(x)=\alpha x+\beta$</code></p>
<blockquote>
<p>两者语法一样，都是用单个$。<a href="https://blog.csdn.net/ssjdoudou/article/details/103318019">公式渲染调试参考</a></p>
</blockquote></li>
</ol>
<h3 id="代码">代码</h3>
<ol type="1">
<li><p>行内代码：<code>tmp = a[i]+b;</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 语法：</span></span><br><span class="line"><span class="code">`tmp = a[i]+b;`</span> </span><br></pre></td></tr></table></figure></li>
<li><p>代码段：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 语法</span></span><br><span class="line">​<span class="code">```c++</span></span><br><span class="line"><span class="code">   #include&lt;iostream&gt;</span></span><br><span class="line"><span class="code">   using namespace std;</span></span><br><span class="line"><span class="code">   int main()</span></span><br><span class="line"><span class="code">   &#123;</span></span><br><span class="line"><span class="code">       cout&lt;&lt;&quot;hello world&quot;;</span></span><br><span class="line"><span class="code">       return 0;</span></span><br><span class="line"><span class="code">   &#125;</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="流程图">流程图</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<h3 id="引用网址">引用网址</h3>
<ol type="1">
<li><p>在当前页跳转：<code>[百度](http://baidu.com)</code> <a href="http://baidu.com">百度</a></p></li>
<li><p>在空白页打开：<code>&lt;a href=&quot;https://baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;</code> <a href="https://baidu.com" target="_blank">百度</a></p>
<blockquote>
<p>两者好像效果一样，估计跟渲染器有关</p>
</blockquote></li>
</ol>
<h3 id="引用图片">引用图片</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 &#x27;&#x27;图片title&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://pic2.zhimg.com/v2-bec8cb8d4ddee4ae698e2a4a41eb1610_1440w.jpg?source=172ae18b" title="title" alt="图片alt" /><figcaption>图片alt</figcaption>
</figure>
<h3 id="文字颜色大小居中">文字颜色、大小、居中</h3>
<blockquote>
<p>用html的语句写就可以啦</p>
</blockquote>
<p><font color="#FF0000"> 我可以设置这一句的颜色哈哈 </font></p>
<p><font size=6> 我还可以设置这一句的大小嘻嘻 </font></p>
<p><font size=5 color="#FF0000"> 我甚至可以设置这一句的颜色和大小呵呵</font></p>
<center>
这一行需要居中
</center>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;#FF0000&quot;</span>&gt;</span> 我可以设置这一句的颜色哈哈 <span class="tag">&lt;/<span class="name">font</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">6</span>&gt;</span> 我还可以设置这一句的大小嘻嘻 <span class="tag">&lt;/<span class="name">font</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">5</span> <span class="attr">color</span>=<span class="string">&quot;#FF0000&quot;</span>&gt;</span> 我甚至可以设置这一句的颜色和大小呵呵<span class="tag">&lt;/<span class="name">font</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>这一行需要居中<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="引用">引用</h3>
<blockquote>
<p>主要参考：<a href="https://www.jianshu.com/p/191d1e21f7ed">简书大佬教程</a></p>
<p>数学公式：<a href="https://blog.csdn.net/ssjdoudou/article/details/103318019">渲染</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>悉尼雪城对比</title>
    <url>/archives/8d8dca72.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="91e2540fe8396243be40e3f29c1b60014926e29fc3f064f6cfc0e6b0d8776594">283549565e3b2714e95c29f56cf4001858a5720f754722287c54df53589cd4e039cef4809dc3b2900beea0199f9c639e20a66bbbc2aa72d4761783bc9f2c23a2f47bcccfdd38c5d1c2ee00cd5f1692878c9da78c8dd91d34902548c5317ca61d2654d43f501ca75819aaccdac8fdd511e7ce195464aa4a63c0eade2dec18a11565ad95431677cd834951e9773b9fedc0e751fbf608ae6a8d3b3034744240e4c7f53b9de026b20e80835fa04edf3a90139f9340375a7d9d73bf9fc716dfa3d0f74a95a4a7bedd233b5529f498298145460ede2bd6a082a75ad92dd2b9b775961802a40d021671b92c619a7f5e4628ca13007cee4a4c6c28525bd2b5eed32ba4c1ad162f3c1579f4b4e0ec055abfca6bd53cb3e788be8ebdfc3d214edd70b31ba9f3810eebb5b17e5aaff602c552672fdb4e210709142b3c40a4d53d5cc029d1e07a708d1d936df841d4ee493552c15e57742aab7c9499efeda4f8105ba68384fd92e3de413d5ecedcc80f7d28179b4214856630c27d6a0f70f525603756befcdcf8991e3e4cb12538890bd5949f92212c7a183e1c9081f2c33f1d38ed10de8f326bed4bf57d00aa6addb4d4e725b044e5236d5074491b90623a0c1f9b256bd13b9b70c88f4c9410ecf4e36927412857e4875e806af40f4b99446f1a083616a28a65253035a812d4fea68d2e9bb3f53111aba763c0948049ed61db531b489cdbf84be6b1ab176bf41b2eb1166da7d90792c282bfeb28f4a301a7d9416f9b88eaf5bc373503dbd3166e66f1d869787d3a39f5a4a0c75f0281bd3994d3289c679508ea59e447569efd140e5adfbcece83a3fb7de7e62e17f18ccb269102cc51b74158e8fb02c594eb7b5d099a7f361d6f045d319f7405ea9543693515b57438ac63c6bf0fbef8fc0280069ce1adf321575bfa90b7b1545d984758ef03d95502706fbfa728dcd4cf030241be5bedc0c527aaa059bba906cd036e345e29c6b1e11a2459a951c0f28e70a8de64781e9d809b3270ecd73639bb39798f7067d7867e9e4af3b556e39b7b037ff2f3f7fe7a8e9251b6611e558254e426fd1696fbfe4e66c8c3a44beaa372e6b974c6c13185570f5f65df2c38c81ef1fba7940345ea4c014af8f24d1ee20dff00ec8e24a8105a073d2952109545e3a885d363a0c63bda2c3754a9be40280e91aa856fc8d9d867827bff3ca5c715546acd4c0807fe71e65e899ad01810f76051efb40167395d101d7f54520551589511c495be59876542f5eb0470da2daed54ebdfcb976f7c35dd43cbd9ce5fa002bdb98d3533b56cea3928275dd09a988488061c5e0de8de30814cdcc24ac858ac1a2c3bf34fbc073637f4463b246a00bde51fcf942fe84e91c6a4079deeb2dce915c598b662d76e1c710adf9ecb779ac16bf66c4da16b4cac86299ea92e02e2cb07abf99a95bb469e3fc608f123e4a19e34e8c4007a756f1c7b47428e1bacca56a6868aea50d8061a4219b3c9d80ec7e8df713836f457164fa463cdd657d6effb22afea9fa51fe7c86d6c0d07a059c236f20084eac733b0afd98a26bbcbdbe1b0b7d220340c1cf8318e4cfa13ac9505cc3f4bfb5a0d447b8b56c8d548df0048dbd84d6e7d178c5d18d5710c37dfccf5441c61dc10c952e2d9f8ba180ef402d72d816fe877621762fb6bb7af0203f5ee0aed383fc3d28fc455a8520becd6914eeebbba03fdfe6131e3852442474f2fc897a3416491dd06acd55423adcb160c895716b75ec61af395398bff815ba47a06a4a8094b8db1365203484ce0e0d67e1e0817ac413338f72293fc80ce5dfb9669c98195a80a119add15d702c59eda0bc5457d243d1713d3e69baf273a65a487d12603d67cdc314a2aa2b37e081538b033a94e5a4ca88b1e9537d3cfa848153a60ac98d47e31ac8b2d3d540012ae362d4055458fc5619ca316c7be893df002a4fd0b28a3c43306e252e98e31ef56ea4e03dde606bd60f4b17fc70e54d5a14623fd14afccf54a71ee8b7a5523ab977b3c701d0679d0af62e0fdfdecdb08bfea458b24d23af08fc3558825b55d1fdd4b4077e269c96e01e8850a7dde84758a0178df2fda50747ed303889d6dc6e51d45dd56ca0f431c6d3a99fc19544bc22b51f9c48af29ca6a5481737a4db21d5da614c0dff2a8df5c90753ee71aa8be3402ba622fab48374ac5f9944a952f95328ce8e22c79af32068e9e755249ab1b16324f67da473067db94375e5b1530fed1209d50e33a59b6ec4e6c99d869f59ddf44d466caf7521e779e404d052083dca947cc9fd88b515d31492ee28c0393365443d0a2acc67a558cf9677bbb47c8a329f19b85a833ab4da3bdb77d16d577db6d9681507f329df970dfd25ab3628ae9c42930c9b0cf836fd5afd1db4a4fb35994809c4b3ff6801cb0cfc9238523e4d053d01cf626b51a35783007720984638d803c8970d0c04b3426c5ddd163650ac590b0d09c941329555204089c1bbae0f058c5c7d7c1e1f406f4b0bea64b87e41b27572d02536657a017ad2fc62917a7f9b2e43eda55cfe92c29d5c4484a4d11d76aad796303e1c94472d912c68d6d1d0f8637e392ef9f0b22b00ec55bb8eaeae12229a3c2a889c2a89f6aee0b360d449e5bce89ed06e61ac4c3cf3b7e022489c09939328413568e8ed53f8a1a931c9096e72373cfea5338765c0089695146f52c1cce1aa47071ec1d414d7cd7d55f35be26d46ad8062a928fbafb14377980d5823fe69dc971c807f9a495ba52fd828d202106b74cdd07e3cc3e272d44ff82c96394251e85561f87d7773fe643323ecd7c86299efb47ae546b9d8cf4fce45a7017231f30ae6d060ea65ffbfcdaebf5d5d963d37baa043ed89b6665522ad608e3559ea00cdbd712bbbe3560551a08c15e03f29540463fb14b876b2fb889159df41162cf771e7a07bd364826cd56a2edd58c824c5b1366fc2491454d611a30efe6774fb1afb7ac16eef92728e942a614ae9f04b720b8edce93a726a6cf7ef32ac9aab08a4905ac9698f50f14e039fc600d41988d819849e0ee8eea22b3a37269c526310b869e43ed29dfa93523e55532bae643d4e371f45c22bec1949cd7e975a457a08851218751d29afba10b3824f7041bcfa0b9d08c4e3e1580c3bfc3834ade92b6ea84a4bab0158ce13b3a434dd26abae45500beaf665e2e4cb8c5a97b7c29db7d030ba51da42f5372d254c81952844a627abd57ee2052a9d7b62cec3db1190e5f965e07fcb9a7123e16cbd763cebf30cee9e6d91664b35908ead72c8a01d2b52352aa364cde4fd28023ec059c7257ef45c2a58aa11ded7b96277b64ea2d78baf4dffebe92ccff8d77503b896eb52eff158c60cd90c8ddf91893a9feb1afd4ef607cf616e8aa9561735ebe013c15998286df830d4cb72e5a5345361bf7a63392538e559b31d4f97e5fb8d056908d31d4885858d34bd80f3a349a1c8dbc83359439a1c16447fdeab42152fee5ef1213306619e832a10e21861a249620c32b3c6d71c16cf699c909ba9b0c8566da273f58cdb7d28ceceb219a4031d17fd157bebea6a8d987491b7daf522bf16a896bdd9a8fdeed29f7fccd286e86dfbb19d9d2ef7766fac6c0e5afe3e36439ec65e75bea4c4d96a405b49b98a6e48b4f444e6719a0852311ad8c4e75621f077a5682fbf64877518bfa56dbd2d49e9897498c9424f25c73b49ad4ac77969c0b633010036b6dd08ac1e0330af3977c7937722f8c32ee7b728b921ee936484774f71ef73a85daada2ad0564b8861c9737db43d68a63b97de8393616b10c264f0d7b258822507235a39f3e13ba228b19c7c2b85b600921ecf51bcdcb7957c39da73958e3cbdfceb04bb956845bbf9081c3b26924654af1d5e048c35c6f12834c3333691f74415ad741a3dc1a360395495e0de9583fca7073683bf8f599ae999e338a53a298302214322a42e374bc8264e578bd9433d3a879be391d4d85c6f275de1be4536dfb8ef64286636cbd7a37fee2bcfd2749469dbb2195eaaf680bfe6638a66151e2587c9fec79846e371c22b50a73833f3b8965d938075cff7e477104625281d0ce8c879f79278db2e99dc8f05110bcf74ccbbd5060a1ddc1811c8e0719cdd1723d930d55c346afd30932d222ff3d095e6040d6877503147405835cce7613b850d0cf6d9816ac8fc95ff4eb32d6cf10a04531c209c9e3b92501fb53abad2c368119b4d05e4e64343b80e0686623f54aaccbeef08e4f96bfb2420fc8ae693fa793a25cf2d15c14f58e63e7b07f068046e425fd18c7fc20fade8e85758a91f5e87f31027e5cc987968d82d29d6d73ee976df4b79d2f68e76864dd29cca0c8abf0353b484a676c3e44865ce5b9bc43372088d79794429876754e22429bc75dffb40a58f95fc732519b5d1e5183044c48fbf862feafaca02a1ddec8d485cbb08bc02c0549c6cdadfcd76af95a68a32d603d575f747dea19e0597b4d65ebae177fe941702a1bb8dd0294d4c6fbc05f1394d9d589f0084a06f1dd8fdb166b70bc12be3966472f45f885cc1501c39374b6358c9be16b4c9c0f1b0bebcc6406cc45c5253ad01b8141c4e278d300bc6c208de3a33bbacdccf2b0d60b6f0ca8c16d7fde46aa1914f23cd62ea4efabc2ad8cf0e82948d208ab228bbeda01c180bd59f02648eecdd1d23716c47559fece4b76a6617b33e2beb7fde99daa908859a572986960b3ca093d4df1f27e7e4b9eabc0c284f9951ab0926eee58b921ffb8c4ef2469bb36ebba88afe32d9bddc4bc764374158e27bd3efb309f17cfb119c3378212107099e0742693bc3837d78eaca2e0b54d15fd1dfee2e655709b3bda1c51e133e5c9c0a794a21296aaec756e21d9978531c0bf0d428e52bc835941d652137ff672ead9d7f7ee22801898b90298decd6d30091b5cfcf5c42d44c434f853feb75cdba6209a174c01a65c12729be334f6b1dc78bf94230810302eb97e4e07aa94fe6f15c88d0562fcaf0b60df84a9939387e033bd88a133d430f3bb9f9e04c9f211e2e14d9e8edda6b6498be7f54cd5bc1b3735445bfbe56ecda3a207fe043020229ac627635883b30eb7ed2c12775fef5981f4c87159c8e8ac04297326690a0c6c2ad4e6cac61e2eede4ff5cf5513436c47039e85a299bb923c509930409fb588a99060fd1daaa886885cfde8ce5b550f1bd9113aed7d46487d1d91ad080812592bb0b74f0c7324ddb109aec5f2956ad2c922d7644c570ee09bccb99729802f133745f4699490c40e09ac354a205a6907ffb03df11af99d5807cb85f886008f0f4897cce0b2a746ca1ac292d3926d82b97c02761dd5f40dfbdd248ec04172fb0bb81be5e144771bfbf4e1cd86a0a8499fbdd42721f5c2e9a69bbecd67ac747965eb3b9c4ba4be00105064b808aa07ee9e2d12039f17542dcd4d88c2d67c20cac344a29a2e642dd3ea6ce780c1dba5176d205d0395590454a6377a068c582e8e1a698fe549c32f3dc8a3b92d9947889c9e51a8450a28c6cd2a2629df9439a1511fead768728920d24cf360fb5fef4057f6637a9e53b00700e89a7910914fecba515bcd25c7a3eb35d962ee520393ba72459b536c12cb321fa406f34b4802b171a842817d12f673d79131780499ec1818af366473ebcb144989e96393bf56948a6adc437fb058c0aa3dfa4c4be5040a4d08a3abaa4958fc6bd6872226a6a328f74c1bfdd59a80669e847b2ef7a2ea8dd7d47398c6c220468855216972f6a04b36227bbe39fa0079c902a9c15e1f8b3e7dfb189194e4a7972720b62d38f1119e67f5375a18108676add78682bfb4f059ac3a8af2adbcc69b9c9634b75cd7d9aa30975f02f8520250960f42e335c0b436e6956aeb0b25a663e5f654b40547bdbf2837badc407cad204b0d2cbe4e48d83e89782e452d45024dfe033b98645c72e16d06627897390ad4499d011bb25ade162e2cdb2b166c85d54ad5dff5c14b5c64c41e6552b7fe4bb0da9616a0190087fbfbe5ddc25f976f3faea129add9048ebcb9825b177705b2824599f7b9b6f4d971f6b9e05fb033d83b06b701727299236f23af90b591ae9c05c87b3627d7491cc6b5de32a3ee0ae91fa2aa7ead1a886bb98fef8cee1e0db272f2cc1f1315bb38894b9709265452485ed9da311708b1acb9a00b1110f4dd6831a218ebf9c9e0a7d8a16960e4a9013e3c23ed730f901127a807f9f018de5215743b54b7a5b38786c634b82df9b356a28bda19113c0af9be5e95d4eb6506345ae93cd32f2ce8bad20056bc53a55d8d6c1cef0249aa60de05451663f9a17512e9c90e9981039b95704da40c823f47f6dbe5d1a866b59662122dc8b42a92afc853003671bcd3e59a2b5d00ae2563dc70c477f1501797e0528f193ebd283575ecbf14ee786766e19e4855a7c397b7f9dbc107ef7a1dcf8e8f1def6905bba978847f45b2d837aae3e7fa63b54cf27e11e5f9638ef233c88a877a873f37191f851c0dbe8fd263d6d650f182b113478ca2d1b31bd7265758f699c04dc8e8581cf8f0a866f9ce530b9c42da973face439b1b58c8d17aa968b8effefe77aa132532e8e54e5b1c1d31a5088d047bd4187b4da47e8eea251d19c54e6ed84c090378e60a8e609c9fed892c84a79c5cc8f25361f43456aac0608f1bb795ce24936a5b6250e0d08a032edbd36db4434089e38bbf10489882bb7c63c24a64742da801702f41f7d38fdc5f20a79f5334b1ba91285a296fd9155ed1dd44240a69f30bc7b5d349546f1cdfc830e64d2a75161941fae5b9c5294c3a7b1a949718696ea3ec06b6bc18b540dfbe785dbb9201dd7aef8e940b31ebbec4905aab391eb9dca1350e787791ece3fe988f598669dc821e8ba277d92ce4886ab58d869ba61514301845f153b9ab24d3abdbed5a2ff35afceb5a1979b209b2b146d019e00ab1e319ca9bb895472cc5d4ad5054d54d36890f984c8abf8e78996be250b4728214472c517083eaca9a6fad85380a9f1bf51325267fc34a2c743feb3aebf115addf53f89f4a5e227186a792d94ee0b9a1672b6a477cdfa38880c0051932115e3deb0ca0d04d3a714f766985e99fabcf4fe6bfe31fbff31939d57810869f666b6c86fec7562a1bf226eb93fbe7e7700793183635799f57162b64c02ab5987c7faf02f17e7f829bab8899438f9428b4336458b8714c0a7e19a81d25323c4385cdf3af5861513c7a1b5725bb98ecb025955a565d62d9484b0704734c4f4c5ca5372d70ae214f469d07d875d96e43ff6fa4f4918ef6b0e0d6031d816706d4d7b0604dc32f7ba5e7e39850f8cef788a05536815e88079f4067c643ae5338cf7fe9839fcc20936f6f813b2208e60335628e4382737bc9e1642bfe696ba01a40dedfba7520c67c26990c32c425302814cc58c7718e2cc8a0bb8928ecda5864d06319065cbd32d1dfbe1e3383bf3026c60e7443361242a5c69fb932125c406c3f2b882114b50d23ad940675e4b7b5ae265022bb6026b7ce921aad9e83432a43c178a485e7f9a55580bea02eeba8c7f77f56902b29049b348ea782629c7867c957f2253c9dc591da2249d310cd15cd171d4ae4622e5805ff5fee0c99b1b2b399a148ff81f58d825b18cfa351838869f8058412aae693da7a76b3a4e43cea046a4a2d2cba4a4c0433a489b137702a284cea09cf7f48a526e233f142ae3494b9265b0c8a601ea55ecd94f4b0075791c56e31be72280b071bf38eb97a57f3e56ddffa33034b6cb212655c12b435fad9e7aa7f3b1e63b07ba93eb301a052750c9c85c5ffff4260e72f9fbb7e3879b5d9d317693922b43db6bb7ec0921789c0a4a75b3b28f1c9110857fc615f4feb635c50ad7b68f2537eeb2b8e1e549f68a67b72d4b58ce3be3dd7377d8bca61a58fbc33f64c3f7e9b4471b918764174237dc541c83319b5777bae2cdcc72df00d19420f5ce3dae702992369835d0d3bb1013b631fe506e6f501158c003b8a6a66a39679de2a3e2ad92b9987162a100fb0ae3a2fa4026900385c363fe39537d0d97bc3b61869658074a8c92dad6feb6c57a2f8c3344bf76697cfc25e699687a51cc59f4e5eb1025daa828f9edd1088741d167e16093ed2e245e1e66719686eeb2db9a4e02517a47c555b1ae1a87cd9d0d94eaebd49425851990ef1f3b4ace9a031efb325501b4b0602038ad8ea50addbf4a9d1190904e2bc43635aa1b1e17d4034fecf243e7d3da834429cf7584338aad4d9f745eb8c4abd66b8f7412539c72164d0f0d095e4c0dba8f67a0bcbd4ec420704800f9257282a36f28cfc30a6b1e3433fa4a7ddc02e924e779c7454bc7060bdb2764f4cfe1dab64f81c02407657f749784b511a88aab091368f53fafd819dd1d58a836676d1dc30b277aa68a285823bd643f91312ea574bc91452010be9a99920e0d48ec1a508abceced5f4a8a4400ab80dfa92d33c27ee35be25b64fd3f3449a643300f45b208aa98f7e692409346721e7ff3c5f924c3439914e019a653a25df37ea64adcc4266f553062ca331ef64be442c9a7f0079585cd55ca3d8264f22ef9e999b703b5aadb772683c810a03bba700ab5a4670a2be41d8eeb88b6bf6520bd3d1f302b6df630907424cd071b35b271dad7a8716d2195674303713a76e005cd3a26f2f359de6cf00bf70c911075207f555182de3571a3e750e2d517c304acce3ffcded8e87f2a70416e16c5c786a71b636019d9846b4bb2319e62352ea6ca05b0980c0cd3e0f1e2adf4832ab80235fb1b6230174928d8f85b8abce941a90bc68e6d5b7b00d6caa29f2aec4479a51798ebb397385e9f7702497916583adf7cd7c7f1395617f4f2dea82206badb2a597f56cdd0e1bcff9c3b0d6b1c14023b4fb5c5d93355c8d0850650962dd73998f54d831c07eb1791a7b83c2e620716e0c59315e65282540fe19141e66598ecc6613f0de684db3702c20b0425dc47752398de055ad8d5af8c8c6ecb1c5674edbcfcfe7d0ee02a55320c70ebb06d89260d17926fba847b365b90795412127d47c50e34f1274a00f47a0cec390e3df519e02d09a839fc265d91629d485fcea97d9d85aaaf69834f46d069bc14f01fd6b09914878d2e4ad75a884084757edc1848c1787a63f349c7a8ffbd4d598d3b659a70de68c361f0f14b61026878eee61a5859760b51806e0d4e29fa5d177d3e3fd392060a711c1f1fe7ba277bdd657adeb91a149accf225f174ff5d28aee93d7f590566a1bacded5e97543a458c5793d2c6aaac3eeb1c9856f9fce4670b03e1d7d6e437389c01104f263278d3ab94a1395f8d2c0c0b21be51ea5a426c28bf17126ed0f9fc374fe495d044a9079d0063343312c32b2a581444df2e2c7abb98ce51794f6b608c11390634454482bf3a52f2ceca8d7fe6a987d49c81dc9f355b49f791b3e0afd05dfd6d16150ec2d9c6d1560f0695104ad6692e90b6846e79dd655eb0ae1e43ca5d2693372baa59a1e6313f60b6870142414d0f02c801c79ff201735139cf88d944d3ef29f67e285663b0e5d84539e072cdc101d5c74e18632f2808a19ae28c18779e988873ce7bb15a60f68315622f1ffbe21682f3e26cc5a5a23790a5577ea481c0b41bc7f1b9af77c6275cb1b07451730f4aef6b2878dc24166dd43b7ca36212d374e77da33fd8ab56f43ea10c173a18729fc1cadb3767bd2354a35eb9bfd770ed11d604bb762cd776d093e5053cce0aeff99f7665e604052301411d0ff382a36189d32137a0c972dbc5e2aeee836d867a3a2358e977218752acbb9e47e88d6698bf12113542c4560272adb2382f8a66962190df431472cf57195bc964deedc9193ea7255752f673ff9a0d889b1813a03742ef027f52d92f4936ae70b8c5e3e8da77b50675909db6686855f87c53e8e82178d5db75b639693539e06a3c4191d62f43d3c469647a4f9acb0f75baefd73188315f789577e9cc5243d75ccd8f877a850c5588bb9a5d681bb457bbd4366d10ea86dcb18617919e1e2fa46c98e23a3a427563e6359d00cbeea19a102d98dd419e2ef7649bb4ccedda3dbb27895d03160e8bbde79ccea5ba99f728b1604c3e25141013f13ee0da164150429974b6f65bc674749dd688685aa0f7505dc4155aa3d4aced6a6a4be9f424d2cf9f8891ca26a2f0ca93364a8d73fd1a34be0c2a190e3d15b6c9b333e052403d2c8cf1a76b9f8d4ee2e24934d0391163185e8e0f544a904e4dd317e5f727052a21a9c4919af2d46bbda5f3158efacee385275826e1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请在此输入密码">请在此输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>思考</category>
        <category>学业</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>重要决策</tag>
      </tags>
  </entry>
  <entry>
    <title>天文词汇 Astronomy</title>
    <url>/archives/27799dd0.html</url>
    <content><![CDATA[<h2 id="一太阳系-solar-system">一、太阳系 Solar System</h2>
<h3 id="基本信息">1. 基本信息</h3>
<ul>
<li>在太阳的引力作用下(Under the control of the Sun's gravitational force)，周边有8个行星(planet)、67个卫星(moon)、至少50万个小行星(asteroid)、矮行星(dwarf planet)和少量彗星(comet)绕其运转</li>
</ul>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/Solar_System.jpg" width="50%" height="50%" align="center"></p>
<ul>
<li><p>太阳系分为<strong>内太阳系(inner solar system)</strong>和<strong>外太阳系(outer solar system)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/inner_outer_solar_system.png" width="90%" height="90%" align="center"></p></li>
</ul>
<h3 id="详情">2. 详情</h3>
<h4 id="star-sun-太阳">1. Star: Sun 太阳</h4>
<ol type="1">
<li>从内到外：Core(日核)、Radiative zone(辐射层)、Tachocline(差旋层)、Convective zone(对流层)、Photosphere(光球)、Atmosphere(太阳大气层是一种气态晕(Gaseous halo))</li>
<li>Gaseous halo 气态晕：
<ul>
<li>chromospheres 色球层</li>
<li>solar transition region 太阳过渡区</li>
<li>corona 日冕</li>
<li>heliosphere 太阳圈</li>
</ul></li>
<li>Solar eclipse 日食</li>
<li>太阳风：当太阳中的太阳黑子(Sunspot)、耀斑(Solar flare)、日珥(Solar prominence)活动剧烈时，会产生太阳风，强烈时会影响通讯和航天设备运行</li>
<li>Aurora 极光：太阳风与高纬度地区磁场交互后产生</li>
</ol>
<h4 id="planet-行星-搞懂tpo16-2planets-in-our-solar-system">2. Planet 行星 （搞懂：TPO16-2《Planets in Our Solar System》）</h4>
<blockquote>
<p>按照物理性质可分为类地行星(Terrestrial <strong>(Earth-like)</strong> planets)和类木行星(Jovian <strong>(Jupiter-like)</strong> planets)</p>
<p>类地行星的特点：体积小、平均密度大、自转速度慢、卫星较少</p>
<p>类木行星的特点：体积大、平均密度小、自转速度快、卫星较多</p>
<p>在太阳的引力的控制下(Under the control of the Sun's gravitational force)，每个行星都保持一个椭圆轨道(maintains an elliptical orbit)，并且它们都沿相同的方向行进(travel in the same direction)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/8_Planets.png" width="50%" height="50%" align="center"></p>
<h5 id="mercury-水星">Mercury 水星</h5>
<h5 id="venus-金星">Venus 金星</h5>
<h5 id="earth-地球">Earth 地球</h5>
<h5 id="mars-火星">Mars 火星</h5>
<h5 id="jupiter-木星">Jupiter 木星</h5>
<h5 id="saturn-土星">Saturn 土星</h5>
<h5 id="uranus-天王星">Uranus 天王星</h5>
<h5 id="neptune-海王星">Neptune 海王星</h5>
<h4 id="dwarf-planet-矮行星">3. Dwarf planet 矮行星</h4>
<ul>
<li><p>包括：冥王星(Pluto)、谷神星(Ceres)、阋神星(Eris)、鸟神星(Makemake)、赛德娜(Sedna)和妊神星(Haumea)</p></li>
<li>特点：That is, it is in direct orbit of the Sun and is massive enough to be plastic – for its gravity to maintain it in a hydrostatically equilibrious shape (usually a spheroid) – but has not cleared the neighborhood around its orbit of other material.
<ul>
<li>必须围绕太阳运动</li>
<li>质量必须足够大，自身引力足以克服其固体引力以达到流体静力平衡，而使自己成圆球状</li>
<li>不能清除其轨道附近的其他物体</li>
</ul></li>
</ul>
<h4 id="comet-asteroid-彗星小行星">4. Comet &amp; Asteroid 彗星&amp;小行星</h4>
<ul>
<li><strong>小行星(Asteroid)</strong>类似行星环绕太阳运动，体积和质量比行星小得多，数量有数百万</li>
<li><strong>小行星带(asteroid belt)</strong>位于火星和木星轨道之间，由几百万颗大小不一的小行星组成。其中，最大的是谷神星，也是唯一的矮行星</li>
<li><strong>彗星(Comet)</strong>的外貌独特，呈云雾状，亮度和形状会随日距变化而变化。<strong>彗星分为彗核（comet nuclei）、彗发(coma)、彗尾(tail of comet)三部分</strong>。彗核由水、氨、甲烷等冻结的冰块和夹杂许多固体尘埃的粒子构成，进入太阳系后，当与恒星接近时，彗星冰冷表面的物质就会升华和电离，从而形成朦胧的彗发和一条稀薄物质流构成的彗尾</li>
</ul>
<h4 id="moonsatellitesecondary-planet-卫星">5. Moon/Satellite/Secondary planet 卫星</h4>
<ul>
<li>卫星(moon)围绕某颗行星按闭合轨道做周期性运动</li>
<li>除了水星和金星外，其它行星都有卫星环绕</li>
<li>木星最为富有，拥有79个卫星</li>
<li>半径大于1000km的有7个，月球即为其中之一</li>
<li>特点：
<ul>
<li>不会发光</li>
<li>围绕行星运转</li>
<li>随行星环绕恒星运转</li>
</ul></li>
</ul>
<blockquote>
<p>以上内容+图片均参考自&quot;X大仙机经&quot;微信公众号</p>
</blockquote>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>托福</tag>
        <tag>听力</tag>
        <tag>天文学</tag>
      </tags>
  </entry>
  <entry>
    <title>Of Studies</title>
    <url>/archives/8b15f764.html</url>
    <content><![CDATA[<h2 id="of-studies">Of Studies</h2>
<blockquote>
<p>——Francis Bacon</p>
</blockquote>
<span id="more"></span>
<p>Studies serve for delight, for ornament, and for ability. Their chief use for delight, is in privateness and retiring; for ornament, is in discourse; and for ability, is in the judgment and disposition of business. For expert men can execute, and perhaps judge of particulars, one by one; but the general counsels, and the plots and marshalling of affairs come best from those that are learned.</p>
<p>To spend too much time in studies is sloth; to use them too much for ornament is affection; to make judgment wholly by their rules is the humor of a scholar. They perfect nature and are perfected by experience: for natural abilities are like natural plants, that need pruning by study, and studies themselves do give forth directions too much at large, except they be bounded in by experience.</p>
<p>Crafty men contemn studies, simple men admire them, and wise men use them, for they teach not their own use; but that is a wisdom without them and above them, won by observation. Read not to contradict and confuse; nor to believe and take for granted; nor to find talk and discourse; but to weigh and consider.</p>
<p>Some books are to be tasted, others to be swallowed, and some few to be chewed and digested; that is some books are to be read only in parts; others to be read, but not curiously; and some few to be ready wholly, and with diligence and attention. Some books also may be read by deputy and extracts made of them by others; but that would be only in the less important arguments, and the meaner sort of books; else distilled books are, like common distilled waters, flashy things.</p>
<p>Reading makes a full man; conference a ready man; and writing an exact man. And therefore, if a man write little, he had need have a great memory; if he confer little, he had need have a present wit; and if he read little, he had need have much cunning to seem to know that he doth not.</p>
<p>Histories make men wise; poets witty; the mathematics subtle; natural philosophy deep; moral grave; logic and rhetoric able to contend. Abeunt studia in mores. Nay there is no stond or impediment in the wit, but may be wrought out by fit studies: like as diseases of the body may have appropriate exercises. Bowling is good for the stone and reins; shooting for the lungs and breast; gentle walking for the stomach; riding for the head; and the like. So if a man’s wit be wandering, let him study the mathematics; for in demonstrations, if his wit be called away never so little, he must begin again. If his wit be not apt to distinguish or find differences, let him study the schoolmen; for they are cymini sectores. If he be not apt to beat over matters, and to call up one thing to prove and illustrate another, let him study the lawyers’ cases. So every defect of the mind may have a special receipt.</p>
<h2 id="谈读书">谈读书</h2>
<blockquote>
<p>——王佐良译</p>
</blockquote>
<p>读书足以怡情，足以博彩，足以长才。其怡情也，最见于独处幽居之时；其博彩也，最见于高谈阔论之中；其长才也，最见于处世判事之际。练达之士虽能分别处理细事或一一判别枝节，然纵观统筹、全局策划，则舍好学深思者莫属。</p>
<p>读书费时过多易惰，文采藻饰太盛则矫，全凭条文断事乃学究故态。读书补天然之不足，经验又补读书之不足，盖天生才干犹如自然花草，读书然后知如何修剪移接；而书中所示，如不以经验范之，则又大而无当。</p>
<p>有一技之长鄙读书，无知者慕读书，唯明智之士用读书，然读书并不以用处告人，用书之智不在书中，而在书外，全凭观察得之。读书时不可存心诘难作者，不可尽信书上所言，亦不可只为寻章摘句，而应推敲细思。</p>
<p>书有可浅尝者，有可吞食者，少数则须咀嚼消化。换言之，有只须读其部分者，有只须大体涉猎者，少数则须全读，读时须全神贯注，孜孜不倦。书亦可请人代读，取其所作摘要，但只限题材较次或价值不高者，否则书经提炼犹如水经蒸馏，淡而无味矣。</p>
<p>读书使人充实，讨论使人机智，笔记使人准确。因此不常做笔记者须记忆特强，不常讨论者须天生聪颖，不常读书者须欺世有术，始能无知而显有知。</p>
<p>读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，论理学使人庄重，逻辑修辞之学使人善辩：凡有所学，皆成性格。人之才智但有滞碍，无不可读适当之书使之顺畅，一如身体百病，皆可借相宜之运动除之。滚球利睾肾，射箭利胸肺，慢步利肠胃，骑术利头脑，诸如此类。如智力不集中，可令读数学，盖演算须全神贯注，稍有分散即须重演；如不能辨异，可令读经院哲学，盖是辈皆吹毛求疵之人；如不善求同，不善以一物阐证另一物，可令读律师之案卷。如此头脑中凡有缺陷，皆有特药可医。</p>
]]></content>
      <categories>
        <category>思考</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title>名词性从句</title>
    <url>/archives/1f5cd790.html</url>
    <content><![CDATA[<h2 id="day-71-从句充当名词成份可跟在介词后">Day 71 从句充当名词成份(可跟在介词后)</h2>
<ol type="1">
<li><p><strong>句子</strong>：<font color=red>To reduce our</font> diet's <font color=red>impact, we'd also need to be a bit more rational about</font> <a href="n."><strong>how much</strong> we eat</a>.</p>
<span id="more"></span></li>
<li><p><strong>生词</strong></p>
<ul>
<li>rational adj.理性的</li>
<li>ration n.理性 v. 饮食合理化 (饥荒时期ration your food)</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>To do, 状语结构</li>
<li>how much/what/when/how/... 从句充当名词成份</li>
<li>Food production is an important contributor to environmental issues.</li>
</ul></li>
<li><p><strong>翻译</strong>：为了减少我们饮食的影响，我们同样应该在饮食上更加合理一些。</p></li>
<li><p><strong>默写</strong>：To reduce the diet's impact, we'd also need to be a bit more rational about how much we eat.</p></li>
<li><p><strong>造句</strong>：</p>
<ul>
<li>To complete the project, we'd also need to be a bit more patient about what we do.</li>
</ul></li>
</ol>
<h2 id="day-72-人-be-at-odds-over-n.">Day 72 人 + be at odds over +n.</h2>
<ol type="1">
<li><strong>句子</strong>：Economists <font color=red>are at odds over how</font> climate change <font color=red>will impact</font> the economy.</li>
<li><strong>生词</strong>
<ul>
<li><font color=red>人 + be at odds over + n.</font> 意见不一致 $ $ have a debate on + n.</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>how/why/what等疑问词引导名词性从句时，需要用陈述句语序</li>
<li>how/why等引导疑问句且对宾语提问时，动词/助动词/be/情态动词需提前（特殊疑问词+一般疑问句）;对主语提问时语序不变。
<ul>
<li>How will climate change impact the economy?</li>
<li>Why did climate change come into being?</li>
</ul></li>
</ul></li>
<li><strong>翻译</strong>：经济学家对于气候变化将如何影响经济的意见不统一。</li>
<li><strong>默写</strong>：Economists are at odds over how climate change will impact the economy.</li>
<li><strong>造句</strong>：
<ul>
<li>Ecologists are at odds over why/how climate change came into being.</li>
<li>Seismologists are at odds over how they can predict the earthquake.</li>
</ul></li>
</ol>
<h2 id="day-77">Day 77</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>There is often no transparency about why</font> people are seeing particular content on their social media feeds <font color=red>or who</font> is financing this content.</li>
<li><strong>生词</strong>：
<ul>
<li>transparency n. 信息透明、公开化</li>
<li>behind closed doors adj. 不为人知的</li>
<li>be kept ... in the dark v. 被蒙在鼓里</li>
<li>keep ... informed v. 使信息公开</li>
<li>well-informed adj. 消息灵通的（人）</li>
<li>feed n.数据流</li>
<li>rationality n. 合理性，机制背后的原因</li>
<li>algorithom n. 算法</li>
<li>finance <span class="math inline">\(\Leftrightarrow\)</span> sposnor vt. 资助，提供资金</li>
</ul></li>
<li><strong>句式</strong>：There is often no transparency about <strong>+ n.</strong>（why ... or who）名词性从句<br />
</li>
<li><strong>翻译</strong>：关于为什么人们在社交媒体数据流中可以看到一些特定的内容以及谁为这些内容付费，这些通常是不公开的。</li>
<li><strong>默写</strong>：There is often no transparency about why people are seeing <em>particular</em> content <strong>on</strong> <em>their social media feeds</em> or who <del>are</del> is financing the content.</li>
<li><strong>造句</strong>：There is often no transparency about why some nagtive news are forbidden on popular medias such as Sina Weibo and Wechat or what the forbidden machanism is.</li>
</ol>
<h2 id="day-78">Day 78</h2>
<ol type="1">
<li><strong>句子</strong>：Auctions <font color=red>can be exciting or intimidating</font>, with both buyers and sellers wondering exactly <strong>how much the property will sell for.</strong></li>
<li><strong>生词</strong>：
<ul>
<li><strong>intimidating</strong> adj. 惶恐的，不安的(frighten, make sb. less confidence; trigger)</li>
<li><em>sky diving</em> v. 跳伞</li>
<li><em>First date</em> v. 第一次约会</li>
</ul></li>
<li><strong>句式</strong>：... can be exciting or intimidating ...</li>
<li><strong>翻译</strong>：拍卖是紧张和不安的，买方和卖方都想知道这个东西确切价格是多少。</li>
<li><strong>默写</strong>：Auctions can be exciting or intimidating, with both <del>sallers</del> sellers and buyers wondering excetly how much the property will sell for.</li>
<li><strong>造句</strong>：
<ul>
<li>First date can be exciting and intimidating, with both boys and girls wondering what the other person thinks (what will happen next).</li>
<li>Interviews can be exciting and intimidating with interviewees wodering whether they will be adopted/recruited/employed.</li>
</ul></li>
</ol>
<h2 id="day-79-某人扮演的角色">Day 79 某人扮演的角色</h2>
<ol type="1">
<li><strong>句子</strong>：Parents <font color=red>will certainly be the</font> first <font color=red>to help</font> children learn <font color=red>what </font> is important in life, <font color=red>how </font> they are expected to behave <font color=red>and what </font> role they will play in their world.
<ol type="1">
<li>value 价值观</li>
<li>manners 行为方式</li>
<li>passion/niche 热爱的事业</li>
</ol></li>
<li><strong>生词</strong>：
<ul>
<li>be expected to do = be required to do 被期待/要求做某事</li>
</ul></li>
<li><strong>句式</strong>：sb. will be the someone to help sb. do what/how...</li>
<li><strong>翻译</strong>：父母将是第一个帮助孩子学会在生活中什么是重要的，孩子被期待什么样的表现，以及他们在世界上将要扮演的角色是什么。</li>
<li><strong>默写</strong>：Parents will certainly be the first to help children learn what is important in life, how they are expected to behave and what <font color=red>role</font> they will play in their world.</li>
<li><strong>造句</strong>：Friends will certainly be the first to help you know why friendship is important, how you will cooperate with somebody and how many funs you will have from them.</li>
</ol>
<h2 id="day-80">Day 80</h2>
<ol type="1">
<li><strong>句子</strong>：[<font color=red>What</font> consumers <font color=red>may come to see in</font> Amazon], <font color=red><strong>instead</strong>, is what I've started to notice</font> -- it's an inescapable, all-consuming retail paradise.</li>
<li><strong>生词</strong>：
<ul>
<li><strong>come to 逐渐，总算，终于</strong> 和 have to notice 呼应，表达后知后觉</li>
<li><strong>inescapable=unavoidable</strong> adj. 不可逃避的</li>
<li><strong>all-consuming 全身心的投入</strong>（修饰interest 指take up time/energy的事情）这里形容电商就是指会上瘾的<strong>addictive</strong></li>
<li>paradise n. 天堂 <span class="math inline">\(\Leftrightarrow\)</span> sencond to none 第一的，最好的</li>
<li>Amazon $$ online retailer 线上零售商
<ul>
<li>speed/convenience/wide selection</li>
</ul></li>
<li>counterfeit products 假货</li>
<li>shady products 质量不好的货</li>
<li>quality control 质量监控</li>
<li>rules = regulations 规章 regulate 管控</li>
<li>break up 结束；分解；解散</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li><strong>What 引导的主语从句有强调功能</strong></li>
<li>instead 插入语，一般放在句首，表示“取而代之的是”</li>
<li>-- dash 等同于 ':' 有解释说明的意思</li>
</ul></li>
<li><strong>翻译</strong>：取而代之的是，消费者在亚马逊上逐渐看到的是我刚刚开始意识到的——它是不可避免的，是会沉浸其中的零售天堂。</li>
<li><strong>默写</strong>：What consumers may come to see in Amazon, instead, is what I've started to notice -- it's an inescapable, all-consuming retail paratise.</li>
<li><strong>造句</strong>：What students may come to see in collage is what I've started to notice -- it's an broad platform connecting both students and the society.</li>
</ol>
<h1 id="模板">模板</h1>
<h2 id="day">Day</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red></font></li>
<li><h2 id="生词"><strong>生词</strong></h2></li>
<li><h2 id="句式"><strong>句式</strong>：</h2></li>
<li><strong>翻译</strong>：</li>
<li><strong>默写</strong>：</li>
<li><h2 id="造句"><strong>造句</strong>：</h2></li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>百句天天练</tag>
        <tag>写作</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>表语从句</title>
    <url>/archives/39059898.html</url>
    <content><![CDATA[<h2 id="day-91-paraphrase-句子改写技巧">Day 91 Paraphrase 句子改写技巧</h2>
<ol type="1">
<li><p><strong>原题</strong>：Some people say that main environmental problem of our time is the loss of particular species of plants and animals.</p></li>
<li><p><strong>改写</strong>：<font color=red>Some people consider that</font> the loss of individual species of plants and animals <font color=red>is the main</font> environmental <font color=red>problem of our time.</font></p>
<span id="more"></span></li>
<li><p><strong>生词</strong></p>
<ul>
<li>individual = particular adj.特定的；单一的(=single)</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li><font color=red>Some people <strong>consider/argue/believe/say</strong> that + 句子</font></li>
<li><font color=red><strong>同义替换</strong></font>
<ol type="1">
<li>同义词替换（注意保持词性不变）
<ul>
<li>loss <span class="math inline">\(\rightarrow\)</span> disappearance <span class="math inline">\(\rightarrow\)</span> extinction</li>
<li>problem <span class="math inline">\(\rightarrow\)</span> issue</li>
<li>particular <span class="math inline">\(\rightarrow\)</span> individual</li>
</ul></li>
<li>词性替换
<ul>
<li><ol start="14" type="a">
<li><span class="math inline">\(\rightarrow\)</span> v. (<strong>the loss of</strong> particular species of plants and animals <span class="math inline">\(\rightarrow\)</span> particular animals and plants <strong>are lost</strong>)</li>
</ol></li>
<li>adj. <span class="math inline">\(\rightarrow\)</span> adv.</li>
</ul></li>
<li>句式改写
<ul>
<li>主语和宾语互换位置</li>
<li>主动态 <span class="math inline">\(\rightarrow\)</span> 被动态 It has been said that</li>
<li>将状语部分提到句首</li>
<li>主谓宾 <span class="math inline">\(\rightarrow\)</span> There be</li>
<li>简单句 <span class="math inline">\(\rightarrow\)</span> 状语从句/定语从句</li>
</ul></li>
</ol></li>
</ul></li>
<li><p><strong>翻译</strong>：一些人认为特定植物和动物物种的灭亡是我们这个时代主要的环境问题。</p></li>
<li><p><strong>默写</strong>：Some people consider that the loss of individual <font color=red>species of</font> plants and animals is the main problem of our time.</p></li>
<li><strong>造句</strong>：
<ol type="1">
<li>原题：Some people say that life is easier and more comfortable than it was when your grandparents were children.</li>
<li>改写：
<ol type="1">
<li>Some people argue that life is poorer and more backbreaking when your grandparents were children than it was today.</li>
<li>Some people consider that it is easier and more convenient to make a living than it was when your grandparents were children.</li>
</ol></li>
</ol></li>
</ol>
<h2 id="day-92-改写词性">Day 92 改写词性</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>The most common belief among</font> Australians <font color=red>is that we will have to</font> change our lifestyles <font color=red>to</font> reduce energy consumption.</li>
<li><strong>生词</strong>
<ul>
<li>reduce energy consumption 减少能源消耗</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li><font color=red>believe v.<span class="math inline">\(\rightarrow\)</span> belief n.</font> 此时句式也要修改</li>
<li><font color=red>Some people believe that ... <span class="math inline">\(\rightarrow\)</span> The most common belief <strong><em>among</em></strong> somewhere is ...</font></li>
<li>此时用介词among + 地点来代替some people
<ul>
<li>among the scientific community</li>
<li>among primary school teachers</li>
<li>among young people/ the millennials (84-9?)</li>
</ul></li>
</ul></li>
<li><strong>翻译</strong>：在澳大利亚人中间有这样一个说法，我们将不得不改变我们的生活方式来减少能源的消耗。</li>
<li><strong>默写</strong>：The most common belief among Australians is that we will have to change our lifestyle<strong>s</strong> to reduce the energy consumption<del><strong>s</strong></del>.</li>
<li><strong>造句</strong>：
<ul>
<li>The most common belief among Chinese is that we should honor our parents to accord with the moral standard.</li>
<li>The most common belief among the millennials is that we will have to <strong>be rational about</strong> how much we eat to reduce our diet's impact <strong>on</strong> the environment.</li>
</ul></li>
</ol>
<h2 id="day-93-指出逻辑谬误">Day 93 指出逻辑谬误</h2>
<ol type="1">
<li><strong>句子</strong>：A good critical thinker will point out <font color=red>while this is a significant issue, it <strong>is not relevant to</strong> the question.</font> (logging <span class="math inline">\(\rightarrow\)</span> biodiversity counter-point: x logging <span class="math inline">\(\rightarrow\)</span> job loss)</li>
<li><strong>生词</strong>
<ul>
<li><strong>while</strong> 1)Although 2)对比 3)与...同时</li>
<li>A be not relevant to B A与B不相关
<ul>
<li>miss the point</li>
<li>is beside the point</li>
</ul></li>
<li><strong>critical thinker</strong> 具有批判性思维的人</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>主语+谓语+<font color=red>while this is a significant issue, it is not relevant to the question.</font></li>
</ul></li>
<li><strong>翻译</strong>：尽管这是一个非常重要的问题，一个具有批判性思维的人将会指出这是和当前问题不相关的问题。</li>
<li><strong>默写</strong>：A good critical thinker will point out while this is a significant issue <del>problem</del>, it is not relevant to the question.</li>
<li><strong>造句</strong>：
<ul>
<li>While this is a significant issue, A good critical thinker will point out that it is beside the point(missing the point).</li>
</ul></li>
</ol>
<h2 id="day-94-背后机制的描述-rationality">Day 94 背后机制的描述 rationality</h2>
<ol type="1">
<li><strong>句子</strong>：Business groups <font color=red>would <strong>no doubt</strong> argue that if</font> wages <font color=red>rise, and</font> productivity <font color=red>remains flat, or negative, (then)</font> profits <font color=red>will fall and</font> jobs <font color=red>could go. <strong>That's a fair point.</strong></font></li>
<li><strong>生词</strong>
<ul>
<li>Business <strong>groups</strong> 商业公司</li>
<li>no doubt = undoubtedly adv. 毋庸置疑的</li>
<li>flat = unchanged = the same 不变的</li>
<li>rationality 背后的机制</li>
<li>productivity 生产率</li>
<li>profit n.利润</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li><font color=red>... would <strong>no doubt argue</strong> that <strong>if</strong> ... rise, and ... remains flat, or negative, <strong>then</strong> ... will fall and ...</font></li>
<li><strong>That's a fair point.(书面) = Fair enough(口语) 也行；也有道理</strong></li>
</ul></li>
<li><strong>翻译</strong>：商业公司毋庸置疑的会说，如果公司提升，生产效率会持平或者变低，从而导致利润降低以及裁员。</li>
<li><strong>默写</strong>：Business groups could no doubt argue that if wage<strong>s</strong> rise, and productivity remains flat, or negative, then the profit<strong>s</strong> will fall and jobs could go. That's a fair point.</li>
<li><strong>造句</strong>：
<ul>
<li>Students could undoubtedly argue that if homework load rise, and time of finishing it remains the same, or negative, then the accuracy rate could drop and the efficacy will fall. That is a fair point.</li>
</ul></li>
</ol>
<h2 id="day-95-现象-rightarrow-问题">Day 95 现象 <span class="math inline">\(\rightarrow\)</span> 问题</h2>
<ol type="1">
<li><p><strong>句子</strong>：The season's awards movies <font color=red>demonstrate that</font> cinema <font color=red>is dodging todays's pressing issues in favour of anodyne distraction.</font></p></li>
<li><p><strong>生词</strong></p>
<ul>
<li><p>cinema = film industry</p></li>
<li><p><font color=red>dodge</font> = avoid = shy away from 逃避，躲避</p></li>
<li><p><font color=red>in favour of</font> 赞成</p></li>
<li><p><font color=red>anodyne</font> adj. unlikely to offend anyone 不温不火的，不得罪人的；安慰剂</p>
<p><span class="math inline">\(\Leftrightarrow\)</span> controversial</p></li>
<li><p><font color=red>distraction</font> = pastime 消遣；分散注意力的事</p></li>
</ul></li>
<li><p><strong>句式</strong>：</p>
<ul>
<li>社会现象+ <font color=red>demonstrated that +</font> 社会问题 现象揭示问题<br />
</li>
<li><font color=red>dodge</font></li>
</ul></li>
<li><p><strong>翻译</strong>：这一季度获奖的电影反映了电影行业在逃避当今紧迫的问题，更偏向于一些不得罪人的娱乐主题。</p></li>
<li><p><strong>默写</strong>：The season's <font color=red>awards</font> films demonstrate<del>d</del> that cinema is dodging <del>the</del> <font color=red>todays's</font> pressing issues in favor of <font color=red>anodyne distraction</font> .</p></li>
<li><p><strong>造句</strong>：</p>
<ul>
<li>The increasing number of infected people by COVID-19 in America demonstrate that government's actions are dodging the pressing issues in favor of anodyne financial policies.</li>
</ul></li>
</ol>
<h2 id="day-96-观点段首句表支持利">Day 96 观点段首句——表支持（利）</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>The obvious argument in its favour is that</font> young children pick up languages much more easily than teenagers.</li>
<li><strong>生词</strong>
<ul>
<li><font color=red>in its favour = use sth. to one's advantage</font> 对...有利，支持它的</li>
<li>The odds are in our favor.<br />
</li>
<li>favorable adj.有利的</li>
<li>pick up
<ul>
<li>pick up languages/a bad habit 不经意间学会（耳濡目染）</li>
<li>pick up somebody 接人</li>
</ul></li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>The obvious argument in its favor is that ...</li>
</ul></li>
<li><strong>翻译</strong>：支持它（小学开始学习语言课程）的一个最显而易见的论点就是小孩子学会语言相比于青少年更加容易。</li>
<li><strong>默写</strong>：The obvious argument in its favor is that young children pick up languages easily than teenagers.</li>
<li><strong>造句</strong>：
<ul>
<li>The government should spend more money on primary education rather than college education. The obvious argument in its favor is that there are several other ways for colleges to raise money, such as the donation of alumnus.</li>
</ul></li>
</ol>
<h2 id="day-97-总结段正反融合">Day 97 总结段（正反融合）</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>Of course, both views are correct. The problem is they are often framed as mutually exclusive, when in fact we can effectively</font> teach the basics and optimize problem-solving <font color=red>at the same time.</font></li>
<li><strong>生词</strong>
<ul>
<li><font color=red>frame = express 表达</font> frame the question</li>
<li><font color=red>mutually exclusive 互斥的</font></li>
<li><font color=red>optimize</font> problem-solving
<ul>
<li>inquiry-base learning</li>
<li>task-base learning</li>
<li>project- base learning</li>
</ul></li>
</ul></li>
<li><strong>句式</strong>：文章总结，融合正反两方观点，强调两者并非对立
<ul>
<li><font color=red>Of course, both views are correct. The problem is they are often framed as mutually exclusive, when in fact we can effectively + 做什么 and 做什么 at the same time.</font></li>
</ul></li>
<li><strong>翻译</strong>：当然，两个观点都是正确的。问题是他们经常作为互斥的观点被表达，事实上我们可以高效的教一些基础知识同时优化一些问题解决的能力。</li>
<li><strong>默写</strong>：Of course, both views are correct. The problem is that they are always framed as mutually exclusive, when in fact we can efficiently teach the basics and optimize problem-solving at the same time.</li>
<li><strong>造句</strong>：
<ul>
<li>Of course, both views are correct. The problem is that they are often framed as mutual exclusive, when in fact we can work effectively and make less mistakes at the same time.</li>
</ul></li>
</ol>
<h2 id="day-98-观点段首句弊">Day 98 观点段首句——弊</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>A longer term fear is that</font> computers <font color=red>become so</font> intelligent <font color=red>that they begin to</font> make decisions <font color=red>without</font> human oversight <font color=red>and without regard for</font> our well-being.</li>
<li><strong>生词</strong>
<ul>
<li>fear <span class="math inline">\(\Leftrightarrow\)</span> concern <span class="math inline">\(\Leftrightarrow\)</span> danger</li>
<li>human <font color=red>oversight</font>
<ul>
<li>neglect <strong>n.</strong> 疏忽</li>
<li>have oversight of <strong>n.</strong>监管</li>
</ul></li>
<li><font color=red>regard for</font> our well-being
<ul>
<li>Best regards. 问候，只有这里可数</li>
<li>without regard for anybody else <strong>n.(v) attention/care</strong></li>
<li>hold sb. in high regard <strong>n.(v) respect</strong></li>
</ul></li>
<li>well-being n. 安危；安康</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li><font color=red>A longer term fear/concern/danger is that</font> 一个长期的缺点</li>
<li><font color=red>The obvious argument in its favor is that</font> 支持它的观点是</li>
<li>so + adj. + that 如此...以至于</li>
<li><ol start="22" type="a">
<li><ul>
<li>without + n. and without + n.</li>
</ul></li>
</ol></li>
</ul></li>
<li><strong>翻译</strong>：一个长期的缺点是计算机变得太智能了，以至于开始不关注我们的安危同时在没有人类监管的情况下做决定。</li>
<li><strong>默写</strong>：A longer term fear is that computers become so intelligent that <font color=red>they</font> begin to make decisions without human oversight and without regard for our well-being.</li>
<li><strong>造句</strong>：
<ul>
<li>A longer term concern is that viruses become so drug-resistant that we have to raise awareness of prevention and keep researching new vaccines.</li>
</ul></li>
</ol>
<h2 id="day-99-comes-with-time">Day 99 comes with time</h2>
<ol type="1">
<li><strong>句子</strong>：This skill <strong>comes with time</strong> and good parenting, <font color=red>and my firm conviction is that</font> punishment <strong>does not have much of a role to play</strong> in this.</li>
<li><strong>生词</strong>
<ul>
<li><font color=red>The skill/Trust/Team camaraderie/Self-efficacy <strong>comes with</strong> time/care/attention/accumulating experience</font> 某样东西的养成需要时间/精力/经验的积累</li>
<li>A <strong>does not have much of a role to play in</strong> B A对于B没什么用 = does not work</li>
<li>A play a role in B A对B有作用</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li><font color=red>A comes with B</font> A的养成需要B的积累</li>
<li><font color=red>My <strong>firm conviction</strong> is that = I firmly believe that</font></li>
</ul></li>
<li><strong>翻译</strong>：这个技能的形成是需要时间以及良好的教育的，我非常坚信的是惩罚这个做法对于这个技能的养成没有任何的作用。</li>
<li><strong>默写</strong>：This skill comes with time and good parenting, and I firm conviction is that punishment <strong>does not have much of role to play</strong> in this.</li>
<li><strong>造句</strong>：
<ul>
<li>Team camaraderie comes with accumulating experience, and I firm conviction is that team terms don't have much of role to play in this.</li>
</ul></li>
</ol>
<h2 id="day-100-问题观点澄清不是-而是">Day 100 问题/观点澄清（不是 而是）</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>The trouble isn't that</font> it's hard to make the case that Amazon is extremely big and powerful; <font color=red><strong>t</strong>he trouble is that </font> even as Amazon gets bigger, it still faces relentless competition in the retail business, and <strong>is therefore</strong> not slowing in any obvious way to act like a lumbering monopoly of yore.</li>
<li><strong>生词</strong>
<ul>
<li><font color=red>make the case that</font> = argue that 认为</li>
<li><font color=red>relentless competition</font> 不懈的无止境的竞争 relent v. 减弱，缓和</li>
<li>a lumbering monopoly of yore 昔日老态龙钟的垄断企业</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>My point isn't that ... ; my point is that ...</li>
<li>The trouble isn't that ... ; the trouble is that ...</li>
</ul></li>
<li><strong>翻译</strong>：问题不是说很难证明亚马逊非常强大，问题是即使亚马逊变大，它依然面临着零售行业不懈的竞争，因此它并没有显现出像昔日老态龙钟的垄断企业（一样的样子）。</li>
<li><strong>默写</strong>：The trouble isn't that it's hard to <strong>make the case</strong> that Amazon is <strong>extremely</strong> big and powerful; the trouble is that even <font color=red>as</font> Amazon gets bigger, it <del>is</del> still <font color=red>faces</font> relentless competition, and is therefore not slowing in any obvious way <strong>to act</strong> like a lumbering monopoly of yore.</li>
<li><strong>造句</strong>：
<ul>
<li>The trouble isn't that you are not trying hard to get this job; the trouble is that even as you try your best, the company does not plan to recruit new employees in this year.</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>百句天天练</tag>
        <tag>写作</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>同位语从句</title>
    <url>/archives/7dbecab8.html</url>
    <content><![CDATA[<h2 id="day-81-同位语从句-前面修饰的名词">Day 81 同位语从句 = 前面修饰的名词</h2>
<ol type="1">
<li><p><strong>句子</strong>：<font color=red>It's an unsettling thought that</font> extreme temperatures are the new normal for this generation of children.</p>
<span id="more"></span></li>
<li><p><strong>生词</strong></p>
<ul>
<li>unsettling adj. 使某人感到不安的 upset/anxious</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li><font color=red>It's a/an + adj. +n. +that + 同位语</font>
<ul>
<li><font color=red>It's an unsettling thought/news that</font></li>
<li><font color=red>It's a fun fact that</font></li>
<li><font color=red>It's a a happy accidence that we ran into each other.</font></li>
<li><font color=red>It's an universally acknowledged truth that</font></li>
</ul></li>
<li>the new normal 最近才有的新的惯例（现在出门戴口罩）</li>
</ul></li>
<li><p><strong>翻译</strong>：一个不安的想法是对于孩子这一代人，极端的温度已经是一个新的趋势。</p></li>
<li><p><strong>默写</strong>：It's an unsettling thought that extreme temperatures are the new normal for this generation of children.</p></li>
<li><p><strong>造句</strong>：</p>
<ul>
<li>It is a terrible news that the US government prohibits Chinese students from gaining American visa.</li>
</ul></li>
</ol>
<h2 id="day-82">Day 82</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>The development <strong>aims to</strong> ease the city's chronic housing crisis - <strong>and to</strong> challenge the mindset that</font> indigeneity <font color=red>and</font> urbanity <font color=red>are incompatible.</font></li>
<li><strong>生词</strong>
<ul>
<li>chronic adj. 慢性的</li>
<li>mindset n. 已有的观念 ideology/perspective</li>
<li>indigeneity adj. 传统的，本土的 indigenous/aboriginal 原住民的</li>
<li>urbanity adj. 现代的</li>
<li>incompatible adj. 不可共存的</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>ease housing crisis/the pain/the burden</li>
<li>challenge the mindset</li>
</ul></li>
<li><strong>翻译</strong>：这个发展（在温哥华土著区建两座大楼）旨在缓解住房压力同时挑战传统的观念，即传统的和现代的不能共存的观念。</li>
<li><strong>默写</strong>：The development aims to ease the city's chronic housing crisis - and to challenge the mindset that <strong>indigeneity and urbanity</strong> are incompatible.</li>
<li><strong>造句</strong>：
<ul>
<li>The policy that school should reduce student's academic burden <strong>aims to</strong> ease the <strong>curricular pressure</strong> of student and challenge the mindset that good education and less academic burden are incompatible.</li>
</ul></li>
</ol>
<h2 id="day-83-would-have-us-believe-that-the-fact-...-means-...">Day 83 would have us believe that the fact ... means ...</h2>
<ol type="1">
<li><strong>句子</strong>：Some media commentary <font color=red>would have us believe that the fact</font> the reef was not listed as endangered <font color=red>means</font> any concerns about its well-being are entirely <strong>misplaced</strong>.</li>
<li><strong>生词</strong>
<ul>
<li><font color=red>would have us believe sth.</font> 使我们相信（贬义）</li>
<li>endangerd adj. 濒危的</li>
<li><font color=red>misplaced</font> adj. 不合时宜的
<ul>
<li>misplaced confidence</li>
<li>misplaced trust/loyalty</li>
</ul></li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>The fact that +同位语+ means ...</li>
</ul></li>
<li><strong>翻译</strong>：一些媒体的评论引导我们相信，没有把珊瑚列入濒危物种的这个事实意味着任何对它安危的关心都是完全不合时宜的。</li>
<li><strong>默写</strong>：Some media commentary would have us believe that the fact the reef was not listed as endangered means any concerns about its well-being <strong>are</strong> entir<strong>e</strong>ly misplaced.</li>
<li><strong>造句</strong>：
<ul>
<li>Some teachers from training institutions would have us believe that the fact method is more important than practice in learning English means a lot practice is entirely misplaced.</li>
</ul></li>
</ol>
<h2 id="day-84-the-misguided-belief-that-...-means-...">Day 84 The misguided belief that ... means ...</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>The misguided belief that</font> searching always results in learning <font color=red>means</font> much classroom practice <font color=red>focuses on</font> searching to learn, <font color=red>rarely on</font> learning to search.</li>
<li><strong>句式</strong>：
<ul>
<li>The msiguided <strong>belief</strong> that + 同位语 + means + 宾语</li>
<li>searching always <strong>results in</strong> learning</li>
<li>searching(means) to learn(end) <span class="math inline">\(\Leftrightarrow\)</span> learning(means) to search(end)</li>
<li>the uncertainty of chaos <span class="math inline">\(\Leftrightarrow\)</span> the chaos of uncertainty -- <The Kite Runner></li>
</ul></li>
<li><strong>翻译</strong>：一个错误的观念认为搜索可以驱动学习，这意味着更多课堂练习关注于用搜索的方法去学习，而不是关注于学习搜索的方法。</li>
<li><strong>默写</strong>：The misguided belief that searching <del>leads to</del> always results in learning means much classroom practice focuses on searching to learn, rarely on learning to search.</li>
<li><strong>造句</strong>：
<ul>
<li>The misguided belief that parents are always right means many children focuses on the methods told by their parients, rarely on thinking by themselves.</li>
</ul></li>
</ol>
<h2 id="day-85-tipping-points">Day 85 Tipping Points</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>There is growing evidence = (that</font> Earth's systems <font color=red>are heading towards climate &quot;tipping points&quot; beyond which</font> change <font color=red>becomes abrupt and unstoppable.)</font></li>
<li><strong>生词</strong>
<ul>
<li>evidence 不可数名词，前后不加a, the,s</li>
<li><font color=red>head towards</font> 向着某处前进</li>
<li><font color=red>tipping points</font> 顶点（起步很艰难，过了这个点后会很顺利）</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>There be</li>
<li>beyond which / after which</li>
</ul></li>
<li><strong>翻译</strong>：越来越多的证据表明，地球系统正朝着气候的“临界点”迈进，变化变得突然而势不可挡。</li>
<li><strong>默写</strong>：There <del>are</del> <strong>is</strong> growing evidence that Earth's systems are heading towards climate &quot;tipping points&quot; beyond which <del>the</del> change becomes abrupt and unsto<strong>pp</strong>able.</li>
<li><strong>造句</strong>：
<ul>
<li>There is growing evidence that Artificial Intelligent are heading towards the tipping points beyond which technology revolution becomes abrupt and unstoppable.</li>
</ul></li>
</ol>
<h2 id="day-86-呈上启下说出事物不好的一面">Day 86 呈上启下，说出事物不好的一面</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>However, reaching the conclusion that</font> change is inevitable <font color=red>is not the same as assuming that</font> change is always for the better.</li>
<li><strong>生词</strong>
<ul>
<li>inevitable 不可避免的</li>
<li><font color=red>is not the same as + n.</font> 并不等同于</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li><font color=red>Reaching the conclusion that + 同位语 + is </font></li>
<li>assuming that change is always for the better. 这里为宾语从句，并非同位语从句(assuming the fact that)</li>
</ul></li>
<li><strong>翻译</strong>：但是，结论说改变是不可避免的并不等同于假设改变是更好的。</li>
<li><strong>默写</strong>：However, reaching the conclusion that change is inevitable is not the same as assuming that change is always for the better.</li>
<li><strong>造句</strong>：
<ul>
<li>However, reaching the conclusion that drinking water is good for our health is not the same as assuming that drinking water is always for the better.</li>
<li>However, reaching the conclusion that technology is game-changer is not the same as assuming that technology is always for the better.</li>
</ul></li>
</ol>
<h2 id="day-87-bounce-deeply-entrenched">Day 87 bounce &amp; deeply entrenched</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>While</font> Spain <font color=red>has largely <strong>bounced</strong> back from the economic crisis</font> of 2008, the internas' stories <font color=red>are a <strong>reminder</strong> that the recovery masks deeply entrenched socio-economic problems.</font></li>
<li><strong>生词</strong>：
<ul>
<li>bounce back from/to = recover 经历低估后返回</li>
<li>economic crisis = economic recession 经济危机/衰退</li>
<li>internas‘ = live in maid = carer 女佣</li>
<li>mask = cover up 覆盖</li>
<li><strong>deeply entrench</strong> = deeply rooted + problem/stigma/bias 根深蒂固的</li>
<li>socio-economic 社会经济的</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li><font color=red>While ... has largely <strong>bounced</strong> back from the economic crisis</font></li>
<li>sth <font color=red>are a <strong>reminder</strong> that the recovery masks deeply entrenched socio-economic problems.</font></li>
</ul></li>
<li><strong>翻译</strong>：<strong>虽然</strong>西班牙从2008年的经济危机中恢复过来了，但是女佣的故事作为一个警醒，（告诉我们，经济的）恢复掩盖了一些根深蒂固的社会经济问题。</li>
<li><strong>默写</strong>：While Spain has largely bounced back from the economic crisis of 2008, the internas' stories are <strong>a</strong> reminder that the recovery masks <strong>deeply entrenched</strong> socio-economic problems.</li>
<li><strong>造句</strong>：
<ul>
<li>While Wenchuan has largely bounded back from the earthquake of 2008, the story of corruption in charity is a remainder that the recovery masks deeply entrenched political problems.</li>
<li>While China has largely bounded back from the epidemic of 2020, the <strong>whistle-blowers'</strong> stories are a reminder that the recovery masks deeply entrenched policial problems.</li>
</ul></li>
</ol>
<h2 id="day-88-extended-family-fragment-into">Day 88 extended family fragment into</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>This is the story of</font> our times--<font color=red>the story of</font> the family, <font color=red>once a dense cluster of many</font> siblings and extended kin, <font color=red>fragmenting into</font> ever smaller and more fragile forms.</li>
<li><strong>生词</strong>：
<ul>
<li>extended family vs. nuclear family 大家庭vs小家庭</li>
<li>kin 集合名词，不用加s，表示远亲</li>
<li>siblings 兄弟姐妹，可数</li>
<li>break into pieces = fragment into 分裂</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>主句 This is the story of family. 后面的是同位语+现在分词结构修饰family</li>
<li>插入语，两个逗号隔开，这里是同位语，没有that连接</li>
</ul></li>
<li><strong>翻译</strong>：这是我们这个时代的故事——关于家庭的故事，曾经一个有很多兄弟姐妹和亲戚的大集合，分裂成了非常小的、破碎的形式。</li>
<li><strong>默写</strong>：This is the story of our time<strong>s</strong> -- the story of <strong><em>the</em></strong> family, once a dence cluster of many siblings and extended kin, fragementing into <strong><em>ever</em></strong> smaller and <strong><em>more</em></strong> fragile forms.</li>
<li><strong>造句</strong>：
<ul>
<li>This is the theory of Big Bang -- the theory of the universe, once a dence cluster of energy, fragmenting into smaller pieces(planets and stars).</li>
<li>This is the theory of being -- the theory of the cell, once a zygote full of energy, fragementing into trillions of cells making up our body.</li>
</ul></li>
</ol>
<h2 id="day-89-nurosportlogiq">Day 89 Nuro&amp;Sportlogiq</h2>
<ol type="1">
<li><strong>句子</strong>：Nuro <font color=red>, a</font> self-driving tech <font color=red>startup</font> created by two former Google engineers <font color=red>, says it's the first company to</font> win approval from U.S. regulators to test its battery-powered driverless delivery vehicles on public streets.</li>
<li><strong>生词</strong>
<ul>
<li><strong>tech startup 科技创业公司</strong></li>
<li>approval 批准，授权</li>
<li><strong>regulators 监管部门</strong></li>
<li>battery-powered 电池供电的（不烧油的）</li>
<li><strong>driverless(=self-driving)</strong> delivery vehicles 无人送货车</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>Nure后面的','跟的市 名词成份做同位语</li>
</ul></li>
<li><strong>翻译</strong>：Nure是由两位前谷歌工程师创立的自动驾驶创业公司，它说它是第一家获得美国监管部门授权可以在公共道路上检测电池供电的无人驾驶的送货车的公司。</li>
<li><strong>默写</strong>：Nure, a self-driving tech startup created by two formar Google engineers, says it's the first company <font color=red>to</font> win the approval from U.S regulators to test the battery-powered driverless delivery <del>car</del> <font color=red>vehicles</font> on <del>the</del> public streets.</li>
<li><strong>造句</strong>：
<ul>
<li>Sportlogiq, a tech startup <strong>concentrating on the intersection of sports and advanced AI technology</strong>, says it's products offer insights to help teams, sach as hockey, soccer and football, make smarter decisions and also to help broadcasters and media bring their audience closer to the game with deeper analysis.</li>
</ul></li>
</ol>
<h2 id="day-90-议题引出-climate-changeparentinggov.-spendingracismreform-of-educationgenetic-engineering">Day 90 议题引出 climate change/parenting/gov. spending/racism/reform of education/genetic engineering</h2>
<ol type="1">
<li><strong>句子</strong>：<font color=red>The issue of</font> climate change <font color=red>has become a battle of ideologies, values and worldviews, something that become much more pronounced in the last decade thanks to</font> our political class <font color=red>and to</font> parts of the media.</li>
<li><strong>生词</strong>
<ul>
<li>ideologies, values, worldviews 意识形态，价值观，世界观</li>
<li><strong>pronounced</strong>=obvious=easier to notice adj. 显著的，显而易见的</li>
<li><strong>thanks to 多亏了，由于</strong></li>
<li>class 阶级
<ul>
<li>political class 政客</li>
<li>working class 工人阶层</li>
</ul></li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>views vary from person to person(nation to nation) 因人而异（主语是views）</li>
<li><font color=red>The issue of</font> climate change <font color=red>has become a battle of ideologies, values and worldviews, something that ...</font>（主语是issue）</li>
<li>, something that ... 这里是同位语，解释说明climate change</li>
</ul></li>
<li><strong>翻译</strong>：气候变化的问题已经成为了一场关于意识形态，价值观和世界观的战争，<strong>由于</strong>政客们以及部分媒体的关注，这个问题在过去的十年间变得更加显著了。</li>
<li><strong>默写</strong>：The issue of climate change has become a battle of ideologies, values and worldviews, something that become much more pronounced in the last <del>dacades</del> <strong>decade</strong> thanks to the policial class and to parts of the media.</li>
<li><strong>造句</strong>：
<ul>
<li>The issue of <strong>racism</strong> has become a battle of ideologies, values and worldviews, something that become much more pronounced in last decade thanks to our political class and to parts of the media.</li>
<li>The issue of reform of education has become...</li>
<li>The issue of genetic engineering, including food production and cloning, has become ...</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>百句天天练</tag>
        <tag>写作</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>估计量的相合性和无偏性</title>
    <url>/archives/84afe1b9.html</url>
    <content><![CDATA[<h2 id="估计量">估计量</h2>
<ul>
<li><p>参数的点估计就是根据样本构造的一个统计量，把这个统计量称作总体总体参数的估计量</p></li>
<li><p>无偏性、渐进无偏性、有效性、相合性（一致性）都是对与样本统计量好坏的一种度量</p></li>
</ul>
<span id="more"></span>
<h2 id="无偏估计">无偏估计</h2>
<ul>
<li>定义：<span class="math inline">\(E(\hat{\theta})=\theta\)</span></li>
<li>解释：<font color=red>估计量的数学期望等于被估计参数的真实值</font></li>
<li>意义：在多次重复下（n不变），平均数接近所估计的参数真值</li>
</ul>
<h2 id="渐进无偏估计">渐进无偏估计</h2>
<ul>
<li>定义：当<span class="math inline">\(N \rightarrow \infty\)</span>时，<span class="math inline">\(E(\hat{\theta}) \rightarrow \theta\)</span>，就称<span class="math inline">\(\hat{\theta}\)</span>是<span class="math inline">\(\theta\)</span>的渐进无偏估计</li>
</ul>
<h2 id="相合估计一致性">相合估计（一致性）</h2>
<ul>
<li>定义：如果<span class="math inline">\(\hat{\theta}_{N}\)</span>依概率收敛到<span class="math inline">\(\theta\)</span>，就称<span class="math inline">\(\hat{\theta}_{N}\)</span>是<span class="math inline">\(\theta\)</span>的相合估计</li>
</ul>
<h2 id="强相合估计">强相合估计</h2>
<ul>
<li>定义：如果<span class="math inline">\(\hat{\theta}_{N} a.s.\)</span>收敛到<span class="math inline">\(\theta\)</span>，就称<span class="math inline">\(\hat{\theta}_N\)</span>是<span class="math inline">\(\theta\)</span>的强相合估计</li>
</ul>
<h2 id="有效性">有效性</h2>
<ul>
<li>指估计量与总体参数的离散程度，如果两个估计量都是无偏的，那么离散程度较小的估计量相对来说是有效的，离散程度用方差来衡量</li>
</ul>
<h2 id="举例二阶中心矩">举例：二阶中心矩</h2>
<ul>
<li></li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li><strong>无偏性有期望这个条件，样本均值的期望等于或趋于总体均值</strong></li>
<li><strong>相合性没有期望这个条件，样本均值随着n增大会趋于总体均值</strong></li>
<li><strong>相合性与强相合估计的区别</strong>：后者条件加强了，前者依概率收敛，后者a.s.（全概率，即以概率1收敛）收敛。</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>参数估计</tag>
        <tag>相合性</tag>
        <tag>无偏性</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机试200415</title>
    <url>/archives/174f01e4.html</url>
    <content><![CDATA[<blockquote>
<p>20年华为暑期实习的机试题目</p>
</blockquote>
<span id="more"></span>
<h2 id="求获胜者字符串计数比较">1. 求获胜者——字符串计数+比较</h2>
<ol type="1">
<li><p>题目描述</p>
<p>输出票数最多者，如果票数相当，按照字母排序，a&gt;b&gt;c,A&gt;B&gt;C,如果字母相同，则字母少的在前面，比如Luc&gt;Lucy</p></li>
<li><p>输入：</p>
<blockquote>
<p>Tom,Lily,Tom,Lucy,Lucy,Jack</p>
<p>Tom,Tomy,Toc,Toma,Tom,Tomy,Z</p>
</blockquote></li>
<li><p>输出：Lucy</p></li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic <span class="meta-keyword">error</span> <span class="meta-string">&quot;-std=c++11&quot;</span> <span class="comment">// 用c++11标准来编译</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span> <span class="comment">// 需要系统学一下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span> <span class="comment">// 需要系统学一下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span> <span class="comment">// 需要系统学一下</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法一：</span></span><br><span class="line"><span class="comment">// 1. 整体读入，切分名字，存入map中（去重+计数） ++map[key]</span></span><br><span class="line"><span class="comment">// 2. 将map中的数据放到vector中，用sort函数对vector排序（编写cmp，作为结构体排序交换条件）</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Info&gt; vec;</span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]&lt;<span class="string">&#x27;A&#x27;</span> || s[<span class="number">0</span>]&gt;<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; ++i)</span><br><span class="line">        <span class="keyword">if</span>(s[i]&lt;<span class="string">&#x27;a&#x27;</span> || s[i]&gt;<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 将名字插入到map中，并计数</span></span><br><span class="line">    ++mp[s]; <span class="comment">// ++map[s]操作符重载：判断s是否在map中，如果在，对应的value++；如果不在，将s插入map，对应的value=1.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">split</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>(); <span class="comment">// string的函数 .size()返回字符串长度</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    string cur;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[p] == <span class="string">&#x27;,&#x27;</span>) <span class="comment">// string类型可以直接用下标访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">check</span>(cur))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            cur = <span class="string">&quot;&quot;</span>; <span class="comment">// 清空当前cur</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur += s[p]; <span class="comment">// +=可以在string后面添加字符</span></span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; !<span class="built_in">check</span>(cur))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升序排列，返回false时对调两元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Info &amp;a, <span class="keyword">const</span> Info &amp;b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.cnt != b.cnt)</span><br><span class="line">        <span class="keyword">return</span> a.cnt &lt; b.cnt; <span class="comment">// int类型比较，小的排在前面</span></span><br><span class="line">    <span class="keyword">if</span>(a.name.<span class="built_in">size</span>() == b.name.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> a.name &gt; b.name; <span class="comment">// 长度相等的string类型比较，字母序小的排在后面</span></span><br><span class="line">    <span class="keyword">if</span>(a.name.<span class="built_in">find</span>(b.name) != string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// a.name包含b.name时进入，表明a应该排在b的前面，所以不交换</span></span><br><span class="line">    <span class="keyword">if</span>(b.name.<span class="built_in">find</span>(a.name) != string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// b.name包含a.name时进入，表明b应该排在a的前面，所以交换ab的位置</span></span><br><span class="line">    <span class="keyword">return</span> a.name &gt; b.name; <span class="comment">// 当出现次数相等、两名字不等号长且没有包含关系时，比较两字符串大小，如何比？！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="built_in">split</span>(input);</span><br><span class="line">    <span class="keyword">if</span>(!valid)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;error.0001&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将mp中的元素放到vector中，为了sort</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> o : mp)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(&#123;o.first, o.second&#125;); <span class="comment">// vector的函数，.push_back()，向vector中加入元素</span></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp); <span class="comment">// sort函数需要系统学习一下</span></span><br><span class="line">        cout &lt;&lt; vec[vec.<span class="built_in">size</span>() - <span class="number">1</span>].name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (auto o : vec)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; o.name &lt;&lt; &quot; &quot; &lt;&lt; o.cnt &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二：</span></span><br><span class="line"><span class="comment">// 1. 整体读入，切分名字，存入vector（不去重，不计数）</span></span><br><span class="line"><span class="comment">// 2. 直接sort vector，遍历排好序的vector后找到最先出现的最大值</span></span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">split</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span> || s[i<span class="number">-1</span>]==<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;<span class="string">&#x27;A&#x27;</span> || s[i]&gt;<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;s[i]&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!(s[i] == <span class="string">&#x27;,&#x27;</span>|| s[i] == <span class="string">&#x27;\0&#x27;</span>) &amp;&amp; (s[i]&lt;<span class="string">&#x27;a&#x27;</span> || s[i]&gt;<span class="string">&#x27;z&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;2&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;s[i]&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;,&#x27;</span> || s[i]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            name.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(st, i-st)); <span class="comment">// string.substr(start, length)</span></span><br><span class="line">            st = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">split</span>(s))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error.0001&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(name.<span class="built_in">begin</span>(), name.<span class="built_in">end</span>()); <span class="comment">// 直接对string类型的vector进行排序，先按照字母序排序，字母序相同根据长度排序</span></span><br><span class="line">    string ret, tmp = name[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> vote = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> o : name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; o &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(o == tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; vote)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = tmp;</span><br><span class="line">                vote = cnt;</span><br><span class="line">                cnt == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分析</p></li>
</ol>
<h2 id="字符串匹配">2. 字符串匹配</h2>
<ol type="1">
<li><p>题目描述</p></li>
<li><p>输入：</p>
<p>read</p>
<p>read[addr=0x17,mask=0xff,val=0x7],</p>
<p>read_his[addr=0xff,mask=0xff,val=0x1],</p>
<p>read[addr=0xf0,mask=0xff,val=0x80]</p></li>
<li><p>输出：</p>
<p>0x17 0xff 0x7 0xf0 0xff 0x80</p></li>
<li><p>代码</p></li>
<li><p>分析</p></li>
</ol>
<h2 id="函数调用链栈总和最大值数据存储dfs">3. 函数调用链栈总和最大值——数据存储+DFS</h2>
<ol type="1">
<li><p>题目描述</p>
<p>函数调用链栈总和为调用链中各个函数栈大小的总和，给定输入，找到调用链中栈总和的最大值，注意入口函数不唯一，比如1调用2、3，5调用6，6调用7，则此时有两个函数入口1和5.</p></li>
<li><p>输入：</p>
<p>第1行：调用关系总组数n 第1组被调用函数个数 第2组被调用函数个数 ... 第n组被调用函数个数</p>
<p>第2行：调用函数1 函数1栈大小 被调函数1 ... 被调函数m</p>
<p>...</p>
<p>第n+1行：调用函数n 函数n栈大小 被调函数1 ... 被调函数k</p>
<p><strong>最多100行</strong></p>
<blockquote>
<p>输入案例1：</p>
<p>5 2 3 1 0 0</p>
<p>1 20 2 3</p>
<p>2 30 3 4 5</p>
<p>3 50 4</p>
<p>4 60</p>
<p>5 80</p>
<p>输入案例2：</p>
<p>5 2 3 1 0 1</p>
<p>1 20 2 3</p>
<p>2 30 3 4 5</p>
<p>3 50 4</p>
<p>4 60</p>
<p>5 80 1</p>
</blockquote></li>
<li><p>输出：</p>
<ol type="1">
<li>如果所有调用链中只要存在一个递归调用（即直接或间接调用自己，比如1-&gt;2-&gt;3-&gt;1即为递归调用），则输出R</li>
<li>如果调用链中有函数未给出调用栈大小，则输出为NA</li>
</ol>
<blockquote>
<p>输出案例1：</p>
<p>160</p>
<p>输出案例2：</p>
<p>R</p>
</blockquote></li>
<li><p>代码</p>
<ol type="1">
<li><a href="https%20://www.nowcoder.com/discuss/409299?channel=-1&amp;source_id=-1">代码参考自牛客网大佬</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; callnum, fsize;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; G; <span class="comment">// 记录调用关系，期中值为mp的value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; mp; <span class="comment">// 用于存储函数名和id的对应</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; vis; <span class="comment">// 用于判定是否存在循环调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cur为当前调用函数，sum为截止到目前需要的内存空间（包含当前调用）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> sum)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[cur] = <span class="literal">true</span>;</span><br><span class="line">	ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].<span class="built_in">size</span>(); ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> nxt = G[cur][i];</span><br><span class="line">		<span class="keyword">if</span> (vis[nxt])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">bool</span> ret = <span class="built_in">dfs</span>(nxt, sum + fsize[nxt]);</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[cur] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> num;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		callnum.<span class="built_in">push_back</span>(num); <span class="comment">//callnum 存入调用了多少个函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="comment">// 共n条数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		string name;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		<span class="keyword">if</span> (mp.<span class="built_in">count</span>(name) == <span class="number">0</span>) <span class="comment">// 如函数名未出现在mp中，则将其加入字典，并赋值++id</span></span><br><span class="line">		&#123;</span><br><span class="line">			mp[name] = ++id;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> sz; <span class="comment">// 当前函数栈大小</span></span><br><span class="line">		cin &gt;&gt; sz;</span><br><span class="line">		fsize.<span class="built_in">resize</span>(id + <span class="number">5</span>); <span class="comment">// resize函数是分配一个大小为id+5的空间，方便[]取地址，而不用push_back()函数</span></span><br><span class="line">		fsize[mp[name]] = sz;</span><br><span class="line">		<span class="comment">// cout &lt;&lt; sz &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; callnum[i]; ++j) <span class="comment">// 读取当前函数会调用的函数名</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// cout &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">			string s;</span><br><span class="line">			cin &gt;&gt; s;</span><br><span class="line">			<span class="keyword">if</span> (mp.<span class="built_in">count</span>(s) == <span class="number">0</span>)</span><br><span class="line">				mp[s] = ++id;</span><br><span class="line">			G.<span class="built_in">resize</span>(id + <span class="number">5</span>);</span><br><span class="line">			G[mp[name]].<span class="built_in">push_back</span>(mp[s]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; id &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">if</span> (id != n) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NA&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vis.<span class="built_in">resize</span>(id + <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> o : mp) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> enter = o.second;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id; ++i)</span><br><span class="line">			vis[i] = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">bool</span> ret = <span class="built_in">dfs</span>(enter, fsize[enter]);</span><br><span class="line">		<span class="keyword">if</span> (!ret) </span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;R&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>自己编写</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; G; <span class="comment">//每行一个函数，第0列为当前行调用函数的次数，第1列当前函数的序号，第2列为所占空间</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; flag;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur_f, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	flag[cur_f<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">	ans = <span class="built_in">max</span>(sum, ans);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; G[cur_f<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">3</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!flag[G[cur_f<span class="number">-1</span>][i]<span class="number">-1</span>])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">dfs</span>(G[cur_f<span class="number">-1</span>][i], sum + G[G[cur_f - <span class="number">1</span>][i] <span class="number">-1</span>][<span class="number">2</span>]))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	flag[cur_f<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	G.<span class="built_in">resize</span>(n + <span class="number">5</span>);</span><br><span class="line">	flag.<span class="built_in">resize</span>(n + <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		flag[i] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp;</span><br><span class="line">		cin &gt;&gt; tmp;</span><br><span class="line">		G[i].<span class="built_in">push_back</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		G[i].<span class="built_in">resize</span>(G[i][<span class="number">0</span>]+<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= G[i][<span class="number">0</span>] + <span class="number">2</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; G[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">dfs</span>(G[i][<span class="number">1</span>], G[i][<span class="number">2</span>]))</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;R&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分析</p>
<ul>
<li><p>运用深度优先搜索算法，相当于在图上找路，这里无需做剪枝操作，因为需要全部遍历，否则会遗漏掉循环现象。这里属于邻接表遍历，注意两层循环分别在哪里</p></li>
<li><p>注意dfs的参数定义，以及函数返回值和最终答案从哪里计算。这里采用bool类型的返回值，目的在于判断是否产生循环现象。最终答案通过一个全局变量来计算，注意vis/flag在dfs中变化的位置</p></li>
<li><p>注意给定数据如何存储和遍历（选择适当的数据结构很重要）</p>
<ul>
<li>当使用不定长数组时，需使用容器vector，这里主要用到了push_back(), resize(), 下标取值, 遍历器取值(auto a : G)</li>
<li>后期需要整理vector, map, string的用法</li>
</ul></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>字符串</tag>
        <tag>机试</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂句式</title>
    <url>/archives/8e48727d.html</url>
    <content><![CDATA[<h2 id="day-31-summarize-compare-the-trend-and-key-features">Day 31 summarize &amp; compare the trend and key features</h2>
<ol type="1">
<li><p><strong>句子</strong>：<font color=red>A whopping</font> 83 per cent <font color=red>of us wolud like to see</font> Australia <font color=red>rely more on solar power, <strong>while</strong></font> 68% <font color=red>would like to see more wind and</font> 62% <font color=red>more hydro power.</font></p>
<span id="more"></span></li>
<li><strong>生词</strong>
<ul>
<li>whopping = very large adj.相当大的
<ul>
<li>(whopping) hundreds of people 相当多的人</li>
<li>whop = hit, strike v.击打</li>
<li>screech v.发出尖叫、刺耳的声音</li>
<li>come to a screeching halt 戛然而止</li>
</ul></li>
<li><strong>a lion's share</strong> 绝大多数的人</li>
</ul></li>
<li><strong>句式</strong>：
<ul>
<li>while 这里表对比
<ul>
<li>虽然（放句首）= Although</li>
<li>对比（两句中间）</li>
<li>时间上的同时</li>
</ul></li>
<li>省略句，注意while后省略了&quot;of us&quot; 而and后面也省略了&quot;of us&quot;以及&quot;would like to see&quot;</li>
</ul></li>
<li><p><strong>翻译</strong>：有83%的人希望看到澳大利亚以后依赖于太阳能，而希望风能和水利发电的人分别是68%和62%。</p></li>
<li><p><strong>默写</strong>：A whopping 83 per cent of us would like to see <del>in</del> Australia rely more on solar power, while 68% would like to see more on wind and 62% more on hydro power.</p></li>
<li><p><strong>造句</strong>：</p>
<ul>
<li>In Peking University, 40 per cent of undergraduates would like to attend a company directly after graduate, while 30% would like to go abroad for a master or PhD degree and 30% would like to keep studying in China.</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>语法</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>托福备考规划051620</title>
    <url>/archives/d47528e1.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3c3fff5f3d9a90167749f31119f98dde64341ff7fa215f0ec633320ac9791e46">283549565e3b2714e95c29f56cf4001858a5720f754722287c54df53589cd4e0bda6133f8cfa686bb1d1af559c6491e8529fca216a3aa7907946c0276e3332a889b204389fbb05132b831e1ec966f7f0f7a021a82b3b9443327347b86be900a74a05fed4858240e17c7d49b863f1d7e6e924278e6fd00abc25fb6036de9d931efe5b192834091ddd38cd896a02db2218873e79fa528be6a11db5f3b6bbc2d1c08f2ab36f3bf0a8cc503c8d212d74599a103e57bb83a62133e593eb6f3407a287d30de9920f6652f6042e4e3f71913c5cc5104881eb7eebd2426e7e8c8b25b36edcdc5edb9ab43a75d4b7710229a04af5dda82050ff6e65266e96a2fb1f7a81b87ca51b9df6528f30d1f025b42a7f38da83efeb6c3e2fb0cbb108272d9fc364cfb9b8af27e05818e096b5615820ea51f1387805b930e9527b50c13dbb9c510b6fdc9451d7b755a4e7d2e3e3d3e71133c30cdbef6bf63dc3ee82836fce6b89f2f79750411dff7c1b4ec0a144a0744c0efd483ff76c6f2f84b34bcedc818dbada80f7391005e54c0a6dfbc6af5a0bfbc775dfe4f28269c4bdb9d9130bd7f540b1981136c5bbe499232d80e7927e141371bf779cb176d7b240fa13d3d240d4a2f49eea9606fd8457ac0a54c8bd0c20c090ab59239559e8ac1227bc27913170ce18d5b8bcaf8446682fee80d407e98ca94e2f918f059cd62e079a5c477708aa5efb90f0e0f4e5e5a1639f1ea6342415a993a6b02ed42469443e2cad85cfbd1bef46fe01cafd7bc40256134d4feede350796f54906e84162972a16ec9c9fd2d9281f6d37888c08479f30484143ab94a266992d606b065314f5d5b4a1752a63e45a89c08724880c40f4fe75d0a030a173ef9372c5c6d1b5dc15378faacaaf223370c4f6bf30851c68f6d15113820fe79695b732073dbedd4bab1999529ff3dfbedda5364166bc6cf713a82f7969df5c17813b0ee6ee3e61d6a849730ab3dfd8aed89419ea33d2993ec1bdb4940a327f6e89ab30cd5b0b095e042d9ba35969480d2cad6528039f0ea6816f151de1255b4fcba1e42ca46f93050f4723f806c7e371d355477a7d6f283d5f1fcf11233587e0edebb6afcb98a2316782ea708655a739b8fd37e75376c6fb8c95f47416bb93e142fcca09c276d07b3161ae5c0923c320951584aad5fd47b1408dcea3256eb8276b832bb187145b2ac44ee37920a3fd1d086825776e0d0f599b72b3741eb8d99171ac301d76d101c5a969eefe1b8786c3812cf9d80de8c62188917f9558fb007cdb17a80ca69e4c92d919106f875de981948c3af6330c8d8b9b0ac99bdc0a6b64fac68a07f326ff40de290bba9bbae2302bb144abd1fd985e511e3d369d309d7b6fe6c13038af8bd7d48b7abc4635d2d66ee4fed5eab148a37e008a0fff6481500b2a6e410c15148e14d91096d73926ac0a4a4743fbad3f3ef843c748dc7c4a996f9225b5572b7c00bb338e1fea760991d7e9923e710c36f264fd1f0764b1bfa970ff6c6ddd92621430387c0cbd0714cb4736e89f8edfdb128c72adfcfff954166cf29bc94bfe2b046732268f55c6403ea1b40ad14dcadbc3b8f041cb804c2ac18816b0cc139a59444ef4e1e26f5fba24d4e48580a8b66a10ac70cf069f84b9624ac736c635934e2ba454dbf85b0b11611f4bc8daf0ac050d63c032f65b0a44de2266c83feb17d8ad8102b34cd94fd69806a7fe2eed947a25c5fbec1ccf457afe106248c10b296221b6b8039eb8f33b162a573ccdfcca938b1ae6d315a8bb2ac6f6106ab6ca52ef607c92fc2eb4899a788489ab83daaf3ee5a24da0be7aa872f4c39139fbde25c6cef6f697083ccd0e3388a81049d48e4d7453432ff29bec2706701ce401e410c11f25ffcd5ea1de4932357f834d12e154bd156a107490dd8f85a257b2684a0ac99f97f027d39210f0cf03526233400c7b27394ff60d556cb69a2db067d66131e190bb1b8bcf0ad8e69348482ca2c1b99d68a0963dda7944a2bfe6786f4cb9c89a973c1460760df4e7c41539392ccb3ce229751e09045479f8027551848eb2993087d3911817d5023475896d8933354df77b6576fbf44db92b5a44f8884ef92a38b08600734e0930a2a18299f04c088a6788c49b5680b53a0f65fad691e80c759eab5269746ab67913b10d285c00bec63b208cf067e4f506148fd9726ba837f2ef267f7c12b008800448319bd8fdf6c677b384744e5523855cdd8ead3a54b41c02ea94e9f2519321668aed10bfa4f574418a105b00d91d1dc785659f22d9e442536b6580ea830fbec67e430535a90dcd7c8adf215745e2ca36b41d3351e0d0b4b49912f3454771a2bc525953e48e5ef5115d02bf7aac3194f9b80677bbc5d1a8c352ab7b78b09b1bbffad3edb6f005c50a32f22e825d18aee4b614f00c134e2ed61be6d29ed605b49604bd95943977c7bf760ee2031aac29d70c5802bacfdbae928380d32ae838f6cc463e73d6a2d34407db44fae0c26bcda1aa35d51b56d0b5ba369c28a5c72987b2892fc40f830ede716cfa757f37933547cb7a4e47a51a399995c78298f1e2d37f9673448a645242a9363516946603e42ff1f5b231cd5789075b81a4c432e196909a5eb1355591788981f62f4de23e7d96a168fef4627975c1fb2b40dae81acedf1818a7e4d5f04bef0fb8b7bfb8709ebe0de3f2f5b868079f4b6f400bd37bd2ae837b6ef86587eac0c6735faf3763a4fd2b848090a5bcf0e62429135605f62ec6d5577723f3ffdaa889617777a2603aefaa7e9438db678a177703380c79386e7092a279b3094fc9e9a9413bb0f976720d76025b5874b80d3d0a326ed5901aede0db6a2b157d0a2d131ffdf86fed9f4a59db95d57889bcd71f9695a611e25dbd72811926c41ca5540b1afe44bd8f8962c46d6fd3d6c5e47ef68e220fed558ab3213c2fe0706e90536b85ac7fbaf8eda98f6eaa041a646d3fe3d43d4726d205f8e6857d7cc560a895f138b19f06b73131d7030cf437f5108ed84228ab2a2593ba7cdab70a550586feb2522793c5b6590fbe8e5040bcffe5bf57f16a7be090b92dc12b61db88e2b9a73fd5cf4965e9b60ed45d2b58e02f3f8b7db05ba1cecb652a1452a132999bd2a561a25d711d17b19082f82f41553616a7fb61200be2483dcd882d2a88e65609eef141d7d23e48bde5f15dd4787d22d782c7a538e13b9aa602dd5529930e428688c04361adb8fa5d28f84846ae57cda69be55aa13a59e527b3c850224dc5fe818ed70015da575c75175f3af82757a44255580a67af5cc7eeda2a24cf34d4110f6e4fa26a520f8ccbdaafd645fec22c678d180e0f7ed241656194ceba77e7af6d037aecd0117e5d3a970495cd1f889647f3929fbe22df7e6bcc13ec080806b727a9a7fa04fdcf85dd3839793e883d3aaaede46c544eee1bf53c4416a95b9daef131f0a4c5ce46298b777a62ec78792a3b417ecaf453738ef84222577e261a18897f41b4f5db510b9501f06e7a5c338b8775dddcdfefbd49327c8805bf649273a4ee867aafcc32e1f9e0d9aa4c8d1d3b24aac16e3cee77197f24ab4ceb724083cd72ed1d88d83959a8be27dce19ae948575641278e02d02740bbeb30f74f4aead457530ebda95da98a44bbf4ecfad78349e9580195eeddad979062c6e38db2ad033aefe7b0d309495446c9de936afbc5280d3af2a3a6271f517d39d4e7f0100ec749c608a8b1dbcc5a939107635f44d4914a8193c6118975ea2ad2730a5bfa06ff3e44dd1b0efd8dbf9636b9904ec48c84d92f81da65ab0ab12ba687f11155c52ba65e6cca2e75cfe6b9abe1c6f70694158a072c1c15dc303d9a3256148f641cf371de75b60f47dd62b405d011ddf520d93aae0f367ce4216ba01ed69c92847b799e22f0445ac40873e1538c8cdcd714d09a134fa6154479b58a9abfe42ddef0a758298b93b31b9e75c60c96e4834979cb48fcb6892c1848d65a70c452a16322ea82e0fb3d59784a5281da846116a4a0aba939862ca8df3d80354b62fe7be47366cc22c3e4123c2bd2eb5ce88869340a16a69dd2a0436522347c79959b217454344f6eb81745e9a04ff91d5935d08e04a0140fccf34d94410c6c8e000c6b1da9cd04750b94c485c97531b9f1caf68cada2d7e359b7ef01bceee678f12141c2263195eea6266a8f20b2a9dd0d9e8438a73dcb4fb82f75347e693c68728ee5d5402da39bfb4b206b8b1717f269b77c089a7cda42b839fe20dd277e7460f2fa23bc30cce4d418ae4adecf80a4f88b6ad6e02d16a9301f8d3a121ed3944cc1319c840da9dd4ba1b69ea9e275287e0a278c6e8bff497a78f42985abe390e19cd0c9e9bb688c6ca59879aa6dd4a544b43577f4ac01b8477f896ffeb95ee82b48e0352a7dc1ac45ea25cb1cf5587853f0d713704e3565cc61c36e2e6d8eabe22413210367091a1619e0de5b049bfbec4ba305976af45b632e8940f13e12ee03894c2c197fcd5c7807afc280fa33b07b6d345527f8a2853a4b3357c7c2c8e35d90d1fdec9a31c38c659f505b32f3ac9f07b108cbf046de031b6679331f1f370abe11165327c2a1b8ac6ef71a697dc2a4d1e8473eb00817d76462c5c03184bf5291381430b395992e8dd982ea7a0b861fec537cb6b1beefc7a0fc4bf9a19124ca99b79805edc7559fbc4f21b919bc8694489fa3734e91fdf2537b1f7fe8867004f68d752991179e618ad0b5e556851c0a2af3e031d638889cc0e967befae57d5509fd437c992c5486b591f3463c1bc8bb5fb6f9f96c5a7c43b2eadc4aa02144308589cb6e53d4c5a6160230798189f68e4c7f1a54dd5a7018339fc987fe9142de5b11881ccf772f84185e5913e0320003353c62169d40da6a80bdae285b3edcdbc1db339f1d6592cc07e4fcc0e021c12fd399972b7619786e8cd77f7e7da6a03d71d28a2c0770491f7516fd8f7dfa69427a2f62278526134ced1005ff7aebf1e5bc6456a748ebe3b6372720f764ee8bdfed965ce387fd3d7d137ebf33c9460431248236a40558c7e05d3a30a2ad761be2ee7abb8065ba19789b166ef51d53907d18e6347b3ae0b6dfda0578bc646b0746815519e793cbccd61781f2962889d1a6bffe11dc7fa08845e67a0d45b087dc95e2ddbf01e49394ecbfb06b33b147070184d258e942eb19614be04d7ba383a515cc0633b3d17dec1d74c169db3f228d620f02828a80e9c6dfc48008b90fb2603f71deaa7b80075750c020f4abeef3d65cf43f411c4c26ad479b0b801640117ca17de533f22f39325ad16b685c9f532aa9baa5f3241beae9be4202ad70f5b5baeec65475981c8593165bf58ef411e2c492045bc8e9c3d76481115f94d83873ab683c085ba48ef0c532d94b6613e81f7f64a38c9e234c839d993c399328bb8fee9f1b00314ea9bd1c78be8cb9ba4ed4d9a9ad77e5796ebd85c5bd7937e09c4ec84d5cffbb099b01f11e2795c43d43ddf9ff1c5c83a633fba20f74f78dce54f4fa63445e0df9bfc1feb37ae6b32b50f7c4c4edb05a198e209ec719dd6b85f67de3cb7a0fd51bd8eeba58fff9c1e82dd65cb55da793d82483206798355dfa61e8a97eb6e4cc02c89d806300118597b52c6276b52f701ae716f4bc4af8b41d6d71921d6c86de9a992018e05bc73686c5ef18afa43b06e7ce011f6c4cc791d4227298dd89e65005880fa8df725604f74be381c9e9eba033aaaf366bae79d13e89e79081344dba43380a198110f476b96c87d8efd3c491ab2faaa81145f9000cacd3a286ddbdaf97093622f8600d571a0ea794d18b1095e4a6629b03cff8b5d39b5098309c74a664b392472e37480d97e7c5f5d6375a5eac80b12f6feb12110b720a073598c2d76ce24f5466f5d372988bb402b08463198cdb4e2f6bb6a19230eaa14c8ba8af9a776c8df5d7374d5dfa2cc424738c6c14afc2cc8fa95fd03157136c47594098ba2b31e988ba868e3fb0cbf511c9032c8c2c026e6c4c289760227cbb3e0edbd0a5946db0646873728a5656cd704410f9c2e90560e2f16d73247aa881dfd201a93ed22522dc514eb90954831c00966e530cd14ca3b377187c4d23022657da149aafb3f603fe64390cec927377c694c8c87145ade38e9490d750359ce1326b55152fccbd7c0512a9b925cf5a63b21f5cdf5b58bf4612be3f4f025a9e5fc89c535b37a4943bd686554a0b5b591bfed0166132c7b0452230cbc38d9a5515f1e95bb00a4447e511988f3436507bceac73423e0032f5bbd0a7b3a89efcfbc44f09ae506a71cd13b6ebe7ad34e13aefe8a4899e69a8da612921f3a5db0403919229e03d4ddc0eafab800311e68021b4ca2d4ae6ac16ed6f58c7a62cdd9e51f9a3239e14dbc9a55b6036672c48f012c180ec8bd9b7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请在此输入密码">请在此输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>托福</tag>
        <tag>规划</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>LeeCode151 翻转字符串里的单词</title>
    <url>/archives/d2f63532.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<blockquote>
<p>给定一个字符串，逐个翻转字符串中的每个单词。 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
</blockquote>
<p>示例 1： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure> 示例 2： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure></p>
<p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string">151. 翻转字符串里的单词</a></p>
<h2 id="c解题">C++解题</h2>
<h3 id="思路1整体反转单词反转">思路1：整体反转+单词反转</h3>
<ul>
<li>我们也可以不使用语言中的 API，而是自己编写对应的函数。在不同语言中，这些函数实现是不一样的，主要的差别是有些语言的字符串不可变（如 Java 和 Python)，有些语言的字符串可变（如 C++)。</li>
<li>对于字符串可变的语言，不需要再额外开辟空间了，直接在字符串上原地实现。在这种情况下，反转字符和去除空格可以一起完成。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/LeeCode151思路1.png" width="70%" height="70%" align="center"></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 反转整个字符串</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; ++start) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[start] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 填一个空白字符然后将idx移动到下一个单词的开头位置</span></span><br><span class="line">                <span class="keyword">if</span> (idx != <span class="number">0</span>) s[idx++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环遍历至单词的末尾</span></span><br><span class="line">                <span class="keyword">int</span> end = start;</span><br><span class="line">                <span class="keyword">while</span> (end &lt; n &amp;&amp; s[end] != <span class="string">&#x27; &#x27;</span>) s[idx++] = s[end++];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 反转整个单词</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + idx - (end - start), s.<span class="built_in">begin</span>() + idx);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">                start = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + idx, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析：</h3>
<ul>
<li>时间复杂度: <span class="math inline">\(O(N)\)</span>，其中 N 为输入字符串的长度。</li>
<li>空间复杂度: <span class="math inline">\(O(1)\)</span></li>
</ul>
<hr />
<h3 id="思路2-利用双端队列或栈">思路2 利用双端队列或栈</h3>
<ul>
<li>将字符串分成单词一个个放到双端队列或栈中,按照栈的顺序输出</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/weiren1998/Blog_Sources@main//imgs/LeeCode151思路2.png" width="70%" height="70%" align="center"></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[left] == <span class="string">&#x27; &#x27;</span>) ++left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[right] == <span class="string">&#x27; &#x27;</span>) --right;</span><br><span class="line"></span><br><span class="line">        deque&lt;string&gt; d;</span><br><span class="line">        string word;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[left];</span><br><span class="line">            <span class="keyword">if</span> (word.<span class="built_in">size</span>() &amp;&amp; c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">                word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word += c;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">        </span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans += d.<span class="built_in">front</span>();</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (!d.<span class="built_in">empty</span>()) ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<ul>
<li>时间复杂度<span class="math inline">\(O(n)\)</span></li>
</ul>
<h3 id="知识点总结">知识点总结</h3>
<ol type="1">
<li>单向链表的创建和遍历</li>
<li>vector的运用，push_back(), insert()</li>
<li>stack的运用，push(), size(), top(), pop()</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer3_从尾到头打印链表</title>
    <url>/archives/2ea5c0fa.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<blockquote>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32M，其他语言64M</p>
</blockquote>
<p>题目链接：<a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">剑指offer3 从尾到头打印链表</a></p>
<span id="more"></span>
<h2 id="单项列表结构体">单项列表结构体</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="c解题">C++解题</h2>
<h3 id="思路1利用vector的push_back插入后再遍历使得前后反转">思路1：利用vector的push_back()插入后，再遍历使得前后反转</h3>
<blockquote>
<p>运行时间：4ms 占用内存：504k</p>
</blockquote>
<p>代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; ArrayList;</span><br><span class="line">		ListNode* p = head; <span class="comment">// 防止head丢失</span></span><br><span class="line">		<span class="keyword">while</span> (p)</span><br><span class="line">		&#123;</span><br><span class="line">			ArrayList.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// for(int i = 0; i &lt; ArrayList.size() / 2; i++) 和下方循环效果相同</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ArrayList.<span class="built_in">size</span>() - i; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = ArrayList[i];</span><br><span class="line">			ArrayList[i] = ArrayList[ArrayList.<span class="built_in">size</span>() - <span class="number">1</span> - i];</span><br><span class="line">			ArrayList[ArrayList.<span class="built_in">size</span>() - <span class="number">1</span> - i] = tmp;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ArrayList;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：遍历链表复杂度为n，遍历vector复杂度也为n，所以总的时间复杂度为<span class="math inline">\(O(n)\)</span></p>
<h3 id="思路2利用vector的vector.insertvector.beginx从第一个元素前方插入元素省去反转过程">思路2：利用vector的vector.insert(vector.begin(),x)从第一个元素前方插入元素，省去反转过程</h3>
<blockquote>
<p>运行时间：3ms 占用内存：456k</p>
</blockquote>
<p>代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; ArrayList;</span><br><span class="line">		ListNode* p = head;</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="comment">// 首先要保证head指针不为空</span></span><br><span class="line">		&#123;</span><br><span class="line">			ArrayList.<span class="built_in">insert</span>(ArrayList.<span class="built_in">begin</span>(), p-&gt;val); <span class="comment">// 在第0个位置之前插入值</span></span><br><span class="line">			<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) <span class="comment">// 这里要保证head的子节点不为空</span></span><br><span class="line">			&#123;</span><br><span class="line">				ArrayList.<span class="built_in">insert</span>(ArrayList.<span class="built_in">begin</span>(), p-&gt;next-&gt;val); <span class="comment">// 这里添加的元素是子节点的值，而非当前节点的值</span></span><br><span class="line">				p = p-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ArrayList;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：时间复杂度<span class="math inline">\(O(n)\)</span></p>
<h3 id="思路3创建额外的stack存入stack后在正向pop出来">思路3：创建额外的stack，存入stack后在正向pop出来</h3>
<blockquote>
<p>运行时间：4ms 占用内存：452k</p>
</blockquote>
<p>代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; ArrayList;</span><br><span class="line">		stack&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">		ListNode* p = head; <span class="comment">// 防止head丢失</span></span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp.<span class="built_in">push</span>(p-&gt;val);</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> size = tmp.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ArrayList.<span class="built_in">push_back</span>(tmp.<span class="built_in">top</span>()); <span class="comment">//stack.top()取栈顶值</span></span><br><span class="line">			tmp.<span class="built_in">pop</span>(); <span class="comment">// 移除栈顶值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ArrayList;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：时间复杂度<span class="math inline">\(O(n)\)</span>，运用额外的空间</p>
<h3 id="知识点总结">知识点总结</h3>
<ol type="1">
<li>单向链表的创建和遍历</li>
<li>vector的运用，push_back(), insert()</li>
<li>stack的运用，push(), size(), top(), pop()</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer2_空格替换</title>
    <url>/archives/e1fca84c.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<blockquote>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32M，其他语言64M</p>
</blockquote>
<p>题目链接：<a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">剑指offer2 空格替换</a></p>
<span id="more"></span>
<h2 id="c解题">C++解题</h2>
<h3 id="思路1从前向后替换">思路1：从前向后替换</h3>
<p>代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replaceSpace1</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> cnt_length = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> cnt_space = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) <span class="comment">// char* 类型的字符数组结束符为&#x27;\0&#x27;</span></span><br><span class="line">		&#123;</span><br><span class="line">			cnt_length++;</span><br><span class="line">			<span class="keyword">if</span> (str[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">				cnt_space++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此时cnt_length长度不包括&#x27;\0&#x27;这一位,但大小与总体长度相同</span></span><br><span class="line">		<span class="keyword">int</span> new_length = cnt_length + cnt_space * <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (new_length + <span class="number">1</span> &gt;= length)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; new_length + <span class="number">1</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = length; j != i; --j)<span class="comment">//注意这里j的范围，如果定义为</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (str[j] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">						str[j + <span class="number">2</span>] = str[j];</span><br><span class="line">				&#125;</span><br><span class="line">				str[i] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">				str[i + <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">				str[i + <span class="number">2</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				i = i + <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		str[new_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：从前向后遍历的同时需要从后向前挪，复杂度为<span class="math inline">\(O(n^2)\)</span></p>
<h3 id="思路2从后向前替换">思路2：从后向前替换</h3>
<p>代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replaceSpace2</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> cnt_space = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) <span class="comment">// char* 类型的字符数组结束符为&#x27;\0&#x27;</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">				cnt_space++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				str[i + cnt_space * <span class="number">2</span>] = str[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (str[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				str[i + cnt_space * <span class="number">2</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				str[i + cnt_space * <span class="number">2</span> - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">				str[i + cnt_space * <span class="number">2</span> - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">				cnt_space--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：从后向前查找，挪动时是前方空格个数的2倍距离，复杂度为<span class="math inline">\(O(n)\)</span></p>
<h3 id="知识点总结">知识点总结</h3>
<ol type="1">
<li>C++ 字符数组的创建，以及结构（末尾'\0'）</li>
<li>数组替换是应从后向前，防止数据被污染</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer1_二维数组中的查找</title>
    <url>/archives/32378a1f.html</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<blockquote>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32M，其他语言64M</p>
</blockquote>
<p>题目链接：<a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">剑指offer1 二维数组中的查找</a></p>
<span id="more"></span>
<h2 id="c解题">C++解题</h2>
<h3 id="思路1遍历二维vector">思路1：遍历二维vector</h3>
<p>代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; array)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();++i) <span class="comment">//注意这里对于二维vector的操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;array[<span class="number">0</span>].<span class="built_in">size</span>();++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target==array[i][j])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：行列均遍历一遍，复杂度为<span class="math inline">\(O(n^2)\)</span></p>
<h3 id="思路2遍历列对行进行二分查找">思路2：遍历列，对行进行二分查找</h3>
<p>代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; array)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=array.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high=array[i].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;=high)  <span class="comment">//注意二分查找终止条件 &lt;=</span></span><br><span class="line">            &#123;</span><br><span class="line">                mid=(low+high)/<span class="number">2</span>; <span class="comment">//注意这里需要更新mid，不用严格考虑奇偶</span></span><br><span class="line">                <span class="comment">//注：为防止low+high溢出，则上方表达式应该为mid=low+(high-low)/2</span></span><br><span class="line">                <span class="keyword">if</span>(target==array[i][mid])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;array[i][mid])</span><br><span class="line">                    high=mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：列遍历一遍，行二分查找，复杂度为<span class="math inline">\(O(nlog(n))\)</span></p>
<h3 id="思路3根据数据信息选择从左下角右上角开始查找">思路3：根据数据信息，选择从左下角/右上角开始查找</h3>
<p>思路描述：因为每行从左到右依次变大，每列从上到下依次变大。以从右上角出发为例，若target大于该值则向下查询，若target小于该值则向左查询。因为比该值大的只可能在下方或下左方，比该值小的只可能在左方或者左下方，而从右上方开始搜索，最坏的情况为target不在数组中，此时需要搜索的次数是2n次，即时间复杂度为<span class="math inline">\(O(n)\)</span></p>
<p>代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; array)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 从右上角开始向左向下搜索</span></span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col=array[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">// 注意这里是n-1</span></span><br><span class="line">        <span class="keyword">while</span>(col&gt;=<span class="number">0</span>&amp;&amp;row&lt;array.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==array[row][col])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;array[row][col]) <span class="comment">// target大于当前位置，向下搜索</span></span><br><span class="line">                row=row+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// target小于当前位置，向左搜索</span></span><br><span class="line">                col=col<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：特殊查找类型，相当于只把某1行和某1列进行了查找，复杂度为<span class="math inline">\(O(n)\)</span></p>
<h3 id="知识点总结">知识点总结</h3>
<ol type="1">
<li>C++ STL的vector操作</li>
<li>二分查找mid的设置和更新，可以用while也可以用递归，记住边界条件</li>
<li>思路2、3中的搜索方法，值得记住</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>足球和我的故事</title>
    <url>/archives/4c58ca92.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6dda8efeb290e3685d1673e7983e7c0e0b8924c86f2b98f5faec6e06790da389">283549565e3b2714e95c29f56cf4001858a5720f754722287c54df53589cd4e0a14ea30473cc835025aabe5d3622c0f4c338319a70990f11e946e24acef02da38824fe2b6dbe8d8f68be7e74c17c4803c57362ab181739a41fb0fc8738aa6e4c31258431200d697b4055f2e8080352ef20cad6119d655f275dbd3276a09607396f3cfd89a0ce1d2abc2f19bb2ca629815cced9d3ff5dad75c1c4293ebd3171429207d195f4748b052f0dfb61f84fb9a42601c3a21f602e8101b98f468d4cccddbb82eac6ed93f206b61fea9b3e21df7f410b31bc171ac914f5d6329f2c4c8dea3d457f3e76b80b4f29504f0b5d0c766d66e303c7a676e17a659abc94f0fb3aa086cac95edaf1df576bf651ee3c8849c84ae9d427b54c7c905f96fc2dce3c02fe3ca6836c7d138ad227bdb3dd9494feff1f528e3c49bafd2b7863a86710c53eca16117ed2367763c992c889c25640e816e046967e202ed01484f5532a1da2cdfb2a53c7820960ecf2d7017572836358fb480462e2394a3ea88612a6d1a9fbc19e6d92ad1ef0c7c148a993c01fe0d7afd3839a00f63f93f3ab3da7c917818583a5d1b36a4894561eab911d1eb41580fa728d23caae69921419f90d1d6c7df5694be617c751d3483aee63bc9a394d2a7fb0482d206a8647dcc332d1cb81ad1f30feba8ba074155c2d9fe8ba40a85a7850cd28c674afc51f241859ba5dc83e06e9e2c2be66310de2f713f88abe210bf07f40b36c10fbfd871fa4b09e7c777c070ca6911255b59d79fea704d1bc9ddbb19387cab9e6b6c29bf4c05dc74ff69541b02328b3ff6cd9635cbeb57c0301fcd85b8d6eadf31208a5e62c9555182c214730e6213afd0992eedce66c00bd41d4d0584213578e31ad9b3a1258ac3bdc7594024ddf795f05f720a8b68e066ecdb4202706e982602edc5ea01db67f21bc4e12b1458077dbf35ec9bf6dcf61ebd4051bb2a98f7b6fae1564c716a466f18630bf2896762aad9e960d3d7c1f2452c6d6338c5bbb32fdbeec5989ca1631936b6e6db57f53c328da4d59ce1e64818edc4756eb8477ca72d5bf4081e4e2a24be85c4d9400c930d591b1a11bfbd1a364db4d41f21afae2e45ddd4cb66eb5c798b4a63ea9006ac28880434bb431fc5c6b54e3cfaf86f1367955034dd8c193677dcb10ed1bb11c720fdb0b97a6ea0ebc9b9c20dbb08cc37a65da9e4098b3463ff4963efdcb9128f337614dfda3e041805afb59d13642c5ffce1407e395396e68a6f00208b2f49f67844a26c78f78919ca79be0579812bf60cb1607366ca542028c67b738dbac0c09e4bd097ad265f10a15b2e71f55adbc635b9bfb62ed381b5052ed19aee38dc15488da0bb42ff6f6420a12d55b9a07f708058cfdf463602f6f04a411c725672837e881c33fca3b5652fc9e91e854e508814ac468bb968032f037c4e65ff5e7f61651cbbda4a8ab55a1a6df20a6276287889fafcdf283ad7aedf001b8fd7363f6626c1f5745fabf7086d33f504320d75c03743ef523a1cfa53a9286b5741aa72c81c90488047d3879a514e3cdb7168f51ffaf01a468e7da2731f1a0fbe7931f9b999dee4dddcda051c524baa7704b17099ea2bce18f8584468fa15312d3d1bf31be357f5d9dd3c82fa454636e3c1b9a462692b492bbbedde2e6275154ee685c57d5a911a4a86dbe5dcb2cc9b1b320895a599d3e5c028a310d9d8616408d92e100f3ab4975642787591009d30f09296de14d89e6dcfab6d6619a7d7eca3808f7fea078121c172b03e6c8f66683eb7be249c89e6d32d43da40257e7bcfd47715b44d387dbe7310b1e15c9a3ab002efbde6e1d1fa479cb22d84ce2fff485f6ba5a660353506cc9dd0727e7317f450d198e74f16c7ad4d1d25f65b5217e87ae64b233c82977e80a8bd19768925d4782052ea1bb92d7fe16e8f4db6649013ef2e6e3051e5a5a92c5d6b17b508611af8b342c4c0b54385063a490ea197a500f8e47f0541d298b7a073842bb4cc489cfce2d49571e3a6cdd498763d836fdf6a58f71536f592c7d66002798077db5f5c183afd379fb4bfe856e97f8d662defb5bfde9fd4fa69ed677645259722b2f26a5a9e3746a54dea2d2558691da33c4d0b06b3c4a9a9a75abf9867e71ba3a2d9fdc63091e4a3224dd642f38eb5ecdfc3fc9f353ecdb55b396bac35e1f8ff7c4a3088a9185b61aa8761741ab14b3156271387e0d5974991f5b34071c1975d3c83bf20c9ae0652208447407b64050c0516213a5207eb40dffe81c92e83735707cece7ad56dad6fe2267e95ab7ebdef7ae7098888275f8e2b73fa5ce6013d8adca70af2042b9b7677536e6640b5b3d6d2c5bf6450a6c8dd7aa550f96ab37e01b3da6a199e5217ab7cdee36fb01dc5aa669ab0be0c360899411f35702f78b82434c4fcda4f0adfe73af5ec11abb3a5a1fdc777fd86c648a16a402381c8a5a93386d48950156b05637e24b714a3394ef3223f3263454397a6df21dc7361e3002ebbbad79236baa5d8e96647ad0cd1da36909e4a9f0c34e4d321bc3dcb85739ceca839991d6dc4f791c3f12ecfb593ffd39ceeef595a8549192f7563574675fcbec62a78150ce7164aa11067900647d385f796092998368af705b16ca9a0d109039a818978454751a23b1fee30aecc82998ac9d596a86164858e66fae365f9d7bd715640b6aa29724b2489b9c28e2e770cb5b24212abbe0ff1e834c51a535d1515b644d1ae111c539e2671c663bfdb8e3ca4ac346c2093e7c62baa4bb465679ce5ce3a618efdcbca037b9de738af502a2436a0ada3d5b4a5382e133063c15415f545f91583d1b051d8f79e9cb75f094d7883d056c1282c1f28a69494e2ef59577e4fe1b8c07ea30e48dad765285cc804c8a6187a77efd5b0d9567ac735f44f4ef4bbb018abb28940442fc8588fd510b0758038456f570696e63347c8a512bd3446481256ff6dd8fb18eaeb6f22da0f2d32914aa13fde645aa4599f6ea908361b27b93d8f0dfdce825dd5677b387ca44e29eefe8b0cd180a5852c121d020eecfc3a6e127e6714c5c6a5aa208428348bd9e9d81ca0aed7b4da95811e681d4f3b3629b6d49e28f13940535e0e08a9fc9987c7eb2e9ca20d5ff782beddb1ec9e108d63fc999d8c05c6f353e4f8ccaa3af4fe3211e96d90470ef142ae36441f68b43c963edb97906e4a3fd4fcd97245b4df62fe8bf2964dcc6bab51cb33f51d5b90149582f570d9144e3369f8753859ecdc085cb42af54784715ac6c73cd7a299e8fe72d1ab823119bc1947c7e50e93e25c03d4c5e45b026e94180bd32c7bb045548a3efdcabbcb21adcca95774186c38954d8174aa0810ba40741ad014181a79d9c76e2da39ba50127cd1c169cf9eab49438d2d09ba1b8bae009d3f552e5273a2e6991382be2e7cc282c907ac38e7c3494a104a383e2b63d3ae69ccaf3e4853a977a2719d9ebd8430985f061cbd90bd69d34c9825f4f18c006988d863b6c1c4ec84831a3387f5fdd7ee589418a151e92a3f23a4a8a7a541f94d761a7b7c1ea0c55bca8ed3b22a57a18a8cde78b170ccf200e43bad5bca91fa857d5a2db5dc7d2f09e25fb561ab5c026e674d7c2ee4448fbd3d59a1ef0ed6fd673669473d70e29b8749b675b97e710697214de98fcb6737ebf1f69ab6e1030532bd39defa95cfe92ed26076946de87306c6b5e70235698cd1b0f65965bfd3523c3a364d0c3e9031551404c5c48d5a8d0bdabb92a7d014c6e475f1c49fdb16731e55c5a735bb9dbbe733c35d7154441700ba7e07112077f29270b26196e2a838a01719b165c93deec1fc72156914d5527e9592607ef3277854c2ac19946e1e5923d731586a666db9efb6809c00cd70ec3799353562d8c4f5159e1cc5f7fcdfb1433b79aa307c9d5d3b51b82209a5caea92823a092180b4f27e944141bce529357191ea1c47ba2a43a5b5a3a16f0af47c63580dabc0282047b53c35621b1a996d9ee7ece1fa7426c65f09b7dc7192b03476801560782d561cd009f4a4428188f9a286e077a9db598e1c52ad94b4cf955c448187cf6ef85e9af7cc42689659ce91aa16d5441ac5a6c9623fa28ad36585060c2fa1aa6b62dff306ef9f440df6706b431682d411d06b880e24c1e1fd064096d53d6293ac449a81b7c169d827c03c42bf71d6be091a7df462d79d9b2385b4856160ce36503d9c82f47a016e107762b6e7928ec1f36e692a92d8c34d2fcd2da9a296c902d1e8f03ce63b04db10dd193a626cf51139322681ab56b6c52fe6f330628e6270e25488f98659b6ddeae3ec9ee56f7b2c4dde512287f730735a69ec15e7bb920ebd4208ad61276c2f0304f6eac9d4ea638e6a0a56c62e114c026758fb6154a04060561768c1d5d28e5fe0cc91d65900d03e727b4f73351a0ec7e6022f26c7acaf2a64b077b642ed30bdcf6da9ff5595754c22cf870961aee4aa8dd30d971b3ae5536f5e1643b7b1fdd73a28efa8731f52bd5e6e30cd6293d49029addfa1f0e820732a07e878798f99cc8d888f52c71505c1615a40e03e75df09e1e4e9527ceaf9f109c63d404b33c27db74a730d5850c84d6bedd68be64643f18e5072669afbcf037ebe88921e9a13e9f13a551b97e8e4bb0702176d85e102cbf84079d3c451029226e25733631c8ceeaebf9310ca7a03bf767c8f1f841f9015c14ea1049a3cd76a6f0c9e177fc07808d4da7bfb3102bc34c47d1de81a4664ebc8b668e89fa1333bea65bae20b64fb474dc344245d4d3035057a30f670ca42beb77375225afeb2b1eff6d1e6602a0316b12a7f88c721b939633efb123c0bc66ee3552787409a82be4030fb5156acc0206dc199ccff716a666a00f3ea0e77580e191ef8a80e3699e58f64869fc610f876a93e66e955b8f88dc4ed1effc50dee838722898ae5575f0059ea1184d42f086044d2a1403b0d2a429262cda5dd056e16ef00c3996b8ceb592933a91bf52f1a6d5e7b7360c2123449ed997d66d2fdc47acd4df983e5b6d3b134f8b0cfcaa47e15f8f1784212d397578ad1d88ad2d5ea32130ebef282a4620584bdb455ddd401337df117725c1bb88a613b180f27dfb6a4b1d69877c24feda64cbe8c290b62d577ddfe2638ee36023b6cc7960e843048d1eba19b78bafcdbb151b00ffc33fbb01592a0ea86d6813199a9ddbf3c0c52835086ccf0c2d85ef190659426462e467df0998790cc865d91285bb86d5f16c6bb13873213ef75cf719979f5f7ca5c230dabaf5d046dc26a80e4842634fe61a0eef2440ba2ec0843313acad8945d5eeb07738c0b69eafb8ddffc1e993613e370728eee5e4edfa5ebd438d52798227b235a87f29d7aad877ef5cd870da3db78135925f61d5f29225aba32399d53f8a97cd80902515fc260c7099104007b12a8b2c7875ba0cd064ffbfc0b7a91d9a6a8a9106f492adf23e8826f883bd70af139d4edb153ddf915be80b9506961c2cacf98fb843d5ca74937e303c58e2f1a597de78c7bf5020d71e84bf8f8f37a9b94f465cb9b2babb0f47c0cdc99ffa4d2c1bb80b7c40af386af627098be2190374de5f984ec67e0a8553427f35b636caadb1c6bf3f9c3b062963b020e42f144150468a19b02a46fbb6aa9912cb8aaa8b5edd908f1546b56523e67705cab6acce914ca32c4191b1f9f0b9a3e868c33764bf9003a90a2873a1de39c46ce3df48861d54adf592f2d7751a1f45f666b438b353a17534cf1df8ba69984d4e93f1d615bf27ecb63a6942920a8bc8d7eb7bc18c40f64da74b629aa8f1e38b33678e6d87ccc428887b29d8d53651f76674dbe787ab3e455efe7d99b9d825dd54986467b71fed14296e20e59163760fc1baa131697ab006edc512e6bddfa25721e6647c937c131b63df45b96aec28d5d25888572190d51a63436dd2068b55f16dc8b8f641ea45f9254800bd745b8f69d491a7aa4f556c8f8c3efad8af9b61ce6afbeb31e9c47b46d5d4e8731906f06d8ee60817770c9707ad22ef26899e7e7638408e79edb068486309a62924f556b6b315c9c570b777e10252eb6631d8eb8bc02a41ff2fa6a49f704463db95ab265668c32d79a04fe5055821730cb006846485f50e7a56d4af8a937d70488abe8115a221f2116beefc83a209f610810830106924bb1830431399fd389c89a60c4ce7d97e25a01e52065f0fd6ebd5a6a2704915b5aaf8a04fdb361545defefebfa3f99aff13a651466e78297543af92779a4e730892bd8547412b1b1196193d03339c32139465d91c82293a219a8583973199de3b03da337e2c92b69e5563fbc386e50b59c7c75054b2079a378b3a3d5a230925ebc1f0747aca7a248f3656011d4155c127be423242c7800d18c418cb6bc590ba1cd4c8d7e55900849348b916c265291bc278b4d19ccee2558a71882eee2666ee9825f518b5d10d3a97d932c8819cdd4fb933970f8c77e2e51e23eedd009b9e043f860bd48f20533986ca043ecd71f3236ec2c57bbd2cdb90fed79db4f6799bb48802b0cb664aa7e44b026d9f1f74fc64868732256ee60c015ffa8edc53057a1a98dab3c4f3171f73f33f85c7274f448f79e390bf50c1142723c5b01c866861c07a888a29e86f890a80b67fee1a61f5ab75a020ab344abefe2823932e6d1f27896dcee42f8c756cdf278a56df4cd5cfd3925609e201dba949790d43a3f7078337cf120fe18942ccbf85dda156419dc17bd9a59c52b5bb9d76601d18569c9ac2795e8ba2e242b30b1749caf302f148893f81496b710b12a6890bc7c13b5cffc77f469933f3d0c815a7f0b7fc3b1daf6aff8c25a6855370e682f09adf30a21a2cc7adcd359c44d2f0fd9c8a7e66ba9a67d522dd4980ba95b0e75355554f4054847e7845d45705d954a91be1b39845b742154cc3d469facdcb270d7a04ffd8af5ac0cae6a7bfc5666cd1762317f123ef621eb51eebf94a1ee7e29731654197ae55e8a7e77923714f1b2c488321485ce7b0b4d81df9b34b2a64bce9c320a33ef176cd3ba6097bc59f446728285f85409a6b5e563c35849d0656533e549581b9a30019de4ea3ea94e01fbc2203444b60dfd177907fe10a4993a59d99674d1fb9311d9c4f3366156ae0127c45656fa88a66b91632b6a01e64d3acd5a06044859e5b45606c65ae7a86d52deecdcf79653abd62ec90c97365d945a9803b0ca4662e07bd2ae6b75985503879774fb41f63dd916ccf5f84deb6b2a81c705ef2af1570493fc08f417ff4fb6311d38e0cb1f70f2d0b9fecf6360c2b303f4f76749cc312821987263e79cc4237fafcaaf7cd93ff1e410d8d0ea808440dfef616dde26b666a25c5e569eed6074cffd3a9b3f5f937c4361a3cb3a6f71974a81cfe6cda0769cef3937470ed530997549caa7bd2f42986ca5e6931d5d4bef110516dfdeca51fa9d1aa7e814fa7b0f20e130d3fd4667ae0e686f99f3db2a062110f54a5f9c97ca634154e7cfdb1c9807353033e63b35b24a773e1d7d6cc0ac6566fd1b8a5ff282789774ca6c586ae5ffd8f1e42d57f3c6abfc3212cc68ef156622bef449c6619253cc77fdb732f21a82e138e37054cbb9c1880bdaab328726e0d97f365a47fe3c18da99a3324aafc8ccbca24d80e0cdda4473d3c4eeb8e547944f2d09a7bf7978548d570b8527368d18a2bc847bd6dfc3f3bc74d72f6e4ae9d33b44b7f54af571f729383bd9454958ae7a1dfc2e8bb7ee41c4a4807f84ce218859f5ed1b87a213d184704d6d013f7968d289f712859d0ed4648c8597135f3ce8ddcbd8ca17ca7bac5aefb38482d2a404289bb1ba5db569386c106e02e745ec2702a82fbad050552a262ad7a3f21de0ba739e1926784fbad75b40eed2d5e33d1d2d9232573bb5ab4c8ad1f85b26dc2b2ec625653608540308ee676599114472ff8aa763f32ec309a1aef4e7414eb0e853585b0cf00d9ab8e3d4d91a6de52c80fcdb81748de7c612598ed79861742a8ffc888548e276a412af27cd7179872e9af289ea037f00393e910d321cdcdec4b5972d9edd3f281db2c2f4911f3063107dede2e3d9f2017084b1816f9bb145d2e916628241fcea13dd324967a89d71c4f88398e7ca6e54a7903f08205fa1343c5eb37fee92dc5c162a5d744dba30ae554a50a180f0ab6cdb861c4dbf455dbe4c69041a916235ba68a5d4c5108ca81dbd050a76ee254280462dd5eb42439f1736466b9ff3d7ea50196b735a8594a35a02f219f761375fa176ac1328a75caef6f4d416a668d5b54bdcb5ca03931c14204647bf2698f08a5869380770b7d16e9f126ac279481850d12156b53b5757b103e345f55e80d60de65006cdfa7deebae7c5681c7e7964555807ec08cc57a3f3417c4911fc02d8b152c7302b4c0f0d66b5e40ec2d4db84a1535abb242f324ac3aa3ef85d7c72db838dd2f521434ff234ee1f5b8c5af10b6b786a4fe24d94acd17d6c3befcc09105e7c201522362b07a2661e021e4e995fd0550329517bc248c353a0e42b8094369e4d6511d6a26a72d26fb0362bdbb3871a0190c4a368b9b682c2252a98fad54186294d2126a10fa203d2e14b68f0385d92f4fe800c727e4747cc0e0a97e472da9fd44142b7cf9d5865a2082d4f8a676d6094ef78013d5c00d05bd1065a0a8c1cb8d4d00a44c04226afb4cd30be7f633ed1e67b6640b7e15435efcf885e7ec942c4628b8de9175d8f1f2a3b541105a2bde6c75cc64cc9b414d905716184abf0740b6c699d421c70810f31ffb183e744e27e5d5a328e057d45eff388c5867a394e4a062d673e98ae16f251adc3aa1d0f7614df15a34313415684f66f461bcc5f8e70a6c075ea6389d66ad387fb441833f40a4a99f9b6f4cee983ba1f4b4c64c4ba290704ab79d47012cccb0623f1142516beeed7d7286049178e244b8c9b899db8ce6a9cccf187e213d45b98344a48b1e769e46a46e5ce9018b40e5c6c7a61a35e918f7c03391a6e91137c44d7ace0e0757767cc8492e88a40a410e632436f797c03a9e1458a0d71574cd2976c141ddbe0ffc90426604507a8db0fe960592724d210358015865c01f513a885f2322f8d2505f0f36807e0dd487b5b3da283e78ed66134fcdd844699bd2cafd518d8eaa368c3d1b70950c2d186b2bbe93009aeb39eb06e92560135e6d8a48dabcfad2b8ea0bd4875ff7066f7663a124f7679e578b60bc6e1031b2ea213aa06f0f8d63156d97bb97ff24bba4c98b87569a25d91342cc53294257eeebddb8fb1f2fa93832ccba6fee1b4bf1b9c6ebe8adf166a88c45480b08eecf4bf0ff5098ae11a0053552a5c138cdfd4e5ba7f41204121e7c5c7acd129dc1b9de0fa355f66a84ddcc0582f59392712584f450095897d2272972e10993905d44bf3098a61f62cd5e420f6f711924888fc4668bcdf154bf3d5759f4fa44cf7950035a51f00ae62e8ac28a53feb82c3062e9cb9e58c1cb9f67da793d86de693f63a33e8fd4dec5ff7a75e24c415c2ffb302ff0ddd890e01734e2a9e4ee0686ec1216edce9160c83da2dba327003666d89e0063b436ae1442ffa3abf05469296fb4f657c2f7c1dffaa26b23c6ccc29e3c4e343968a417d8755ff7af0c22b14ff8da669aa1dc208ad1815693f6e7b6579c6279d036557632482a439fa483f578db43b18bbb310377544a0f3e4f474860665bccc0055b7e2e58be21970ff377312fef90cda304f41d87503dd43666b0026509b29ec9001007639825ae3322359a6989357a595d412b695a5c402fb59a6443fc3f39bdccca70ad5a918fa61683a6b6bf93013b2965921e32f2e153ce4718b4429631e1beaa41a7ae89c289e7bcce9ed8a802b1490b5ba7e01329642d7daa8599ffeb9e42bf666865a40e5d163b91071809d3c8d606c65bf0b4f6c3c21135f149a1d4d11337c477bc390c98d4f5931814399987927cbf161a6326eacbef4da88cc1bd1e29169b55d9fb1a118bac20d52bfe69eee2c57d787b15bca640cb00220e791f5173e09147bd6ade3f9c4e8c579b0b233a60d7d96b81eeae4836b3e8d3446ba2650d235c97c035e3b63f57af34374bfb4baf4b16f61c5be35f941815637fbd92f5c818d02f9054071db50ddd645c5252daf383c68d13d3b2c5ff96933354ffc9ebef10c7250380424bf45cd787900a5c54ab36b4c5bc80047488923b4fe92ce7ab68bb3e7951784ae2ab7fa1eb23ca6a58cfcd97fbc0df49236e074c9772317f4a98c8bf59c16498438aebd99e914b293b69a4004b88c681901b298069e04ebfcb36ca1f3c01c44ae45effd02e28a922e8881b5474f842d413b8afc26b96a32ac216e854a8d034cb090921d8ac7128b41f06f97fcbc6c6ded94636ad7f461584bd8046b28bbad3ee6089f87a26abf976efed303eae785fb569a12f1c97014e3fd010961dac27cb02b9ee16d5f1bc7d70b94c5ceb05c53f5837935842ec0c9b082ee1e14379808fc09880588b788354045751fddc09b20f423ef8b3f45b928a3a12274c11889d311a4075aa5685090e35973005d96469968e3d49a45f215eafce9a7fb5868e29266aad3fa7ce369cad8a8c0a9e7322743c9d0a9f3fdcc49826cb175e393a7bd0d8cd1a8e851348d4a98fa8df0f28c914476700e899891d28518b42436f1bad3727f508cabc1a5821dee59b775efeacd8aa634f5fcf4ce0646bfd71d3ca6adaa31813f0cf0ce5c6d72845bf5ebcb1fa55f7af671497d7cc77e21cecf3aadfe011473daa0b75854bd7e178f666a17b3ac2fc3daadf8166f4c2eaa58994299d9d11763f39f13d1907c7b862ebd77799d843b632c372cdb914114c8e38b5b0271b25df5c4e766f10ada0961f47816a3a70c2c315efa46b8d0a78cb25487c242a2a03f9764d7699d09612c67f72cfec52c60014ceb274640cf8359c6f126944c7decfb095db6202c22e931bd15cdacf15388d2fdb810bd967163b963c4cda9684fd585d2251d80fec8ce39649a6aae995bdec8f2eff2156d6d19</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请在此输入密码">请在此输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>思考</category>
        <category>足球</category>
      </categories>
      <tags>
        <tag>足球</tag>
        <tag>思考</tag>
        <tag>访谈</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建 Hexo+Next</title>
    <url>/archives/57027c96.html</url>
    <content><![CDATA[<blockquote>
<p>又一次做了修改哈哈哈，目前重新搭了一下所有的环境，沿用了next的Gemini主题，配置了很多有的没得，感谢几位大佬，学到了很多。这次直接在hexo的source/_data中对主题进行了修改，所以之后next更新后，不会有过多的影响，只有归档页的格式对主题中的一些文件进行了修改，其他均未在主题文件中进行改动。</p>
<p>主要参考：<a href="https://tding.top/">小丁的博客</a></p>
<p>back2top小猫：<a href="http://yearito.cn/posts/hexo-theme-beautify.html">yearito</a></p>
<p>归档&amp;分类样式参考：<a href="https://jrbcode.gitee.io/posts/be9758cd.html">CodeHeap</a></p>
</blockquote>
<span id="more"></span>
<h3 id="使用手册">使用手册</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% 新建文件，可以在`scaffolds`目录下修改模板</span><br><span class="line">$ hexo new [post] <span class="string">&quot;My New Post&quot;</span> % []内的post可以省略</span><br><span class="line">$ hexo new draft <span class="string">&quot;draft name&quot;</span></span><br><span class="line">$ hexo new page <span class="string">&quot;page name&quot;</span></span><br><span class="line"></span><br><span class="line">% 部署到本地server</span><br><span class="line">$ hexo clean % 清理</span><br><span class="line">$ hexo douban % 拉豆瓣数据</span><br><span class="line">$ hexo generate % 渲染生成静态文件</span><br><span class="line">$ hexo server % 部署到本地server % 后两句可以改为一句 hexo s -g</span><br><span class="line"></span><br><span class="line">% 部署到github</span><br><span class="line">$ hexo deplogy -g</span><br><span class="line"></span><br><span class="line">% 简化语句，可以将n个命令合并到`package.json`中</span><br><span class="line">% 加入语句 <span class="string">&quot;cgd&quot;</span>: <span class="string">&quot;hexo clean &amp; hexo douban &amp; hexo generate &amp; hexo deploy&quot;</span></span><br><span class="line">$ npm run cgd </span><br></pre></td></tr></table></figure>
<h3 id="主题美化">主题美化</h3>
<blockquote>
<p>详见开头参考文献</p>
</blockquote>
<h3 id="部署vps">部署VPS</h3>
<blockquote>
<p>目前未实现，想做的话，之后可以参考前端大佬的blog：<a href="https://tding.top/">小丁</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
